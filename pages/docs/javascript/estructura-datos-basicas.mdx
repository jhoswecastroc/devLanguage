import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Estructura de Datos Básicas

En la programación, una estructura de datos es simplemente una manera de organizar y almacenar datos de manera que se pueden utilizar eficientemente. Estas estructuras varían en complejidad, desde los tipos de datos simples mencionados hasta estructuras más complicadas que se abordarán en temas avanzados. JavaScript, como muchos otros lenguajes de programación, utiliza estas estructuras para facilitar el manejo de la data y hacer operaciones más eficientes y menos propensas a errores.

## ¿Qué son las Variables?

En programación, una variable es una ubicación de memoria nombrada capaz de contener datos que pueden ser modificados durante la ejecución del programa. Piensa en una variable como un "contenedor" para almacenar información que tu programa puede necesitar. Esta información puede cambiar o variar mientras el programa se ejecuta, de ahí el término "variable".

Las variables son esenciales porque permiten a los programas ser dinámicos y reaccionar a diferentes entradas y condiciones sin necesidad de cambiar el código del programa. Por ejemplo, si estás escribiendo un programa que procesa la entrada del usuario, puedes almacenar esta entrada en una variable y luego usarla en varias operaciones a lo largo de tu programa.

### Funciones de las Variables

- **Almacenamiento de Datos:** Las variables actúan como almacenes de datos. Pueden guardar cualquier tipo de dato que JavaScript admita, como números, cadenas de texto, objetos, etc.
- **Facilitación del Reuso de Datos:** Puedes usar el valor de una variable muchas veces en tu código sin necesidad de repetir el dato real. Esto hace que el código sea más limpio y más fácil de mantener.
- **Flexibilidad en Programación:** Las variables permiten que los programas realicen operaciones en datos abstractos sin conocer los valores específicos antes de la ejecución del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

Considera un programa que calcula el área de un círculo. La fórmula para calcular el área es 𝜋𝑟2, donde 𝑟 es el radio del círculo. Al almacenar el radio en una variable, puedes cambiar el tamaño del círculo simplemente actualizando el valor de la variable, sin cambiar el código que calcula el área.

```js copy filename="JavaScript"
let radio = 5;
const pi = 3.14159;
let area = pi * radio * radio;
console.log("El área del círculo es: " + area);
```

Este enfoque muestra cómo una variable (radio) puede ser usada para calcular el área de un círculo con diferentes radios simplemente cambiando su valor, demostrando la utilidad de las variables en la adaptabilidad de los programas a diferentes datos de entrada.

Las variables son, por lo tanto, una herramienta indispensable en la caja de herramientas de cualquier programador, permitiendo la creación de programas flexibles y eficientes que pueden operar con datos dinámicos.

### Nombramiento de Variables

El nombramiento de variables es una parte esencial de la programación en JavaScript, al igual que en cualquier otro lenguaje de programación. El nombre de una variable debe ser descriptivo y claro, reflejando su contenido y propósito dentro del programa. Esto no solo mejora la legibilidad del código, sino que también facilita la mantenibilidad y la colaboración entre desarrolladores.

**Reglas Básicas para Nombrar Variables**

1. **Inicio de Nombres:** Los nombres de las variables deben comenzar con una letra (mayúscula o minúscula), un guion bajo (\_) o un signo de dólar ($). No pueden comenzar con dígitos.
2. **Caracteres Permitidos:** Después del primer carácter, puedes usar letras, dígitos, guiones bajos y signos de dólar.
3. **Sensibilidad a Mayúsculas:** JavaScript es sensible a mayúsculas y minúsculas. Por ejemplo, variable, Variable, y VARIABLE son consideradas tres entidades distintas.
4. **Palabras Reservadas:** Existen ciertas palabras reservadas que no pueden ser usadas como nombres de variables porque JavaScript las utiliza para otras funciones del lenguaje, como if, for, let, const, entre otras.

<h4 className="font-medium mt-5">Ejemplo de Buen Nombramiento</h4>

```js copy filename="JavaScript"
let contadorDeUsuarios = 100; // Claro y descriptivo
const COLOR_PRIMARIO = "#4A90E2"; // Uso de mayúsculas para constantes, descriptivo
```

<h4 className="font-medium mt-5">Ejemplo de Mal Nombramiento</h4>

```js copy filename="JavaScript"
let a = 25; // ¿Qué representa "a"?
let data = "2022-01-01"; // Poco descriptivo, ¿qué tipo de data es?
```

**Importancia del Nombramiento Adecuado**

El correcto nombramiento de variables es crucial para:

- **Legibilidad del Código:** Hace que el código sea más fácil de leer y entender.
- **Mantenimiento:** Facilita la detección de errores y la actualización del código.
- **Colaboración:** Permite que otros desarrolladores comprendan el código más rápidamente, facilitando la colaboración y la revisión de código.

El nombramiento efectivo no solo impacta la calidad del código, sino que también optimiza el proceso de desarrollo al hacer que el código sea más accesible y entendible para todos los involucrados en el proyecto.

<Callout emoji="👀" type="default">
  Adoptar convenciones de nombramiento claras y consistentes es una práctica
  fundamental en la programación. Mientras más intuitivo sea el nombre de una
  variable, menor será la carga cognitiva para el programador al revisar o
  modificar el código. Así, se promueve no solo un mejor entendimiento del
  código, sino también una mayor eficiencia en el proceso de desarrollo.
</Callout>

### Declaración de variables

La declaración de variables es un paso fundamental en cualquier programa de JavaScript, ya que establece los nombres y los contextos en los que se almacenarán y manipularán los datos durante la ejecución del programa entonces declarar una variable implica informar al intérprete de JavaScript sobre la intención de utilizar un identificador para referirse a algún dato. Esto se hace mediante el uso de palabras clave específicas que preparan el entorno de ejecución para asignar espacio en memoria y gestionar el acceso a ese espacio.

**Palabras Clave para la Declaración**

En JavaScript, existen principalmente tres palabras clave que se pueden utilizar para declarar variables:

- **var:** Esta es la forma más antigua de declarar variables en JavaScript. Las variables declaradas con var tienen un alcance de función o global si se declaran fuera de cualquier función. Sin embargo, debido a sus peculiaridades en el manejo del alcance y el hoisting, su uso ha disminuido con las nuevas actualizaciones del lenguaje.
- **let:** Introducida en ES6 (ECMAScript 2015), let permite declarar variables con un alcance limitado al bloque, la declaración, o la expresión donde se usa. Esto mejora significativamente la gestión del código, haciendo que el alcance de las variables sea más predecible y evitando errores comunes asociados con var.
- **const:** También introducida en ES6, const se utiliza para declarar variables cuyo valor no se pretende que cambie una vez asignado. Al igual que let, const tiene un alcance de bloque, lo que refuerza la escritura de código inmutable donde se requiere.

<h4 className="font-medium mt-5">Ejemplo</h4>

Aquí te muestro cómo podríamos declarar variables utilizando estas palabras clave, adaptando los ejemplos para ilustrar claramente su sintaxis sin utilizar los ejemplos del recurso proporcionado:

```js copy filename="JavaScript"
// Declaración usando var
var contador; // Declarada, pero aún no inicializada

// Declaración usando let
let nombreUsuario; // Lista para ser utilizada en un bloque específico

// Declaración usando const
const PI = 3.14159; // Debe ser inicializada en su declaración
```

Cada una de estas declaraciones prepara el terreno para que la variable correspondiente sea utilizada en operaciones subsecuentes dentro del programa, almacenando datos que pueden ser tan simples como un número o tan complejos como un objeto de configuración.

<Callout emoji="👀" type='default'>

También podemos declarar varias variables al mismo tiempo, a esto se llama Declaración Multiple, en donde se declaran múltiples variables en una sola línea, separadas por comas.

Esto aumenta la compacidad del código, pero puede afectar a la legibilidad si se abusa de ella, por ello hay que saber cuando usarlo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let x = 1,
  y = 2,
  z = 3;
```

</Callout>

**Importancia de Elegir la Palabra Clave Adecuada**

- **Flexibilidad y Seguridad:** let y const ofrecen un mejor control sobre donde y como las variables afectan al programa, reduciendo los errores en tiempo de ejecución debido a colisiones o modificaciones no intencionadas de variables.
- **Claridad en el Código:** Usar const cuando los datos no deben cambiar hace el código más fácil de entender y mantener, ya que define claramente las intenciones del desarrollador.

### Inicialización de Variables

La inicialización de variables es un paso crucial en la programación que sigue a la declaración. Este proceso implica asignar un valor inicial a la variable, estableciendo así el estado inicial que puede ser utilizado o modificado durante la ejecución del programa. En JavaScript, la inicialización puede ser tan simple como asignar un número, una cadena de texto, el resultado de una función, o incluso el valor de otra variable.

**Métodos de Inicialización**

En JavaScript, la inicialización de variables puede realizarse de varias maneras, dependiendo de las necesidades del programa y del estilo de codificación preferido:

1. **Inicialización Directa Durante la Declaración:** Es el método más directo y comúnmente usado. Combina la declaración y la inicialización en una sola instrucción.

```js copy filename="JavaScript"
let edad = 30; // Declara e inicializa la variable 'edad'
```

En este ejemplo, edad es una variable que se declara y al mismo tiempo se inicializa con el valor 30.

2. **Inicialización Separada de la Declaración:** A veces, especialmente en situaciones donde el valor inicial depende de condiciones o cálculos que no están disponibles inmediatamente, la inicialización se realiza después de la declaración.

```js copy filename="JavaScript"
let temperatura;
temperatura = calcularTemperaturaMedia(); // Inicialización posterior a la declaración
```

Aquí, la variable temperatura se declara primero sin un valor y se inicializa más tarde con el resultado de una función calcularTemperaturaMedia.

3. **Inicialización con Referencia a Otra Variable:** Las variables también pueden ser inicializadas usando el valor de otra variable ya existente.

```js copy filename="JavaScript"
let alturaOriginal = 175;
let altura = alturaOriginal; // Inicialización usando el valor de otra variable
```

**altura** se inicializa con el mismo valor que alturaOriginal, que es 175.

**Importancia de una Inicialización Adecuada**

Inicializar variables correctamente es fundamental por varias razones:

- **Evitar Valores Indefinidos:** Reduce la probabilidad de errores derivados de variables no inicializadas, que en JavaScript se representan como undefined.
- **Fundamento para Operaciones Futuras:** Asegura que las variables estén listas para ser usadas en cálculos u otras operaciones desde el inicio.

### Declaraciones y Modo Estricto

**Historia y Evolución del Modo Estricto**

El modo estricto en JavaScript ("use strict") es una funcionalidad introducida con ECMAScript 5 en 2009. Esta directiva fue diseñada para proporcionar una forma de optar por una versión más segura y mejor optimizada del lenguaje. Al utilizar "use strict", JavaScript cambia su comportamiento en varias formas importantes para ayudar a evitar errores comunes y facilitar un código más robusto.

**¿Cómo Funciona el Modo Estricto?**

El modo estricto se activa al colocar la cadena "use strict"; en la parte superior de un archivo JavaScript o al inicio de una función. Esta simple línea altera el comportamiento del compilador de JavaScript de varias maneras cruciales:

1. **Eliminación de las Declaraciones Implícitas:** Antes de ES5, JavaScript permitía la declaración implícita de variables, lo que podría causar problemas de gestión de memoria y conflictos en el ámbito de las variables. Con el modo estricto, cualquier intento de usar una variable sin declararla primero resulta en un error, evitando así el uso accidental de variables globales.

```js copy filename="JavaScript"
"use strict";
x = 3.14; // Error: x no está definida
```

2. **Errores en Asignaciones a Propiedades no Existentes:** En el modo no estricto, si intentas asignar un valor a una propiedad que no existe, JavaScript la crea. En modo estricto, esto también resultará en un error, evitando mutaciones no intencionadas de objetos.

```js copy filename="JavaScript"
"use strict";
let obj = {};
obj.count = 1; // Funciona bien si la propiedad existe
obj.unkownProp = 123; // Error si la propiedad no existe y es una tipografía
```

3. **Protección contra Cambios Accidentales en Objetos Inmutables:** El modo estricto lanza errores si intentas modificar objetos que no son modificables (congelados) o expandir objetos que no son extensibles.

```js copy filename="JavaScript"
"use strict";
let frozenObj = Object.freeze({ name: "Immutable" });
frozenObj.name = "Mutable"; // Error: intento de modificar una propiedad congelada
```

**Uso de "use strict"; en Práctica**

El modo estricto es altamente recomendable en todos los nuevos proyectos JavaScript por varias razones:

- **Mejora la Seguridad del Código:** Al prevenir acciones potencialmente inseguras como la contaminación global.
- **Facilita la Depuración:** Al convertir los errores que serían silenciados en excepciones, facilita la identificación de problemas.
- **Prepara el Código para Futuras Versiones de JavaScript:** Muchas características de ES6 y posteriores presuponen que el código sigue las mejores prácticas introducidas en modo estrict

**Activación del Modo Estricto**

Aquí un ejemplo de cómo se puede activar el modo estricto en un script completo o una función individual:

```js copy filename="JavaScript"
// Modo estricto para todo el script
"use strict";
function doSomething() {
  // este código también está en modo estricto
}

// Modo estricto solo para esta función
function doSomethingElse() {
  "use strict";
  // solo el código dentro de esta función está en modo estricto
}
```

El modo estricto es una herramienta poderosa que ayuda a escribir código más seguro y entender mejor el funcionamiento interno de JavaScript, evitando prácticas que pueden llevar a errores difíciles de rastrear. Al adoptarlo, los desarrolladores pueden mejorar significativamente la calidad y la seguridad de sus aplicaciones.

### Reasignación de Variables

En el contexto de JavaScript, la reasignación de variables se refiere al proceso de cambiar el valor almacenado en una variable que ya ha sido declarada. Este es un concepto fundamental en programación, dado que permite que los datos sean dinámicos y modificables a lo largo del tiempo, adaptándose a las necesidades del flujo del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

Considera el siguiente ejemplo para ilustrar la reasignación:

```js copy filename="JavaScript"
let mensaje = "¡Hola Mundo!";
console.log(mensaje); // Salida: ¡Hola Mundo!

// Reasignando la variable
mensaje = "¡Hola de nuevo!";
console.log(mensaje); // Salida: ¡Hola de nuevo!
```

Inicialmente, la variable mensaje se inicializa con el valor "¡Hola Mundo!". Luego, se reasigna con un nuevo valor "¡Hola de nuevo!". Este proceso sobrescribe el valor anterior almacenado en la variable.

**Conceptos Clave de Reasignación**

1. **Mutabilidad:** En JavaScript, las variables declaradas con let o var son mutables, lo que significa que sus valores pueden cambiar a lo largo del tiempo. Esto es crucial para casos de uso como contadores en bucles, acumuladores en funciones y manejo de estado en aplicaciones.
2. **Tipado Dinámico:** JavaScript es un lenguaje de tipado dinámico, lo que permite que una variable pueda reasignarse a valores de diferentes tipos. Por ejemplo, una variable inicialmente asignada con un número puede reasignarse luego con una cadena de texto, un booleano, o incluso estructuras más complejas como objetos y arreglos.

```js copy filename="JavaScript"
let dato = 42;
dato = "cambio de tipo"; // válido en JavaScript
```

3. **Implicaciones de Rendimiento:** Reasignar variables puede tener implicaciones en el rendimiento de la aplicación, especialmente en bucles o funciones críticas. Es importante gestionar bien cuándo y cómo se reasignan las variables para mantener el código eficiente y legible.

## Constantes

En JavaScript, el uso de la palabra clave const introduce constantes, que son "contenedores" donde se puede almacenar información que no se modificará después de su inicialización inicial. Esto brinda una manera robusta y segura de manejar valores que no deben cambiar a lo largo de la ejecución de un programa, contribuyendo a la claridad y la mantenibilidad del código.

### Características de const

1. **Inicialización Obligatoria:**

Una constante debe ser inicializada en el momento de su declaración. Esto asegura que siempre tenga un valor antes de su uso y evita la creación de constantes que puedan estar indefinidas.

```js copy filename="JavaScript"
const greeting = "Hello, world!"; // Correcto
const name; // Incorrecto, generará un error
```

2. **Inmutabilidad de la Asignación:**

Una vez asignado el valor inicial, no se puede cambiar. Cualquier intento de reasignar un valor a una constante resultará en un error.

```js copy filename="JavaScript"
const pi = 3.14159;
pi = 3.14; // Error, no se puede reasignar el valor de una constante
```

3. **Uso de Constantes en Cálculos y Configuraciones:**

A menudo, las constantes se utilizan para definir valores que no deben ser modificados después de su configuración inicial. Esto puede incluir configuraciones de aplicación, como URLs de APIs o claves de configuración que son sensibles y no deben ser alteradas.

```js copy filename="JavaScript"
const API_URL = "https://api.example.com";
```

4. **Optimización de Rendimiento:**

El uso de const puede permitir optimizaciones por parte del motor JavaScript porque el motor sabe que el valor no cambiará y puede hacer optimizaciones en consecuencia.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo donde se usa const para definir el número de iteraciones en un bucle, facilitando cambios durante el desarrollo sin necesidad de buscar y reemplazar valores crudos en el código.

```js copy filename="JavaScript"
const MAX_ITERATIONS = 5;

for (let i = 0; i < MAX_ITERATIONS; i++) {
  console.log(`Iteración número ${i + 1}`);
}
```

### Consideraciones Adicionales

En este ejemplo, cambiar el número de iteraciones es tan simple como ajustar el valor de MAX_ITERATIONS. Esto es especialmente útil en entornos de desarrollo donde tales valores pueden necesitar ser ajustados frecuentemente.

Aunque const previene la reasignación del valor de la constante, es importante notar que si el valor es un objeto o un array, los contenidos del objeto o array pueden ser modificados. Esto es porque const asegura la inmutabilidad del enlace de la variable, no del valor en sí si es un objeto.

```js copy filename="JavaScript"
const data = { key: "value" };
data.key = "newValue"; // Esto es permitido
```

Esta flexibilidad permite el uso de const con estructuras de datos complejas, ofreciendo al mismo tiempo la seguridad de que el enlace al objeto no cambiará.

El uso de const es un pilar en el desarrollo JavaScript moderno por su claridad y seguridad que ofrece, asegurando que los valores que deben ser constantes lo sean, lo cual es crucial para el mantenimiento y la robustez del código.

## Scope

El scope, ámbito o alcance en JavaScript es fundamental para entender cómo se gestionan y acceden las variables a lo largo de un programa. Este concepto determina dónde las variables son accesibles dentro del código.

El scope se refiere a la región del código donde una variable es accesible. JavaScript define principalmente dos tipos de scope: global y local. Cada función crea un nuevo scope local por defecto, donde las variables declaradas dentro de la función no pueden ser accedidas fuera de ella. Este diseño ayuda a evitar conflictos de nombres y mantiene el código más limpio y organizado.

### Funcionamiento del Scope

Cuando una variable es utilizada en JavaScript, el intérprete sigue un proceso para determinar dónde buscar esa variable. Este proceso comienza en el scope actual donde se está ejecutando el código y, si no encuentra la variable, continúa buscando en el scope superior, hasta llegar al scope global. Si la variable no se encuentra en ningún scope, se produce un error ReferenceError.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos el siguiente código para entender mejor cómo funciona el scope:

```js copy filename="JavaScript"
let color = "blue"; // Variable global

function printColor() {
  let message = "The color is "; // Variable local de la función printColor
  console.log(message + color); // Accede a la variable global 'color'
}

printColor(); // Output: "The color is blue"
// console.log(message);  // Esto generaría un ReferenceError: message is not defined
```

En este ejemplo, color es una variable global accesible desde cualquier parte del programa, incluyendo dentro de la función printColor. Sin embargo, la variable message es local a la función printColor y no puede ser accedida fuera de ella.

### Importancia del Scope

El correcto manejo del scope tiene varias ventajas clave:

1. **Seguridad:** Limita la visibilidad de las variables a las partes del programa que realmente necesitan acceso a ellas, protegiendo los datos de accesos no autorizados.
2. **Reducción de Bugs:** Evita problemas relacionados con la reutilización inadvertida de nombres de variables en diferentes partes del programa, lo cual puede llevar a bugs difíciles de rastrear.
3. **Eficiencia en la Gestión de la Memoria:** Al limitar el ciclo de vida de las variables al scope donde son necesarias, el sistema puede liberar recursos más eficientemente una vez que ya no están en uso.

### Tipos de Scope

JavaScript maneja principalmente dos tipos de scopes que son fundamentales para entender cómo se comportan las variables y funciones dentro del programa. Estos son el Global Scope y el Local Scope, y cada uno tiene sus particularidades que afectan la visibilidad y el ciclo de vida de las variables.

1. **Global Scope**

Cuando una variable se declara fuera de cualquier función o bloque, se le asigna un Global Scope. Esto significa que cualquier script o función en el mismo entorno puede acceder a esta variable. Las variables globales permanecen accesibles durante toda la vida útil del programa y pueden ser modificadas por cualquier parte del código, lo que a veces puede llevar a resultados inesperados si no se manejan cuidadosamente.

```js copy filename="JavaScript"
var globalVar = "Soy una variable global";

function displayVar() {
  console.log(globalVar); // Accede a la variable global desde dentro de una función
}

displayVar(); // Muestra: Soy una variable global
console.log(globalVar); // Muestra: Soy una variable global
```

2. **Local Scope**

Las variables con Local Scope están declaradas dentro de una función o un bloque y solo pueden ser accesibles dentro de ese contexto específico. Este aislamiento ayuda a evitar conflictos de nombres y mantiene el código más seguro y modular. Hay dos subtipos principales de local scope:

a. **Function Scope**

Cualquier variable declarada dentro de una función cae bajo el Function Scope, lo que significa que solo puede ser accesible desde dentro de la función en la que se declara.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function localScopeExample() {
  var localVar = "Soy local a esta función";
  console.log(localVar); // Funciona bien
}

localScopeExample();
console.log(localVar); // Error: localVar is not defined
```

b. **Block Scope (introducido con ES6)**

Con la llegada de ES6, let y const introdujeron el Block Scope, donde las variables declaradas dentro de bloques (definidos por llaves {} como en condicionales y loops) son accesibles solo dentro de ese bloque.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
if (true) {
  let blockScopedVar = "Visible solo dentro de este bloque";
  console.log(blockScopedVar); // Muestra correctamente
}

console.log(blockScopedVar); // Error: blockScopedVar is not defined
```

**Scope de let y const**

El ámbito de las variables (scope) en JavaScript es fundamental para controlar la accesibilidad y la visibilidad de las variables a lo largo del código. Con la introducción de let y const en ECMAScript 2015 (ES6), JavaScript proporcionó herramientas más robustas para la gestión del scope en comparación con var, que era más limitado y propenso a errores comunes de programación.

1. **Ámbito Global**

El ámbito global significa que las variables están disponibles a través de todo el código del mismo contexto de ejecución, es decir, son accesibles desde cualquier parte del script o consola donde fueron declaradas.

**Características:**

Al declarar con let o const en el ámbito global, las variables no se añaden al objeto global (como window en navegadores), a diferencia de var, que sí lo hace. Esto es importante para evitar conflictos en entornos globales, especialmente en el desarrollo web.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let globalLet = "Accesible desde cualquier parte del código";
console.log(window.globalLet); // undefined en navegador, `globalLet` no está en `window`
```

2. **Ámbito Local: Block Scope**

let y const tienen ámbito de bloque (block scope), lo que significa que solo son accesibles dentro del bloque donde fueron declaradas y sus sub-bloques.

**Ventajas:**

- Esto previene errores comunes como la contaminación del ámbito global, donde variables inesperadas afectan otras partes del código.
- Mejora la gestión de la memoria al eliminar las variables una vez que el bloque ha terminado su ejecución.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function testBlockScope() {
  if (true) {
    let blockScopedVar = "Visible dentro de este bloque";
    console.log(blockScopedVar); // Muestra "Visible dentro de este bloque"
  }
  console.log(blockScopedVar); // Error: blockScopedVar no está definido fuera del bloque
}
testBlockScope();
```

3. **Bloques Anidados**

En JavaScript, los bloques anidados son bloques de código que están dentro de otros bloques de código, típicamente estructurados dentro de estructuras de control como bucles o condiciones, así como en funciones.

**Características de let y const:**

Las variables declaradas con let o const dentro de un bloque anidado solo son accesibles dentro de ese bloque específico y no fuera de él. Esto ayuda a prevenir interferencias de variables cuando se ejecutan ciclos o condiciones múltiples.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function outerFunction() {
  let outerVar = "Visible en la función externa y sus bloques internos";

  if (true) {
    let innerVar = "Visible solo en este bloque interno";
    console.log(outerVar); // Correcto: Accede a la variable del ámbito superior
    console.log(innerVar); // Correcto: Accede a la variable en su propio ámbito
  }

  console.log(innerVar); // Error: innerVar no está definida en este ámbito
}
outerFunction();
```

**Uso Práctico y Consideraciones de Diseño**

- **Organización del Código:** Utilizar let y const ayuda a mantener el código organizado y claro. Limita el uso de variables a donde realmente se necesitan y evita efectos secundarios no deseados de variables que permanecen accesibles más allá de su utilidad.
- **Mejores Prácticas:**
  - **Inicialización Condicional:** En algunos casos, puede ser útil inicializar una variable dentro de un bloque condicional, asegurando que su alcance y su uso estén limitados al contexto relevante.
  - **Gestión de Recursos:** Al limitar el ámbito de las variables, let y const permiten una mejor gestión de los recursos al desasignar memoria que ya no es necesaria una vez que el bloque ha terminado su ejecución.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function processItems(items) {
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    // Procesa cada item aquí
    console.log(item); // Accesible solo dentro del bucle
  }
  console.log(i); // Error: i no está definida fuera del bucle
  console.log(item); // Error: item no está definida fuera del bucle
}
processItems(["apple", "banana", "cherry"]);
```

**Scope de var**

El uso de var en JavaScript se asocia tradicionalmente con dos ámbitos principales: global y funcional. A diferencia de let y const, que introducen un control de ámbito de bloque, var se maneja de manera menos restrictiva, lo que puede conducir a comportamientos inesperados si no se maneja con cuidado.

1. **Ámbito Global**

Cuando var se utiliza fuera de cualquier función, la variable se añade al objeto global (por ejemplo, window en navegadores), haciéndola accesible desde cualquier parte del script.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
var globalExample = "Disponible globalmente";
function accessGlobal() {
  console.log(globalExample); // Accede a la variable global
}
accessGlobal(); // Imprime: Disponible globalmente
console.log(globalExample); // Imprime: Disponible globalmente
```

**Ámbito Funcional:**

Las variables declaradas con var dentro de una función no son accesibles fuera de esa función, pero sí en cualquier lugar dentro de ella, independientemente de los bloques de código.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function functionScopeExample() {
  var functionScoped = "Visible dentro de la función";
  if (true) {
    var alsoFunctionScoped = "También visible en toda la función";
  }
  console.log(functionScoped); // Visible dentro de la función
  console.log(alsoFunctionScoped); // También visible en toda la función
}
functionScopeExample();
console.log(functionScoped); // Error: functionScoped no está definido
```

**Problemas Comunes y Soluciones con var**

- **Elevación de Variables (Hoisting):** Las variables declaradas con var son elevadas al inicio de su contexto funcional o global, lo que significa que están técnicamente "definidas" desde el comienzo del bloque de función o global, pero sin inicialización hasta su línea de declaración. En el siguiente tema profundizaremos en este tema.

- **Re-declaración sin Restricciones:** A diferencia de let y const, re-declarar una variable con var en el mismo ámbito no genera error, lo que puede llevar a sobreescrituras inadvertidas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
var redeclare = "Primero";
var redeclare = "Segundo";
console.log(redeclare); // Imprime: Segundo
```

**Implicaciones del Uso de var**

El uso de var puede ser adecuado en contextos donde la compatibilidad con versiones antiguas de JavaScript es crítica, pero generalmente se considera una práctica obsoleta en desarrollo moderno debido a sus peculiaridades y la falta de control de ámbito de bloque. Herramientas modernas como Babel permiten la transpilación de código moderno let y const a var para mantener la compatibilidad sin sacrificar las buenas prácticas de desarrollo.

### Hoisting

Hoisting en JavaScript es un comportamiento automático del intérprete que afecta cómo se gestionan las declaraciones de variables y funciones. Este mecanismo puede parecer confuso al principio, pero una vez comprendido, ayuda a evitar errores comunes y mejora la estructuración del código.

**Detalles Técnicos del Hoisting**

1. **Proceso de Compilación y Ejecución:** Aunque JavaScript es un lenguaje interpretado, realiza una compilación en tiempo de ejecución justo antes de ejecutar el código. Durante esta fase, el intérprete procesa todas las declaraciones de variables y funciones moviéndolas al inicio de su ámbito respectivo. Esto es lo que llamamos "hoisting".

2. **Variables y la Inicialización:**

- **Con var:** Las variables declaradas con var son hoisted y automáticamente inicializadas a undefined. Esto permite que las variables se utilicen de alguna forma antes de su línea de declaración efectiva.

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(value); // Muestra `undefined` porque la inicialización con `undefined` es hoisted
var value = 100;
```

- **Con let y const:** Estas declaraciones también son hoisted, pero no se inicializan, creando la "zona temporal muerta" (TDZ) donde el acceso a ellas antes de su inicialización explícita arroja un error.

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(value); // ReferenceError: value is not initialized
let value = 100;
```

3. **Funciones y Hoisting:**

- **Las funciones declaradas** son completamente hoisted, lo que significa que tanto su declaración como su definición son movidas al inicio del ámbito. Esto permite que las funciones sean llamadas antes de que aparezcan textualmente en el código.

```js copy filename="JavaScript"
hello(); // Funciona correctamente y muestra "Hello"
function hello() {
  console.log("Hello");
}
```

- **Expresiones de Función:** A diferencia de las funciones declaradas, las expresiones de función dependen del tipo de variable usada para su declaración (var, let, const). Si se usa var, el nombre de la variable es hoisted pero no su asignación funcional.

```js copy filename="JavaScript"
hello(); // TypeError: hello is not a function
var hello = function () {
  console.log("Hello");
};
```

Este proceso de hoisting se aplica de manera consistente en todos los ámbitos, ya sea global o local dentro de funciones, pero no atraviesa los límites de estas últimas, manteniendo las definiciones confinadas dentro del ámbito funcional a menos que se especifique lo contrario. Este mecanismo subraya la importancia de entender cómo y dónde declarar variables y funciones para mantener el código claro y predecible.

4. **Implicaciones del Hoisting:**

- **Claridad del Código:** Uno de los principales beneficios del entendimiento profundo del hoisting es la capacidad de organizar el código de manera que refleje la verdadera funcionalidad. Sabiendo que las declaraciones serán movidas al inicio, los desarrolladores pueden optar por colocarlas explícitamente en la parte superior de sus ámbitos para mejorar la legibilidad y evitar comportamientos inesperados.
- **Errores Comunes:** Sin un adecuado entendimiento de hoisting, es fácil caer en trampas comunes como usar una variable antes de su inicialización adecuada, especialmente cuando se usan let y const que están sujetas a la TDZ.

5 **Buenas Prácticas:**

- **Declaraciones al Inicio:** Para maximizar la claridad y prevenir errores, es recomendable declarar todas las variables y funciones al inicio de sus ámbitos respectivos. Esto no solo alinea el código fuente con el comportamiento del intérprete debido al hoisting, sino que también hace que el código sea más fácil de entender y mantener.
- **Uso Cauteloso de var:** Dada la naturaleza de var de hoistear e inicializar con undefined, su uso puede llevar a errores sutiles, especialmente en bloques de código complejos. La preferencia moderna es utilizar let y const, que ofrecen un control de ámbito más granular y previenen modificaciones accidentales gracias a la TDZ.

7. **Hoisting y las Funciones Flecha:**

- A diferencia de las funciones tradicionales y las expresiones de función, las funciones flecha no tienen su propio this, ni son hoisted. Esto significa que deben ser declaradas antes de su uso, lo que puede influir en la decisión de usar una función flecha versus una función tradicional dependiendo del contexto y la necesidad de hoisting.

```js copy filename="JavaScript"
greet(); // ReferenceError: greet is not defined
const greet = () => console.log("Hello");
```

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
function processUser() {
  console.log(name); // undefined debido a hoisting con `var`
  var name = "Sarah";
  innerFunction();

  function innerFunction() {
    console.log(name); // Sarah, porque 'name' es accesible aquí debido al hoisting
  }
}
processUser();
```

Este ejemplo destaca cómo el hoisting permite acceso a la variable name dentro de innerFunction() a pesar de ser declarada después en el texto del código. Sin embargo, el primer console.log(name) muestra undefined porque aunque name es hoisted, su inicialización no lo es.

### Fases del Scope

El manejo del scope en JavaScript es un concepto central para entender cómo las variables y funciones son accesibles en diferentes partes del código. El scope de una variable define en qué partes del código una variable es accesible. Para comprender mejor, es crucial distinguir entre las dos fases principales en el manejo del scope: la fase de compilación y la fase de ejecución.

**Fase de Compilación**

Durante la fase de compilación, JavaScript realiza un proceso conocido como "levantamiento" o "hoisting", como hemos mencionado anteriormente, donde las declaraciones de variables y funciones son movidas al inicio de su scope antes de que el código sea ejecutado. Este proceso implica dos subfases importantes:

1. **Creación de Contextos de Ejecución:** Antes de que el código comience a ejecutarse, el motor de JavaScript configura el entorno para la ejecución. Esto incluye la creación de contextos de ejecución global y funcional, donde el contexto global abarca el código fuera de todas las funciones, mientras que cada función crea un nuevo contexto funcional.
2. **Registro de Identificadores:** Dentro de cada contexto de ejecución, se realiza un paso crucial: el registro de todas las variables (declaradas con var, let, const) y las declaraciones de funciones en el "hoisting". Las variables declaradas con var son inicializadas con undefined, mientras que las declaradas con let y const no se inicializan hasta que el código de su declaración es ejecutado realmente.

**Fase de Ejecución**

Una vez que el contexto de ejecución está establecido y las variables están registradas durante la compilación, la fase de ejecución maneja cómo y cuándo las variables son accesibles en el código. Este es el momento en que realmente se asignan y utilizan los valores de las variables y funciones.

1. **Ejecución de Código:** Durante esta fase, el código es ejecutado línea por línea. Las variables declaradas con let y const que fueron temporalmente inaccesibles (en una zona muerta temporal hasta su declaración) ahora se inicializan en el momento que su declaración es ejecutada en el código.
2. **Acceso a Variables:** El acceso a las variables durante la ejecución sigue las reglas del scope establecido:

- **Global Scope:** Variables declaradas globalmente o fuera de cualquier función están accesibles desde cualquier parte del código.
- **Function Scope:** Variables declaradas dentro de una función sólo son accesibles dentro de esa función y no fuera de ella.
- **Block Scope:** Introducido con let y const, permite que las variables sean accesibles solo dentro del bloque de código ({}) donde fueron declaradas.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo para ilustrar cómo let y const manejan el block scope, a diferencia de var que maneja el function scope:

```js copy filename="JavaScript"
if (true) {
  var varVariable = "Visible";
  let letVariable = "Visible Only Inside";
  const constVariable = "Also Visible Only Inside";
}
console.log(varVariable); // Output: "Visible"
console.log(letVariable); // Error: letVariable is not defined
console.log(constVariable); // Error: constVariable is not defined
```

En este ejemplo, varVariable es accesible fuera del bloque if porque var no tiene block scope, sino function scope. Por otro lado, letVariable y constVariable no son accesibles fuera del bloque if porque let y const respetan el block scope.

## Breves palabras sobre las funciones

Las funciones en JavaScript son estructuras fundamentales que permiten encapsular bloques de código para su reutilización y organización. Funcionan como pequeños programas dentro del programa principal, donde cada función puede recibir entradas, procesar información y devolver salidas.

### ¿Cómo Definir una Función?

Las funciones se definen utilizando la palabra clave function, seguida de un nombre opcional (en el caso de funciones anónimas) y un conjunto de paréntesis que pueden incluir parámetros. Aquí tienes un esquema básico:

```js copy filename="JavaScript"
function nombreDeLaFuncion(parametro1, parametro2) {
  // Cuerpo de la función
}
```

Por ejemplo, una función simple para sumar dos números sería:

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}
```

### Ejecución de Funciones

Una función solo se ejecuta cuando es llamada. Esto se hace usando el nombre de la función seguido de paréntesis, opcionalmente incluyendo argumentos si se requieren:

```js copy filename="JavaScript"
let resultado = sumar(5, 3);
console.log(resultado); // Muestra 8
```

## Sombreado de Variables

El sombreado de variables es una técnica en JavaScript que permite a los desarrolladores redefinir una variable dentro de un ámbito local que tiene el mismo nombre que una variable en un ámbito más amplio o global. Este enfoque puede ser útil para manejar situaciones donde diferentes partes de un programa requieren valores diferentes para una variable que comparte el mismo nombre.

### Detalles Técnicos del Sombreado

1. **Detalles Técnicos del Sombreado**

**Global vs. Local:** Una variable global existe durante la vida útil de una aplicación y es accesible desde cualquier parte del código. Una variable local, sin embargo, sólo existe dentro del bloque donde se define y oculta cualquier variable global del mismo nombre sólo dentro de ese contexto específico.

<h4 className="font-medium mt-5">Ejemplos</h4>

```js copy filename="JavaScript"
let message = "Global message";
function showMessage() {
  let message = "Local message";
  console.log(message); // Accede al mensaje local: "Local message"
}
showMessage();
console.log(message); // Accede al mensaje global: "Global message"
```

En este ejemplo, message dentro de showMessage sombrea al message global, demostrando cómo el ámbito local puede tener preferencia sobre el global.

2. **Ámbito de Bloque:**

JavaScript con let y const introduce el ámbito de bloque, que limita la vida de la variable al bloque, declaración o expresión donde se utiliza. Esto es diferente de var, que define variables con ámbito funcional o global sin importar donde se declaren dentro de la función.

**Implicaciones del Sombreado**

El sombreado permite una flexibilidad considerable en la programación, pero también requiere que los programadores sean meticulosos en la gestión de ámbitos para evitar efectos no deseados. Las variables locales pueden llevar el mismo nombre que las globales sin interferencia, siempre y cuando su manipulación se mantenga dentro del ámbito apropiado.

**Casos de Uso Avanzados**

En situaciones complejas donde múltiples funciones o bloques requieren diferentes versiones de la misma variable, el sombreado puede simplificar la gestión del estado local sin alterar el estado global. Esto es especialmente útil en aplicaciones grandes donde diferentes módulos o componentes pueden necesitar comportarse de manera independiente pero aún interactuar con recursos compartidos de manera controlada.

### Consideraciones Adicionales

- **Riesgos:** El exceso de sombreado puede llevar a código que es difícil de seguir y mantener. Es vital que los nombres de las variables sean elegidos para reflejar claramente su uso y ámbito, reduciendo la posibilidad de errores lógicos.
- **Herramientas de Linting:** Herramientas como ESLint pueden ayudar a identificar problemas potenciales con el sombreado y otros problemas de ámbito en el código, asegurando mejores prácticas en el desarrollo.

## Ejercicios

A continuación, presento una serie de quizes, preguntas y ejercicios diseñados para ayudarte a consolidar tu comprensión sobre los conceptos básicos de JavaScript que hemos discutido. Cada ejercicio incluye una solución para que puedas verificar tu trabajo.

### Quizes

<h4 className="font-medium mt-5">¿Qué es una variable en JavaScript?</h4>

<p className="my-2">a) Una función que almacena datos</p>
<p>b) Un contenedor para almacenar datos</p>
<p className="my-2">c) Un tipo de bucle</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Un contenedor para almacenar datos</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Qué palabra clave en JavaScript declara una variable que no puede ser
  reasignada?
</h4>

<p className="my-2">a) let</p>
<p>b) var</p>
<p className="my-2">c) const</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) const</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  En JavaScript, ¿cuál de las siguientes opciones representa una práctica
  correcta de nombramiento de variables?
</h4>

<p className="my-2">a) Comenzar con un número</p>
<p>b) Usar espacios entre palabras</p>
<p className="my-2">c) Usar camelCase</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Usar camelCase</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Cuál es el resultado de una variable declarada con var fuera de cualquier
  función?
</h4>

<p className="my-2">a) Scope global</p>
<p>b) Scope local</p>
<p className="my-2">c) No tiene scope</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Scope global</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">¿Qué es el hoisting en JavaScript?</h4>

<p className="my-2">a) Priorizar la ejecución de funciones</p>
<p>b) Elevar las declaraciones de variables al inicio de su contexto</p>
<p className="my-2">c) Ignorar declaraciones de variables</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Elevar las declaraciones de variables al inicio de su contexto
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Qué sucede cuando intentas reasignar una variable const?
</h4>

<p className="my-2">a) La variable es reasignada sin problemas</p>
<p>b) Se lanza un error de tipo</p>
<p className="my-2">c) Se ignora la reasignación</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Se lanza un error de tipo</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Qué método se utiliza para imprimir información en la consola de JavaScript?
</h4>

<p className="my-2">a) console.print()</p>
<p>b) console.log()</p>
<p className="my-2">c) console.output()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) console.log()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Qué describe mejor el 'scope' de una variable en JavaScript?
</h4>

<p className="my-2">a) El valor de la variable</p>
<p>b) El tipo de la variable</p>
<p className="my-2">c) El área del programa donde la variable es accesible</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      c) El área del programa donde la variable es accesible
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Qué es sombreado de variables en JavaScript?
</h4>

<div className="my-2">
  a) Cambiar el valor de una variable global dentro de una función
</div>
<p>b) Declarar una nueva variable local con el mismo nombre que una global</p>
<p className="my-2">c) Eliminar una variable global</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Declarar una nueva variable local con el mismo nombre que una global
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Cuál es una característica de las funciones en JavaScript?
</h4>

<p className="my-2">a) No pueden retornar valores</p>
<p>b) No pueden contener otras funciones</p>
<p className="my-2">c) Pueden contener otras funciones</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Pueden contener otras funciones</AccordionContent>
  </AccordionItem>
</Accordion>

### Preguntas

<h4 className="font-medium mt-5">
  ¿Cómo diferirías el uso de var, let y const en la declaración de variables?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      - **var** es la forma más antigua de declarar variables y tiene un scope a nivel de función o global si se declara fuera de una función. Se debería usar con precaución, principalmente en situaciones donde la compatibilidad con navegadores antiguos es necesaria.
      - **let** permite declarar variables con un scope limitado al bloque, declaración o expresión donde se usa. Es útil en la mayoría de los casos donde se requiere cambiar el valor de la variable después de su inicialización, como en bucles o condicionales.
      - **const** se utiliza para declarar variables que no deben cambiar su valor inicial una vez asignado, es decir, son constantes. Su scope también es de bloque y ayuda a garantizar que los valores no sean reasignados, lo cual es útil para configuraciones y valores que no deberían cambiar a lo largo del tiempo.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Puede explicar cómo el scope global afecta la seguridad y la gestión de la
  memoria en una aplicación web?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El uso de variables globales puede llevar a problemas de seguridad ya que cualquier script incluido en la página puede acceder y modificar estas variables, potencialmente llevando a comportamientos no deseados o ataques de tipo XSS (Cross-Site Scripting). En cuanto a la gestión de memoria, las variables globales permanecen en memoria durante todo el ciclo de vida de la página, lo que puede llevar a un uso ineficiente de recursos si las variables acumulan grandes cantidades de datos o si no se liberan adecuadamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Describe un escenario donde el hoisting podría causar un bug en el código.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Supongamos que intentas utilizar una variable antes de declararla con var, pensando que sería undefined, pero otro bloque de código anterior en el mismo scope la ha inicializado con un valor diferente. Por ejemplo:

      ```js copy filename="JavaScript"
      function ejemploHoisting() {
        console.log(miVar); // Esperas undefined, pero muestra 'Hola'
        var miVar = 'Mundo';
      }
      var miVar = 'Hola';
      ejemploHoisting();
      ```

      Aquí, el hoisting causa que miVar se declare al inicio de la función, pero toma el valor del miVar global inicializado previamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Cómo podrías implementar el sombreado de variables para manejar
  configuraciones regionales en una aplicación?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Podrías tener una configuración regional global definida para toda la aplicación y luego, en funciones específicas que manejan lógica relacionada con localidades específicas, podrías declarar variables locales (sombreadas) que tengan configuraciones ajustadas a esas localidades. Esto permite una gran flexibilidad y mantiene el código limpio y modular.

      ```js copy filename="JavaScript"
      var configuracionGlobal = { moneda: 'USD', idioma: 'en' };
      function mostrarPrecios() {
        var configuracionGlobal = { moneda: 'EUR', idioma: 'es' }; // Sombreado
        console.log('Configuración usada:', configuracionGlobal);
      }
      mostrarPrecios();
      console.log('Configuración global:', configuracionGlobal);
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Cuál es la importancia de inicializar variables correctamente en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Inicializar variables correctamente ayuda a evitar errores en tiempo de ejecución, facilita la lectura y mantenimiento del código, y asegura que las variables sean utilizadas con los valores esperados desde su primer uso, previniendo comportamientos indeseados o bugs difíciles de rastrear.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¿Cómo afecta use strict al comportamiento de las declaraciones de variables en
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El modo 'use strict' impide la declaración implícita de variables globales, lo cual ayuda a prevenir errores comunes como asignaciones a variables no declaradas. Esto conduce a un código más seguro y predecible, obligando a los desarrolladores a declarar explícitamente sus variables antes de usarlas.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Discute cómo y por qué podrías usar console.table() en el desarrollo de una
  aplicación.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      console.table() es útil para mostrar datos tabulares, como listas de objetos, en un formato legible en la consola. Esto es especialmente útil en el desarrollo cuando necesitas inspeccionar listas de datos, resultados de pruebas o cualquier información estructurada. Ayuda a visualizar rápidamente las propiedades y valores de los objetos sin necesidad de iterar manualmente a través de ellos.

    </AccordionContent>

  </AccordionItem>
</Accordion>

### Ejercicios

<h4 className="font-medium mt-5">
  Declara dos variables, base y altura de un triángulo. Inicialízalas con 10 y 5
  respectivamente. Calcula el área (area = (base * altura) / 2) e imprímelo con
  console.log().
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquí tu código JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let base = 10;
        let altura = 5;
        let area = (base * altura) / 2;
        console.log("El área del triángulo es:", area);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Crea una constante PI y asígnale 3.14159. Usa esta constante para calcular el
  área de un círculo con radio 4. Imprime el resultado.
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquí tu código JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const PI = 3.14159;
        let radio = 4;
        let areaCirculo = PI * radio * radio;
        console.log("El área del círculo es:", areaCirculo);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Declara una variable global color y asígnale "rojo". Dentro de una función,
  declara una variable local color y asígnale "azul". Muestra ambos colores
  usando console.log() dentro y fuera de la función.
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquí tu código JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let color = "rojo";
        function cambiarColor() {
          let color = "azul";
          console.log("Color dentro de la función:", color);
        }
        cambiarColor();
        console.log("Color fuera de la función:", color);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>
