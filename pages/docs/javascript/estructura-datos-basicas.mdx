import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Estructura de Datos Bﾃ｡sicas

En la programaciﾃｳn, una estructura de datos es simplemente una manera de organizar y almacenar datos de manera que se pueden utilizar eficientemente. Estas estructuras varﾃｭan en complejidad, desde los tipos de datos simples mencionados hasta estructuras mﾃ｡s complicadas que se abordarﾃ｡n en temas avanzados. JavaScript, como muchos otros lenguajes de programaciﾃｳn, utiliza estas estructuras para facilitar el manejo de la data y hacer operaciones mﾃ｡s eficientes y menos propensas a errores.

## ﾂｿQuﾃｩ son las Variables?

En programaciﾃｳn, una variable es una ubicaciﾃｳn de memoria nombrada capaz de contener datos que pueden ser modificados durante la ejecuciﾃｳn del programa. Piensa en una variable como un "contenedor" para almacenar informaciﾃｳn que tu programa puede necesitar. Esta informaciﾃｳn puede cambiar o variar mientras el programa se ejecuta, de ahﾃｭ el tﾃｩrmino "variable".

Las variables son esenciales porque permiten a los programas ser dinﾃ｡micos y reaccionar a diferentes entradas y condiciones sin necesidad de cambiar el cﾃｳdigo del programa. Por ejemplo, si estﾃ｡s escribiendo un programa que procesa la entrada del usuario, puedes almacenar esta entrada en una variable y luego usarla en varias operaciones a lo largo de tu programa.

### Funciones de las Variables

- **Almacenamiento de Datos:** Las variables actﾃｺan como almacenes de datos. Pueden guardar cualquier tipo de dato que JavaScript admita, como nﾃｺmeros, cadenas de texto, objetos, etc.
- **Facilitaciﾃｳn del Reuso de Datos:** Puedes usar el valor de una variable muchas veces en tu cﾃｳdigo sin necesidad de repetir el dato real. Esto hace que el cﾃｳdigo sea mﾃ｡s limpio y mﾃ｡s fﾃ｡cil de mantener.
- **Flexibilidad en Programaciﾃｳn:** Las variables permiten que los programas realicen operaciones en datos abstractos sin conocer los valores especﾃｭficos antes de la ejecuciﾃｳn del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

Considera un programa que calcula el ﾃ｡rea de un cﾃｭrculo. La fﾃｳrmula para calcular el ﾃ｡rea es 撩愚搗2, donde 搗 es el radio del cﾃｭrculo. Al almacenar el radio en una variable, puedes cambiar el tamaﾃｱo del cﾃｭrculo simplemente actualizando el valor de la variable, sin cambiar el cﾃｳdigo que calcula el ﾃ｡rea.

```js copy filename="JavaScript"
let radio = 5;
const pi = 3.14159;
let area = pi * radio * radio;
console.log("El ﾃ｡rea del cﾃｭrculo es: " + area);
```

Este enfoque muestra cﾃｳmo una variable (radio) puede ser usada para calcular el ﾃ｡rea de un cﾃｭrculo con diferentes radios simplemente cambiando su valor, demostrando la utilidad de las variables en la adaptabilidad de los programas a diferentes datos de entrada.

Las variables son, por lo tanto, una herramienta indispensable en la caja de herramientas de cualquier programador, permitiendo la creaciﾃｳn de programas flexibles y eficientes que pueden operar con datos dinﾃ｡micos.

### Nombramiento de Variables

El nombramiento de variables es una parte esencial de la programaciﾃｳn en JavaScript, al igual que en cualquier otro lenguaje de programaciﾃｳn. El nombre de una variable debe ser descriptivo y claro, reflejando su contenido y propﾃｳsito dentro del programa. Esto no solo mejora la legibilidad del cﾃｳdigo, sino que tambiﾃｩn facilita la mantenibilidad y la colaboraciﾃｳn entre desarrolladores.

**Reglas Bﾃ｡sicas para Nombrar Variables**

1. **Inicio de Nombres:** Los nombres de las variables deben comenzar con una letra (mayﾃｺscula o minﾃｺscula), un guion bajo (\_) o un signo de dﾃｳlar ($). No pueden comenzar con dﾃｭgitos.
2. **Caracteres Permitidos:** Despuﾃｩs del primer carﾃ｡cter, puedes usar letras, dﾃｭgitos, guiones bajos y signos de dﾃｳlar.
3. **Sensibilidad a Mayﾃｺsculas:** JavaScript es sensible a mayﾃｺsculas y minﾃｺsculas. Por ejemplo, variable, Variable, y VARIABLE son consideradas tres entidades distintas.
4. **Palabras Reservadas:** Existen ciertas palabras reservadas que no pueden ser usadas como nombres de variables porque JavaScript las utiliza para otras funciones del lenguaje, como if, for, let, const, entre otras.

<h4 className="font-medium mt-5">Ejemplo de Buen Nombramiento</h4>

```js copy filename="JavaScript"
let contadorDeUsuarios = 100; // Claro y descriptivo
const COLOR_PRIMARIO = "#4A90E2"; // Uso de mayﾃｺsculas para constantes, descriptivo
```

<h4 className="font-medium mt-5">Ejemplo de Mal Nombramiento</h4>

```js copy filename="JavaScript"
let a = 25; // ﾂｿQuﾃｩ representa "a"?
let data = "2022-01-01"; // Poco descriptivo, ﾂｿquﾃｩ tipo de data es?
```

**Importancia del Nombramiento Adecuado**

El correcto nombramiento de variables es crucial para:

- **Legibilidad del Cﾃｳdigo:** Hace que el cﾃｳdigo sea mﾃ｡s fﾃ｡cil de leer y entender.
- **Mantenimiento:** Facilita la detecciﾃｳn de errores y la actualizaciﾃｳn del cﾃｳdigo.
- **Colaboraciﾃｳn:** Permite que otros desarrolladores comprendan el cﾃｳdigo mﾃ｡s rﾃ｡pidamente, facilitando la colaboraciﾃｳn y la revisiﾃｳn de cﾃｳdigo.

El nombramiento efectivo no solo impacta la calidad del cﾃｳdigo, sino que tambiﾃｩn optimiza el proceso de desarrollo al hacer que el cﾃｳdigo sea mﾃ｡s accesible y entendible para todos los involucrados en el proyecto.

<Callout emoji="汨" type="default">
  Adoptar convenciones de nombramiento claras y consistentes es una prﾃ｡ctica
  fundamental en la programaciﾃｳn. Mientras mﾃ｡s intuitivo sea el nombre de una
  variable, menor serﾃ｡ la carga cognitiva para el programador al revisar o
  modificar el cﾃｳdigo. Asﾃｭ, se promueve no solo un mejor entendimiento del
  cﾃｳdigo, sino tambiﾃｩn una mayor eficiencia en el proceso de desarrollo.
</Callout>

### Declaraciﾃｳn de variables

La declaraciﾃｳn de variables es un paso fundamental en cualquier programa de JavaScript, ya que establece los nombres y los contextos en los que se almacenarﾃ｡n y manipularﾃ｡n los datos durante la ejecuciﾃｳn del programa entonces declarar una variable implica informar al intﾃｩrprete de JavaScript sobre la intenciﾃｳn de utilizar un identificador para referirse a algﾃｺn dato. Esto se hace mediante el uso de palabras clave especﾃｭficas que preparan el entorno de ejecuciﾃｳn para asignar espacio en memoria y gestionar el acceso a ese espacio.

**Palabras Clave para la Declaraciﾃｳn**

En JavaScript, existen principalmente tres palabras clave que se pueden utilizar para declarar variables:

- **var:** Esta es la forma mﾃ｡s antigua de declarar variables en JavaScript. Las variables declaradas con var tienen un alcance de funciﾃｳn o global si se declaran fuera de cualquier funciﾃｳn. Sin embargo, debido a sus peculiaridades en el manejo del alcance y el hoisting, su uso ha disminuido con las nuevas actualizaciones del lenguaje.
- **let:** Introducida en ES6 (ECMAScript 2015), let permite declarar variables con un alcance limitado al bloque, la declaraciﾃｳn, o la expresiﾃｳn donde se usa. Esto mejora significativamente la gestiﾃｳn del cﾃｳdigo, haciendo que el alcance de las variables sea mﾃ｡s predecible y evitando errores comunes asociados con var.
- **const:** Tambiﾃｩn introducida en ES6, const se utiliza para declarar variables cuyo valor no se pretende que cambie una vez asignado. Al igual que let, const tiene un alcance de bloque, lo que refuerza la escritura de cﾃｳdigo inmutable donde se requiere.

<h4 className="font-medium mt-5">Ejemplo</h4>

Aquﾃｭ te muestro cﾃｳmo podrﾃｭamos declarar variables utilizando estas palabras clave, adaptando los ejemplos para ilustrar claramente su sintaxis sin utilizar los ejemplos del recurso proporcionado:

```js copy filename="JavaScript"
// Declaraciﾃｳn usando var
var contador; // Declarada, pero aﾃｺn no inicializada

// Declaraciﾃｳn usando let
let nombreUsuario; // Lista para ser utilizada en un bloque especﾃｭfico

// Declaraciﾃｳn usando const
const PI = 3.14159; // Debe ser inicializada en su declaraciﾃｳn
```

Cada una de estas declaraciones prepara el terreno para que la variable correspondiente sea utilizada en operaciones subsecuentes dentro del programa, almacenando datos que pueden ser tan simples como un nﾃｺmero o tan complejos como un objeto de configuraciﾃｳn.

<Callout emoji="汨" type='default'>

Tambiﾃｩn podemos declarar varias variables al mismo tiempo, a esto se llama Declaraciﾃｳn Multiple, en donde se declaran mﾃｺltiples variables en una sola lﾃｭnea, separadas por comas.

Esto aumenta la compacidad del cﾃｳdigo, pero puede afectar a la legibilidad si se abusa de ella, por ello hay que saber cuando usarlo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let x = 1,
  y = 2,
  z = 3;
```

</Callout>

**Importancia de Elegir la Palabra Clave Adecuada**

- **Flexibilidad y Seguridad:** let y const ofrecen un mejor control sobre donde y como las variables afectan al programa, reduciendo los errores en tiempo de ejecuciﾃｳn debido a colisiones o modificaciones no intencionadas de variables.
- **Claridad en el Cﾃｳdigo:** Usar const cuando los datos no deben cambiar hace el cﾃｳdigo mﾃ｡s fﾃ｡cil de entender y mantener, ya que define claramente las intenciones del desarrollador.

### Inicializaciﾃｳn de Variables

La inicializaciﾃｳn de variables es un paso crucial en la programaciﾃｳn que sigue a la declaraciﾃｳn. Este proceso implica asignar un valor inicial a la variable, estableciendo asﾃｭ el estado inicial que puede ser utilizado o modificado durante la ejecuciﾃｳn del programa. En JavaScript, la inicializaciﾃｳn puede ser tan simple como asignar un nﾃｺmero, una cadena de texto, el resultado de una funciﾃｳn, o incluso el valor de otra variable.

**Mﾃｩtodos de Inicializaciﾃｳn**

En JavaScript, la inicializaciﾃｳn de variables puede realizarse de varias maneras, dependiendo de las necesidades del programa y del estilo de codificaciﾃｳn preferido:

1. **Inicializaciﾃｳn Directa Durante la Declaraciﾃｳn:** Es el mﾃｩtodo mﾃ｡s directo y comﾃｺnmente usado. Combina la declaraciﾃｳn y la inicializaciﾃｳn en una sola instrucciﾃｳn.

```js copy filename="JavaScript"
let edad = 30; // Declara e inicializa la variable 'edad'
```

En este ejemplo, edad es una variable que se declara y al mismo tiempo se inicializa con el valor 30.

2. **Inicializaciﾃｳn Separada de la Declaraciﾃｳn:** A veces, especialmente en situaciones donde el valor inicial depende de condiciones o cﾃ｡lculos que no estﾃ｡n disponibles inmediatamente, la inicializaciﾃｳn se realiza despuﾃｩs de la declaraciﾃｳn.

```js copy filename="JavaScript"
let temperatura;
temperatura = calcularTemperaturaMedia(); // Inicializaciﾃｳn posterior a la declaraciﾃｳn
```

Aquﾃｭ, la variable temperatura se declara primero sin un valor y se inicializa mﾃ｡s tarde con el resultado de una funciﾃｳn calcularTemperaturaMedia.

3. **Inicializaciﾃｳn con Referencia a Otra Variable:** Las variables tambiﾃｩn pueden ser inicializadas usando el valor de otra variable ya existente.

```js copy filename="JavaScript"
let alturaOriginal = 175;
let altura = alturaOriginal; // Inicializaciﾃｳn usando el valor de otra variable
```

**altura** se inicializa con el mismo valor que alturaOriginal, que es 175.

**Importancia de una Inicializaciﾃｳn Adecuada**

Inicializar variables correctamente es fundamental por varias razones:

- **Evitar Valores Indefinidos:** Reduce la probabilidad de errores derivados de variables no inicializadas, que en JavaScript se representan como undefined.
- **Fundamento para Operaciones Futuras:** Asegura que las variables estﾃｩn listas para ser usadas en cﾃ｡lculos u otras operaciones desde el inicio.

### Declaraciones y Modo Estricto

**Historia y Evoluciﾃｳn del Modo Estricto**

El modo estricto en JavaScript ("use strict") es una funcionalidad introducida con ECMAScript 5 en 2009. Esta directiva fue diseﾃｱada para proporcionar una forma de optar por una versiﾃｳn mﾃ｡s segura y mejor optimizada del lenguaje. Al utilizar "use strict", JavaScript cambia su comportamiento en varias formas importantes para ayudar a evitar errores comunes y facilitar un cﾃｳdigo mﾃ｡s robusto.

**ﾂｿCﾃｳmo Funciona el Modo Estricto?**

El modo estricto se activa al colocar la cadena "use strict"; en la parte superior de un archivo JavaScript o al inicio de una funciﾃｳn. Esta simple lﾃｭnea altera el comportamiento del compilador de JavaScript de varias maneras cruciales:

1. **Eliminaciﾃｳn de las Declaraciones Implﾃｭcitas:** Antes de ES5, JavaScript permitﾃｭa la declaraciﾃｳn implﾃｭcita de variables, lo que podrﾃｭa causar problemas de gestiﾃｳn de memoria y conflictos en el ﾃ｡mbito de las variables. Con el modo estricto, cualquier intento de usar una variable sin declararla primero resulta en un error, evitando asﾃｭ el uso accidental de variables globales.

```js copy filename="JavaScript"
"use strict";
x = 3.14; // Error: x no estﾃ｡ definida
```

2. **Errores en Asignaciones a Propiedades no Existentes:** En el modo no estricto, si intentas asignar un valor a una propiedad que no existe, JavaScript la crea. En modo estricto, esto tambiﾃｩn resultarﾃ｡ en un error, evitando mutaciones no intencionadas de objetos.

```js copy filename="JavaScript"
"use strict";
let obj = {};
obj.count = 1; // Funciona bien si la propiedad existe
obj.unkownProp = 123; // Error si la propiedad no existe y es una tipografﾃｭa
```

3. **Protecciﾃｳn contra Cambios Accidentales en Objetos Inmutables:** El modo estricto lanza errores si intentas modificar objetos que no son modificables (congelados) o expandir objetos que no son extensibles.

```js copy filename="JavaScript"
"use strict";
let frozenObj = Object.freeze({ name: "Immutable" });
frozenObj.name = "Mutable"; // Error: intento de modificar una propiedad congelada
```

**Uso de "use strict"; en Prﾃ｡ctica**

El modo estricto es altamente recomendable en todos los nuevos proyectos JavaScript por varias razones:

- **Mejora la Seguridad del Cﾃｳdigo:** Al prevenir acciones potencialmente inseguras como la contaminaciﾃｳn global.
- **Facilita la Depuraciﾃｳn:** Al convertir los errores que serﾃｭan silenciados en excepciones, facilita la identificaciﾃｳn de problemas.
- **Prepara el Cﾃｳdigo para Futuras Versiones de JavaScript:** Muchas caracterﾃｭsticas de ES6 y posteriores presuponen que el cﾃｳdigo sigue las mejores prﾃ｡cticas introducidas en modo estrict

**Activaciﾃｳn del Modo Estricto**

Aquﾃｭ un ejemplo de cﾃｳmo se puede activar el modo estricto en un script completo o una funciﾃｳn individual:

```js copy filename="JavaScript"
// Modo estricto para todo el script
"use strict";
function doSomething() {
  // este cﾃｳdigo tambiﾃｩn estﾃ｡ en modo estricto
}

// Modo estricto solo para esta funciﾃｳn
function doSomethingElse() {
  "use strict";
  // solo el cﾃｳdigo dentro de esta funciﾃｳn estﾃ｡ en modo estricto
}
```

El modo estricto es una herramienta poderosa que ayuda a escribir cﾃｳdigo mﾃ｡s seguro y entender mejor el funcionamiento interno de JavaScript, evitando prﾃ｡cticas que pueden llevar a errores difﾃｭciles de rastrear. Al adoptarlo, los desarrolladores pueden mejorar significativamente la calidad y la seguridad de sus aplicaciones.

### Reasignaciﾃｳn de Variables

En el contexto de JavaScript, la reasignaciﾃｳn de variables se refiere al proceso de cambiar el valor almacenado en una variable que ya ha sido declarada. Este es un concepto fundamental en programaciﾃｳn, dado que permite que los datos sean dinﾃ｡micos y modificables a lo largo del tiempo, adaptﾃ｡ndose a las necesidades del flujo del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

Considera el siguiente ejemplo para ilustrar la reasignaciﾃｳn:

```js copy filename="JavaScript"
let mensaje = "ﾂ｡Hola Mundo!";
console.log(mensaje); // Salida: ﾂ｡Hola Mundo!

// Reasignando la variable
mensaje = "ﾂ｡Hola de nuevo!";
console.log(mensaje); // Salida: ﾂ｡Hola de nuevo!
```

Inicialmente, la variable mensaje se inicializa con el valor "ﾂ｡Hola Mundo!". Luego, se reasigna con un nuevo valor "ﾂ｡Hola de nuevo!". Este proceso sobrescribe el valor anterior almacenado en la variable.

**Conceptos Clave de Reasignaciﾃｳn**

1. **Mutabilidad:** En JavaScript, las variables declaradas con let o var son mutables, lo que significa que sus valores pueden cambiar a lo largo del tiempo. Esto es crucial para casos de uso como contadores en bucles, acumuladores en funciones y manejo de estado en aplicaciones.
2. **Tipado Dinﾃ｡mico:** JavaScript es un lenguaje de tipado dinﾃ｡mico, lo que permite que una variable pueda reasignarse a valores de diferentes tipos. Por ejemplo, una variable inicialmente asignada con un nﾃｺmero puede reasignarse luego con una cadena de texto, un booleano, o incluso estructuras mﾃ｡s complejas como objetos y arreglos.

```js copy filename="JavaScript"
let dato = 42;
dato = "cambio de tipo"; // vﾃ｡lido en JavaScript
```

3. **Implicaciones de Rendimiento:** Reasignar variables puede tener implicaciones en el rendimiento de la aplicaciﾃｳn, especialmente en bucles o funciones crﾃｭticas. Es importante gestionar bien cuﾃ｡ndo y cﾃｳmo se reasignan las variables para mantener el cﾃｳdigo eficiente y legible.

## Constantes

En JavaScript, el uso de la palabra clave const introduce constantes, que son "contenedores" donde se puede almacenar informaciﾃｳn que no se modificarﾃ｡ despuﾃｩs de su inicializaciﾃｳn inicial. Esto brinda una manera robusta y segura de manejar valores que no deben cambiar a lo largo de la ejecuciﾃｳn de un programa, contribuyendo a la claridad y la mantenibilidad del cﾃｳdigo.

### Caracterﾃｭsticas de const

1. **Inicializaciﾃｳn Obligatoria:**

Una constante debe ser inicializada en el momento de su declaraciﾃｳn. Esto asegura que siempre tenga un valor antes de su uso y evita la creaciﾃｳn de constantes que puedan estar indefinidas.

```js copy filename="JavaScript"
const greeting = "Hello, world!"; // Correcto
const name; // Incorrecto, generarﾃ｡ un error
```

2. **Inmutabilidad de la Asignaciﾃｳn:**

Una vez asignado el valor inicial, no se puede cambiar. Cualquier intento de reasignar un valor a una constante resultarﾃ｡ en un error.

```js copy filename="JavaScript"
const pi = 3.14159;
pi = 3.14; // Error, no se puede reasignar el valor de una constante
```

3. **Uso de Constantes en Cﾃ｡lculos y Configuraciones:**

A menudo, las constantes se utilizan para definir valores que no deben ser modificados despuﾃｩs de su configuraciﾃｳn inicial. Esto puede incluir configuraciones de aplicaciﾃｳn, como URLs de APIs o claves de configuraciﾃｳn que son sensibles y no deben ser alteradas.

```js copy filename="JavaScript"
const API_URL = "https://api.example.com";
```

4. **Optimizaciﾃｳn de Rendimiento:**

El uso de const puede permitir optimizaciones por parte del motor JavaScript porque el motor sabe que el valor no cambiarﾃ｡ y puede hacer optimizaciones en consecuencia.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo donde se usa const para definir el nﾃｺmero de iteraciones en un bucle, facilitando cambios durante el desarrollo sin necesidad de buscar y reemplazar valores crudos en el cﾃｳdigo.

```js copy filename="JavaScript"
const MAX_ITERATIONS = 5;

for (let i = 0; i < MAX_ITERATIONS; i++) {
  console.log(`Iteraciﾃｳn nﾃｺmero ${i + 1}`);
}
```

### Consideraciones Adicionales

En este ejemplo, cambiar el nﾃｺmero de iteraciones es tan simple como ajustar el valor de MAX_ITERATIONS. Esto es especialmente ﾃｺtil en entornos de desarrollo donde tales valores pueden necesitar ser ajustados frecuentemente.

Aunque const previene la reasignaciﾃｳn del valor de la constante, es importante notar que si el valor es un objeto o un array, los contenidos del objeto o array pueden ser modificados. Esto es porque const asegura la inmutabilidad del enlace de la variable, no del valor en sﾃｭ si es un objeto.

```js copy filename="JavaScript"
const data = { key: "value" };
data.key = "newValue"; // Esto es permitido
```

Esta flexibilidad permite el uso de const con estructuras de datos complejas, ofreciendo al mismo tiempo la seguridad de que el enlace al objeto no cambiarﾃ｡.

El uso de const es un pilar en el desarrollo JavaScript moderno por su claridad y seguridad que ofrece, asegurando que los valores que deben ser constantes lo sean, lo cual es crucial para el mantenimiento y la robustez del cﾃｳdigo.

## Scope

El scope, ﾃ｡mbito o alcance en JavaScript es fundamental para entender cﾃｳmo se gestionan y acceden las variables a lo largo de un programa. Este concepto determina dﾃｳnde las variables son accesibles dentro del cﾃｳdigo.

El scope se refiere a la regiﾃｳn del cﾃｳdigo donde una variable es accesible. JavaScript define principalmente dos tipos de scope: global y local. Cada funciﾃｳn crea un nuevo scope local por defecto, donde las variables declaradas dentro de la funciﾃｳn no pueden ser accedidas fuera de ella. Este diseﾃｱo ayuda a evitar conflictos de nombres y mantiene el cﾃｳdigo mﾃ｡s limpio y organizado.

### Funcionamiento del Scope

Cuando una variable es utilizada en JavaScript, el intﾃｩrprete sigue un proceso para determinar dﾃｳnde buscar esa variable. Este proceso comienza en el scope actual donde se estﾃ｡ ejecutando el cﾃｳdigo y, si no encuentra la variable, continﾃｺa buscando en el scope superior, hasta llegar al scope global. Si la variable no se encuentra en ningﾃｺn scope, se produce un error ReferenceError.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos el siguiente cﾃｳdigo para entender mejor cﾃｳmo funciona el scope:

```js copy filename="JavaScript"
let color = "blue"; // Variable global

function printColor() {
  let message = "The color is "; // Variable local de la funciﾃｳn printColor
  console.log(message + color); // Accede a la variable global 'color'
}

printColor(); // Output: "The color is blue"
// console.log(message);  // Esto generarﾃｭa un ReferenceError: message is not defined
```

En este ejemplo, color es una variable global accesible desde cualquier parte del programa, incluyendo dentro de la funciﾃｳn printColor. Sin embargo, la variable message es local a la funciﾃｳn printColor y no puede ser accedida fuera de ella.

### Importancia del Scope

El correcto manejo del scope tiene varias ventajas clave:

1. **Seguridad:** Limita la visibilidad de las variables a las partes del programa que realmente necesitan acceso a ellas, protegiendo los datos de accesos no autorizados.
2. **Reducciﾃｳn de Bugs:** Evita problemas relacionados con la reutilizaciﾃｳn inadvertida de nombres de variables en diferentes partes del programa, lo cual puede llevar a bugs difﾃｭciles de rastrear.
3. **Eficiencia en la Gestiﾃｳn de la Memoria:** Al limitar el ciclo de vida de las variables al scope donde son necesarias, el sistema puede liberar recursos mﾃ｡s eficientemente una vez que ya no estﾃ｡n en uso.

### Tipos de Scope

JavaScript maneja principalmente dos tipos de scopes que son fundamentales para entender cﾃｳmo se comportan las variables y funciones dentro del programa. Estos son el Global Scope y el Local Scope, y cada uno tiene sus particularidades que afectan la visibilidad y el ciclo de vida de las variables.

1. **Global Scope**

Cuando una variable se declara fuera de cualquier funciﾃｳn o bloque, se le asigna un Global Scope. Esto significa que cualquier script o funciﾃｳn en el mismo entorno puede acceder a esta variable. Las variables globales permanecen accesibles durante toda la vida ﾃｺtil del programa y pueden ser modificadas por cualquier parte del cﾃｳdigo, lo que a veces puede llevar a resultados inesperados si no se manejan cuidadosamente.

```js copy filename="JavaScript"
var globalVar = "Soy una variable global";

function displayVar() {
  console.log(globalVar); // Accede a la variable global desde dentro de una funciﾃｳn
}

displayVar(); // Muestra: Soy una variable global
console.log(globalVar); // Muestra: Soy una variable global
```

2. **Local Scope**

Las variables con Local Scope estﾃ｡n declaradas dentro de una funciﾃｳn o un bloque y solo pueden ser accesibles dentro de ese contexto especﾃｭfico. Este aislamiento ayuda a evitar conflictos de nombres y mantiene el cﾃｳdigo mﾃ｡s seguro y modular. Hay dos subtipos principales de local scope:

a. **Function Scope**

Cualquier variable declarada dentro de una funciﾃｳn cae bajo el Function Scope, lo que significa que solo puede ser accesible desde dentro de la funciﾃｳn en la que se declara.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function localScopeExample() {
  var localVar = "Soy local a esta funciﾃｳn";
  console.log(localVar); // Funciona bien
}

localScopeExample();
console.log(localVar); // Error: localVar is not defined
```

b. **Block Scope (introducido con ES6)**

Con la llegada de ES6, let y const introdujeron el Block Scope, donde las variables declaradas dentro de bloques (definidos por llaves {} como en condicionales y loops) son accesibles solo dentro de ese bloque.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
if (true) {
  let blockScopedVar = "Visible solo dentro de este bloque";
  console.log(blockScopedVar); // Muestra correctamente
}

console.log(blockScopedVar); // Error: blockScopedVar is not defined
```

**Scope de let y const**

El ﾃ｡mbito de las variables (scope) en JavaScript es fundamental para controlar la accesibilidad y la visibilidad de las variables a lo largo del cﾃｳdigo. Con la introducciﾃｳn de let y const en ECMAScript 2015 (ES6), JavaScript proporcionﾃｳ herramientas mﾃ｡s robustas para la gestiﾃｳn del scope en comparaciﾃｳn con var, que era mﾃ｡s limitado y propenso a errores comunes de programaciﾃｳn.

1. **ﾃ［bito Global**

El ﾃ｡mbito global significa que las variables estﾃ｡n disponibles a travﾃｩs de todo el cﾃｳdigo del mismo contexto de ejecuciﾃｳn, es decir, son accesibles desde cualquier parte del script o consola donde fueron declaradas.

**Caracterﾃｭsticas:**

Al declarar con let o const en el ﾃ｡mbito global, las variables no se aﾃｱaden al objeto global (como window en navegadores), a diferencia de var, que sﾃｭ lo hace. Esto es importante para evitar conflictos en entornos globales, especialmente en el desarrollo web.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let globalLet = "Accesible desde cualquier parte del cﾃｳdigo";
console.log(window.globalLet); // undefined en navegador, `globalLet` no estﾃ｡ en `window`
```

2. **ﾃ［bito Local: Block Scope**

let y const tienen ﾃ｡mbito de bloque (block scope), lo que significa que solo son accesibles dentro del bloque donde fueron declaradas y sus sub-bloques.

**Ventajas:**

- Esto previene errores comunes como la contaminaciﾃｳn del ﾃ｡mbito global, donde variables inesperadas afectan otras partes del cﾃｳdigo.
- Mejora la gestiﾃｳn de la memoria al eliminar las variables una vez que el bloque ha terminado su ejecuciﾃｳn.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function testBlockScope() {
  if (true) {
    let blockScopedVar = "Visible dentro de este bloque";
    console.log(blockScopedVar); // Muestra "Visible dentro de este bloque"
  }
  console.log(blockScopedVar); // Error: blockScopedVar no estﾃ｡ definido fuera del bloque
}
testBlockScope();
```

3. **Bloques Anidados**

En JavaScript, los bloques anidados son bloques de cﾃｳdigo que estﾃ｡n dentro de otros bloques de cﾃｳdigo, tﾃｭpicamente estructurados dentro de estructuras de control como bucles o condiciones, asﾃｭ como en funciones.

**Caracterﾃｭsticas de let y const:**

Las variables declaradas con let o const dentro de un bloque anidado solo son accesibles dentro de ese bloque especﾃｭfico y no fuera de ﾃｩl. Esto ayuda a prevenir interferencias de variables cuando se ejecutan ciclos o condiciones mﾃｺltiples.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function outerFunction() {
  let outerVar = "Visible en la funciﾃｳn externa y sus bloques internos";

  if (true) {
    let innerVar = "Visible solo en este bloque interno";
    console.log(outerVar); // Correcto: Accede a la variable del ﾃ｡mbito superior
    console.log(innerVar); // Correcto: Accede a la variable en su propio ﾃ｡mbito
  }

  console.log(innerVar); // Error: innerVar no estﾃ｡ definida en este ﾃ｡mbito
}
outerFunction();
```

**Uso Prﾃ｡ctico y Consideraciones de Diseﾃｱo**

- **Organizaciﾃｳn del Cﾃｳdigo:** Utilizar let y const ayuda a mantener el cﾃｳdigo organizado y claro. Limita el uso de variables a donde realmente se necesitan y evita efectos secundarios no deseados de variables que permanecen accesibles mﾃ｡s allﾃ｡ de su utilidad.
- **Mejores Prﾃ｡cticas:**
  - **Inicializaciﾃｳn Condicional:** En algunos casos, puede ser ﾃｺtil inicializar una variable dentro de un bloque condicional, asegurando que su alcance y su uso estﾃｩn limitados al contexto relevante.
  - **Gestiﾃｳn de Recursos:** Al limitar el ﾃ｡mbito de las variables, let y const permiten una mejor gestiﾃｳn de los recursos al desasignar memoria que ya no es necesaria una vez que el bloque ha terminado su ejecuciﾃｳn.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function processItems(items) {
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    // Procesa cada item aquﾃｭ
    console.log(item); // Accesible solo dentro del bucle
  }
  console.log(i); // Error: i no estﾃ｡ definida fuera del bucle
  console.log(item); // Error: item no estﾃ｡ definida fuera del bucle
}
processItems(["apple", "banana", "cherry"]);
```

**Scope de var**

El uso de var en JavaScript se asocia tradicionalmente con dos ﾃ｡mbitos principales: global y funcional. A diferencia de let y const, que introducen un control de ﾃ｡mbito de bloque, var se maneja de manera menos restrictiva, lo que puede conducir a comportamientos inesperados si no se maneja con cuidado.

1. **ﾃ［bito Global**

Cuando var se utiliza fuera de cualquier funciﾃｳn, la variable se aﾃｱade al objeto global (por ejemplo, window en navegadores), haciﾃｩndola accesible desde cualquier parte del script.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
var globalExample = "Disponible globalmente";
function accessGlobal() {
  console.log(globalExample); // Accede a la variable global
}
accessGlobal(); // Imprime: Disponible globalmente
console.log(globalExample); // Imprime: Disponible globalmente
```

**ﾃ［bito Funcional:**

Las variables declaradas con var dentro de una funciﾃｳn no son accesibles fuera de esa funciﾃｳn, pero sﾃｭ en cualquier lugar dentro de ella, independientemente de los bloques de cﾃｳdigo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function functionScopeExample() {
  var functionScoped = "Visible dentro de la funciﾃｳn";
  if (true) {
    var alsoFunctionScoped = "Tambiﾃｩn visible en toda la funciﾃｳn";
  }
  console.log(functionScoped); // Visible dentro de la funciﾃｳn
  console.log(alsoFunctionScoped); // Tambiﾃｩn visible en toda la funciﾃｳn
}
functionScopeExample();
console.log(functionScoped); // Error: functionScoped no estﾃ｡ definido
```

**Problemas Comunes y Soluciones con var**

- **Elevaciﾃｳn de Variables (Hoisting):** Las variables declaradas con var son elevadas al inicio de su contexto funcional o global, lo que significa que estﾃ｡n tﾃｩcnicamente "definidas" desde el comienzo del bloque de funciﾃｳn o global, pero sin inicializaciﾃｳn hasta su lﾃｭnea de declaraciﾃｳn. En el siguiente tema profundizaremos en este tema.

- **Re-declaraciﾃｳn sin Restricciones:** A diferencia de let y const, re-declarar una variable con var en el mismo ﾃ｡mbito no genera error, lo que puede llevar a sobreescrituras inadvertidas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
var redeclare = "Primero";
var redeclare = "Segundo";
console.log(redeclare); // Imprime: Segundo
```

**Implicaciones del Uso de var**

El uso de var puede ser adecuado en contextos donde la compatibilidad con versiones antiguas de JavaScript es crﾃｭtica, pero generalmente se considera una prﾃ｡ctica obsoleta en desarrollo moderno debido a sus peculiaridades y la falta de control de ﾃ｡mbito de bloque. Herramientas modernas como Babel permiten la transpilaciﾃｳn de cﾃｳdigo moderno let y const a var para mantener la compatibilidad sin sacrificar las buenas prﾃ｡cticas de desarrollo.

### Hoisting

Hoisting en JavaScript es un comportamiento automﾃ｡tico del intﾃｩrprete que afecta cﾃｳmo se gestionan las declaraciones de variables y funciones. Este mecanismo puede parecer confuso al principio, pero una vez comprendido, ayuda a evitar errores comunes y mejora la estructuraciﾃｳn del cﾃｳdigo.

**Detalles Tﾃｩcnicos del Hoisting**

1. **Proceso de Compilaciﾃｳn y Ejecuciﾃｳn:** Aunque JavaScript es un lenguaje interpretado, realiza una compilaciﾃｳn en tiempo de ejecuciﾃｳn justo antes de ejecutar el cﾃｳdigo. Durante esta fase, el intﾃｩrprete procesa todas las declaraciones de variables y funciones moviﾃｩndolas al inicio de su ﾃ｡mbito respectivo. Esto es lo que llamamos "hoisting".

2. **Variables y la Inicializaciﾃｳn:**

- **Con var:** Las variables declaradas con var son hoisted y automﾃ｡ticamente inicializadas a undefined. Esto permite que las variables se utilicen de alguna forma antes de su lﾃｭnea de declaraciﾃｳn efectiva.

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(value); // Muestra `undefined` porque la inicializaciﾃｳn con `undefined` es hoisted
var value = 100;
```

- **Con let y const:** Estas declaraciones tambiﾃｩn son hoisted, pero no se inicializan, creando la "zona temporal muerta" (TDZ) donde el acceso a ellas antes de su inicializaciﾃｳn explﾃｭcita arroja un error.

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(value); // ReferenceError: value is not initialized
let value = 100;
```

3. **Funciones y Hoisting:**

- **Las funciones declaradas** son completamente hoisted, lo que significa que tanto su declaraciﾃｳn como su definiciﾃｳn son movidas al inicio del ﾃ｡mbito. Esto permite que las funciones sean llamadas antes de que aparezcan textualmente en el cﾃｳdigo.

```js copy filename="JavaScript"
hello(); // Funciona correctamente y muestra "Hello"
function hello() {
  console.log("Hello");
}
```

- **Expresiones de Funciﾃｳn:** A diferencia de las funciones declaradas, las expresiones de funciﾃｳn dependen del tipo de variable usada para su declaraciﾃｳn (var, let, const). Si se usa var, el nombre de la variable es hoisted pero no su asignaciﾃｳn funcional.

```js copy filename="JavaScript"
hello(); // TypeError: hello is not a function
var hello = function () {
  console.log("Hello");
};
```

Este proceso de hoisting se aplica de manera consistente en todos los ﾃ｡mbitos, ya sea global o local dentro de funciones, pero no atraviesa los lﾃｭmites de estas ﾃｺltimas, manteniendo las definiciones confinadas dentro del ﾃ｡mbito funcional a menos que se especifique lo contrario. Este mecanismo subraya la importancia de entender cﾃｳmo y dﾃｳnde declarar variables y funciones para mantener el cﾃｳdigo claro y predecible.

4. **Implicaciones del Hoisting:**

- **Claridad del Cﾃｳdigo:** Uno de los principales beneficios del entendimiento profundo del hoisting es la capacidad de organizar el cﾃｳdigo de manera que refleje la verdadera funcionalidad. Sabiendo que las declaraciones serﾃ｡n movidas al inicio, los desarrolladores pueden optar por colocarlas explﾃｭcitamente en la parte superior de sus ﾃ｡mbitos para mejorar la legibilidad y evitar comportamientos inesperados.
- **Errores Comunes:** Sin un adecuado entendimiento de hoisting, es fﾃ｡cil caer en trampas comunes como usar una variable antes de su inicializaciﾃｳn adecuada, especialmente cuando se usan let y const que estﾃ｡n sujetas a la TDZ.

5 **Buenas Prﾃ｡cticas:**

- **Declaraciones al Inicio:** Para maximizar la claridad y prevenir errores, es recomendable declarar todas las variables y funciones al inicio de sus ﾃ｡mbitos respectivos. Esto no solo alinea el cﾃｳdigo fuente con el comportamiento del intﾃｩrprete debido al hoisting, sino que tambiﾃｩn hace que el cﾃｳdigo sea mﾃ｡s fﾃ｡cil de entender y mantener.
- **Uso Cauteloso de var:** Dada la naturaleza de var de hoistear e inicializar con undefined, su uso puede llevar a errores sutiles, especialmente en bloques de cﾃｳdigo complejos. La preferencia moderna es utilizar let y const, que ofrecen un control de ﾃ｡mbito mﾃ｡s granular y previenen modificaciones accidentales gracias a la TDZ.

7. **Hoisting y las Funciones Flecha:**

- A diferencia de las funciones tradicionales y las expresiones de funciﾃｳn, las funciones flecha no tienen su propio this, ni son hoisted. Esto significa que deben ser declaradas antes de su uso, lo que puede influir en la decisiﾃｳn de usar una funciﾃｳn flecha versus una funciﾃｳn tradicional dependiendo del contexto y la necesidad de hoisting.

```js copy filename="JavaScript"
greet(); // ReferenceError: greet is not defined
const greet = () => console.log("Hello");
```

<h4 className="font-medium top-5">Ejemplo</h4>

```js copy filename="JavaScript"
function processUser() {
  console.log(name); // undefined debido a hoisting con `var`
  var name = "Sarah";
  innerFunction();

  function innerFunction() {
    console.log(name); // Sarah, porque 'name' es accesible aquﾃｭ debido al hoisting
  }
}
processUser();
```

Este ejemplo destaca cﾃｳmo el hoisting permite acceso a la variable name dentro de innerFunction() a pesar de ser declarada despuﾃｩs en el texto del cﾃｳdigo. Sin embargo, el primer console.log(name) muestra undefined porque aunque name es hoisted, su inicializaciﾃｳn no lo es.

### Fases del Scope

El manejo del scope en JavaScript es un concepto central para entender cﾃｳmo las variables y funciones son accesibles en diferentes partes del cﾃｳdigo. El scope de una variable define en quﾃｩ partes del cﾃｳdigo una variable es accesible. Para comprender mejor, es crucial distinguir entre las dos fases principales en el manejo del scope: la fase de compilaciﾃｳn y la fase de ejecuciﾃｳn.

**Fase de Compilaciﾃｳn**

Durante la fase de compilaciﾃｳn, JavaScript realiza un proceso conocido como "levantamiento" o "hoisting", como hemos mencionado anteriormente, donde las declaraciones de variables y funciones son movidas al inicio de su scope antes de que el cﾃｳdigo sea ejecutado. Este proceso implica dos subfases importantes:

1. **Creaciﾃｳn de Contextos de Ejecuciﾃｳn:** Antes de que el cﾃｳdigo comience a ejecutarse, el motor de JavaScript configura el entorno para la ejecuciﾃｳn. Esto incluye la creaciﾃｳn de contextos de ejecuciﾃｳn global y funcional, donde el contexto global abarca el cﾃｳdigo fuera de todas las funciones, mientras que cada funciﾃｳn crea un nuevo contexto funcional.
2. **Registro de Identificadores:** Dentro de cada contexto de ejecuciﾃｳn, se realiza un paso crucial: el registro de todas las variables (declaradas con var, let, const) y las declaraciones de funciones en el "hoisting". Las variables declaradas con var son inicializadas con undefined, mientras que las declaradas con let y const no se inicializan hasta que el cﾃｳdigo de su declaraciﾃｳn es ejecutado realmente.

**Fase de Ejecuciﾃｳn**

Una vez que el contexto de ejecuciﾃｳn estﾃ｡ establecido y las variables estﾃ｡n registradas durante la compilaciﾃｳn, la fase de ejecuciﾃｳn maneja cﾃｳmo y cuﾃ｡ndo las variables son accesibles en el cﾃｳdigo. Este es el momento en que realmente se asignan y utilizan los valores de las variables y funciones.

1. **Ejecuciﾃｳn de Cﾃｳdigo:** Durante esta fase, el cﾃｳdigo es ejecutado lﾃｭnea por lﾃｭnea. Las variables declaradas con let y const que fueron temporalmente inaccesibles (en una zona muerta temporal hasta su declaraciﾃｳn) ahora se inicializan en el momento que su declaraciﾃｳn es ejecutada en el cﾃｳdigo.
2. **Acceso a Variables:** El acceso a las variables durante la ejecuciﾃｳn sigue las reglas del scope establecido:

- **Global Scope:** Variables declaradas globalmente o fuera de cualquier funciﾃｳn estﾃ｡n accesibles desde cualquier parte del cﾃｳdigo.
- **Function Scope:** Variables declaradas dentro de una funciﾃｳn sﾃｳlo son accesibles dentro de esa funciﾃｳn y no fuera de ella.
- **Block Scope:** Introducido con let y const, permite que las variables sean accesibles solo dentro del bloque de cﾃｳdigo ({}) donde fueron declaradas.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo para ilustrar cﾃｳmo let y const manejan el block scope, a diferencia de var que maneja el function scope:

```js copy filename="JavaScript"
if (true) {
  var varVariable = "Visible";
  let letVariable = "Visible Only Inside";
  const constVariable = "Also Visible Only Inside";
}
console.log(varVariable); // Output: "Visible"
console.log(letVariable); // Error: letVariable is not defined
console.log(constVariable); // Error: constVariable is not defined
```

En este ejemplo, varVariable es accesible fuera del bloque if porque var no tiene block scope, sino function scope. Por otro lado, letVariable y constVariable no son accesibles fuera del bloque if porque let y const respetan el block scope.

## Breves palabras sobre las funciones

Las funciones en JavaScript son estructuras fundamentales que permiten encapsular bloques de cﾃｳdigo para su reutilizaciﾃｳn y organizaciﾃｳn. Funcionan como pequeﾃｱos programas dentro del programa principal, donde cada funciﾃｳn puede recibir entradas, procesar informaciﾃｳn y devolver salidas.

### ﾂｿCﾃｳmo Definir una Funciﾃｳn?

Las funciones se definen utilizando la palabra clave function, seguida de un nombre opcional (en el caso de funciones anﾃｳnimas) y un conjunto de parﾃｩntesis que pueden incluir parﾃ｡metros. Aquﾃｭ tienes un esquema bﾃ｡sico:

```js copy filename="JavaScript"
function nombreDeLaFuncion(parametro1, parametro2) {
  // Cuerpo de la funciﾃｳn
}
```

Por ejemplo, una funciﾃｳn simple para sumar dos nﾃｺmeros serﾃｭa:

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}
```

### Ejecuciﾃｳn de Funciones

Una funciﾃｳn solo se ejecuta cuando es llamada. Esto se hace usando el nombre de la funciﾃｳn seguido de parﾃｩntesis, opcionalmente incluyendo argumentos si se requieren:

```js copy filename="JavaScript"
let resultado = sumar(5, 3);
console.log(resultado); // Muestra 8
```

## Sombreado de Variables

El sombreado de variables es una tﾃｩcnica en JavaScript que permite a los desarrolladores redefinir una variable dentro de un ﾃ｡mbito local que tiene el mismo nombre que una variable en un ﾃ｡mbito mﾃ｡s amplio o global. Este enfoque puede ser ﾃｺtil para manejar situaciones donde diferentes partes de un programa requieren valores diferentes para una variable que comparte el mismo nombre.

### Detalles Tﾃｩcnicos del Sombreado

1. **Detalles Tﾃｩcnicos del Sombreado**

**Global vs. Local:** Una variable global existe durante la vida ﾃｺtil de una aplicaciﾃｳn y es accesible desde cualquier parte del cﾃｳdigo. Una variable local, sin embargo, sﾃｳlo existe dentro del bloque donde se define y oculta cualquier variable global del mismo nombre sﾃｳlo dentro de ese contexto especﾃｭfico.

<h4 className="font-medium mt-5">Ejemplos</h4>

```js copy filename="JavaScript"
let message = "Global message";
function showMessage() {
  let message = "Local message";
  console.log(message); // Accede al mensaje local: "Local message"
}
showMessage();
console.log(message); // Accede al mensaje global: "Global message"
```

En este ejemplo, message dentro de showMessage sombrea al message global, demostrando cﾃｳmo el ﾃ｡mbito local puede tener preferencia sobre el global.

2. **ﾃ［bito de Bloque:**

JavaScript con let y const introduce el ﾃ｡mbito de bloque, que limita la vida de la variable al bloque, declaraciﾃｳn o expresiﾃｳn donde se utiliza. Esto es diferente de var, que define variables con ﾃ｡mbito funcional o global sin importar donde se declaren dentro de la funciﾃｳn.

**Implicaciones del Sombreado**

El sombreado permite una flexibilidad considerable en la programaciﾃｳn, pero tambiﾃｩn requiere que los programadores sean meticulosos en la gestiﾃｳn de ﾃ｡mbitos para evitar efectos no deseados. Las variables locales pueden llevar el mismo nombre que las globales sin interferencia, siempre y cuando su manipulaciﾃｳn se mantenga dentro del ﾃ｡mbito apropiado.

**Casos de Uso Avanzados**

En situaciones complejas donde mﾃｺltiples funciones o bloques requieren diferentes versiones de la misma variable, el sombreado puede simplificar la gestiﾃｳn del estado local sin alterar el estado global. Esto es especialmente ﾃｺtil en aplicaciones grandes donde diferentes mﾃｳdulos o componentes pueden necesitar comportarse de manera independiente pero aﾃｺn interactuar con recursos compartidos de manera controlada.

### Consideraciones Adicionales

- **Riesgos:** El exceso de sombreado puede llevar a cﾃｳdigo que es difﾃｭcil de seguir y mantener. Es vital que los nombres de las variables sean elegidos para reflejar claramente su uso y ﾃ｡mbito, reduciendo la posibilidad de errores lﾃｳgicos.
- **Herramientas de Linting:** Herramientas como ESLint pueden ayudar a identificar problemas potenciales con el sombreado y otros problemas de ﾃ｡mbito en el cﾃｳdigo, asegurando mejores prﾃ｡cticas en el desarrollo.

## Ejercicios

A continuaciﾃｳn, presento una serie de quizes, preguntas y ejercicios diseﾃｱados para ayudarte a consolidar tu comprensiﾃｳn sobre los conceptos bﾃ｡sicos de JavaScript que hemos discutido. Cada ejercicio incluye una soluciﾃｳn para que puedas verificar tu trabajo.

### Quizes

<h4 className="font-medium mt-5">ﾂｿQuﾃｩ es una variable en JavaScript?</h4>

<p className="my-2">a) Una funciﾃｳn que almacena datos</p>
<p>b) Un contenedor para almacenar datos</p>
<p className="my-2">c) Un tipo de bucle</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Un contenedor para almacenar datos</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿQuﾃｩ palabra clave en JavaScript declara una variable que no puede ser
  reasignada?
</h4>

<p className="my-2">a) let</p>
<p>b) var</p>
<p className="my-2">c) const</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) const</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  En JavaScript, ﾂｿcuﾃ｡l de las siguientes opciones representa una prﾃ｡ctica
  correcta de nombramiento de variables?
</h4>

<p className="my-2">a) Comenzar con un nﾃｺmero</p>
<p>b) Usar espacios entre palabras</p>
<p className="my-2">c) Usar camelCase</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Usar camelCase</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿCuﾃ｡l es el resultado de una variable declarada con var fuera de cualquier
  funciﾃｳn?
</h4>

<p className="my-2">a) Scope global</p>
<p>b) Scope local</p>
<p className="my-2">c) No tiene scope</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Scope global</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">ﾂｿQuﾃｩ es el hoisting en JavaScript?</h4>

<p className="my-2">a) Priorizar la ejecuciﾃｳn de funciones</p>
<p>b) Elevar las declaraciones de variables al inicio de su contexto</p>
<p className="my-2">c) Ignorar declaraciones de variables</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Elevar las declaraciones de variables al inicio de su contexto
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿQuﾃｩ sucede cuando intentas reasignar una variable const?
</h4>

<p className="my-2">a) La variable es reasignada sin problemas</p>
<p>b) Se lanza un error de tipo</p>
<p className="my-2">c) Se ignora la reasignaciﾃｳn</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Se lanza un error de tipo</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿQuﾃｩ mﾃｩtodo se utiliza para imprimir informaciﾃｳn en la consola de JavaScript?
</h4>

<p className="my-2">a) console.print()</p>
<p>b) console.log()</p>
<p className="my-2">c) console.output()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) console.log()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿQuﾃｩ describe mejor el 'scope' de una variable en JavaScript?
</h4>

<p className="my-2">a) El valor de la variable</p>
<p>b) El tipo de la variable</p>
<p className="my-2">c) El ﾃ｡rea del programa donde la variable es accesible</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      c) El ﾃ｡rea del programa donde la variable es accesible
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿQuﾃｩ es sombreado de variables en JavaScript?
</h4>

<div className="my-2">
  a) Cambiar el valor de una variable global dentro de una funciﾃｳn
</div>
<p>b) Declarar una nueva variable local con el mismo nombre que una global</p>
<p className="my-2">c) Eliminar una variable global</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Declarar una nueva variable local con el mismo nombre que una global
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿCuﾃ｡l es una caracterﾃｭstica de las funciones en JavaScript?
</h4>

<p className="my-2">a) No pueden retornar valores</p>
<p>b) No pueden contener otras funciones</p>
<p className="my-2">c) Pueden contener otras funciones</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Pueden contener otras funciones</AccordionContent>
  </AccordionItem>
</Accordion>

### Preguntas

<h4 className="font-medium mt-5">
  ﾂｿCﾃｳmo diferirﾃｭas el uso de var, let y const en la declaraciﾃｳn de variables?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      - **var** es la forma mﾃ｡s antigua de declarar variables y tiene un scope a nivel de funciﾃｳn o global si se declara fuera de una funciﾃｳn. Se deberﾃｭa usar con precauciﾃｳn, principalmente en situaciones donde la compatibilidad con navegadores antiguos es necesaria.
      - **let** permite declarar variables con un scope limitado al bloque, declaraciﾃｳn o expresiﾃｳn donde se usa. Es ﾃｺtil en la mayorﾃｭa de los casos donde se requiere cambiar el valor de la variable despuﾃｩs de su inicializaciﾃｳn, como en bucles o condicionales.
      - **const** se utiliza para declarar variables que no deben cambiar su valor inicial una vez asignado, es decir, son constantes. Su scope tambiﾃｩn es de bloque y ayuda a garantizar que los valores no sean reasignados, lo cual es ﾃｺtil para configuraciones y valores que no deberﾃｭan cambiar a lo largo del tiempo.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿPuede explicar cﾃｳmo el scope global afecta la seguridad y la gestiﾃｳn de la
  memoria en una aplicaciﾃｳn web?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El uso de variables globales puede llevar a problemas de seguridad ya que cualquier script incluido en la pﾃ｡gina puede acceder y modificar estas variables, potencialmente llevando a comportamientos no deseados o ataques de tipo XSS (Cross-Site Scripting). En cuanto a la gestiﾃｳn de memoria, las variables globales permanecen en memoria durante todo el ciclo de vida de la pﾃ｡gina, lo que puede llevar a un uso ineficiente de recursos si las variables acumulan grandes cantidades de datos o si no se liberan adecuadamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Describe un escenario donde el hoisting podrﾃｭa causar un bug en el cﾃｳdigo.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Supongamos que intentas utilizar una variable antes de declararla con var, pensando que serﾃｭa undefined, pero otro bloque de cﾃｳdigo anterior en el mismo scope la ha inicializado con un valor diferente. Por ejemplo:

      ```js copy filename="JavaScript"
      function ejemploHoisting() {
        console.log(miVar); // Esperas undefined, pero muestra 'Hola'
        var miVar = 'Mundo';
      }
      var miVar = 'Hola';
      ejemploHoisting();
      ```

      Aquﾃｭ, el hoisting causa que miVar se declare al inicio de la funciﾃｳn, pero toma el valor del miVar global inicializado previamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿCﾃｳmo podrﾃｭas implementar el sombreado de variables para manejar
  configuraciones regionales en una aplicaciﾃｳn?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Podrﾃｭas tener una configuraciﾃｳn regional global definida para toda la aplicaciﾃｳn y luego, en funciones especﾃｭficas que manejan lﾃｳgica relacionada con localidades especﾃｭficas, podrﾃｭas declarar variables locales (sombreadas) que tengan configuraciones ajustadas a esas localidades. Esto permite una gran flexibilidad y mantiene el cﾃｳdigo limpio y modular.

      ```js copy filename="JavaScript"
      var configuracionGlobal = { moneda: 'USD', idioma: 'en' };
      function mostrarPrecios() {
        var configuracionGlobal = { moneda: 'EUR', idioma: 'es' }; // Sombreado
        console.log('Configuraciﾃｳn usada:', configuracionGlobal);
      }
      mostrarPrecios();
      console.log('Configuraciﾃｳn global:', configuracionGlobal);
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿCuﾃ｡l es la importancia de inicializar variables correctamente en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Inicializar variables correctamente ayuda a evitar errores en tiempo de ejecuciﾃｳn, facilita la lectura y mantenimiento del cﾃｳdigo, y asegura que las variables sean utilizadas con los valores esperados desde su primer uso, previniendo comportamientos indeseados o bugs difﾃｭciles de rastrear.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ﾂｿCﾃｳmo afecta use strict al comportamiento de las declaraciones de variables en
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El modo 'use strict' impide la declaraciﾃｳn implﾃｭcita de variables globales, lo cual ayuda a prevenir errores comunes como asignaciones a variables no declaradas. Esto conduce a un cﾃｳdigo mﾃ｡s seguro y predecible, obligando a los desarrolladores a declarar explﾃｭcitamente sus variables antes de usarlas.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Discute cﾃｳmo y por quﾃｩ podrﾃｭas usar console.table() en el desarrollo de una
  aplicaciﾃｳn.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      console.table() es ﾃｺtil para mostrar datos tabulares, como listas de objetos, en un formato legible en la consola. Esto es especialmente ﾃｺtil en el desarrollo cuando necesitas inspeccionar listas de datos, resultados de pruebas o cualquier informaciﾃｳn estructurada. Ayuda a visualizar rﾃ｡pidamente las propiedades y valores de los objetos sin necesidad de iterar manualmente a travﾃｩs de ellos.

    </AccordionContent>

  </AccordionItem>
</Accordion>

### Ejercicios

<h4 className="font-medium mt-5">
  Declara dos variables, base y altura de un triﾃ｡ngulo. Inicialﾃｭzalas con 10 y 5
  respectivamente. Calcula el ﾃ｡rea (area = (base * altura) / 2) e imprﾃｭmelo con
  console.log().
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquﾃｭ tu cﾃｳdigo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let base = 10;
        let altura = 5;
        let area = (base * altura) / 2;
        console.log("El ﾃ｡rea del triﾃ｡ngulo es:", area);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Crea una constante PI y asﾃｭgnale 3.14159. Usa esta constante para calcular el
  ﾃ｡rea de un cﾃｭrculo con radio 4. Imprime el resultado.
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquﾃｭ tu cﾃｳdigo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const PI = 3.14159;
        let radio = 4;
        let areaCirculo = PI * radio * radio;
        console.log("El ﾃ｡rea del cﾃｭrculo es:", areaCirculo);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Declara una variable global color y asﾃｭgnale "rojo". Dentro de una funciﾃｳn,
  declara una variable local color y asﾃｭgnale "azul". Muestra ambos colores
  usando console.log() dentro y fuera de la funciﾃｳn.
</h4>

<div className="my-5">
  <Editor
    height="20vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aquﾃｭ tu cﾃｳdigo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let color = "rojo";
        function cambiarColor() {
          let color = "azul";
          console.log("Color dentro de la funciﾃｳn:", color);
        }
        cambiarColor();
        console.log("Color fuera de la funciﾃｳn:", color);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>
