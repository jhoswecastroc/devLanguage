import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Estructura de Datos B치sicas

Al abordar las estructuras de datos b치sicas en programaci칩n, es esencial comenzar con uno de los fundamentos m치s cr칤ticos: las variables. Entender qu칠 son las variables y c칩mo nombrarlas adecuadamente es vital para cualquier programador, ya que estas son herramientas primordiales en el manejo de datos dentro de cualquier programa.

## 쯈u칠 son las Variables?

Las variables son fundamentales en cualquier lenguaje de programaci칩n porque act칰an como contenedores para almacenar datos. Estos datos pueden variar durante la ejecuci칩n del programa, de ah칤 el t칠rmino "variable".

Una variable se puede imaginar como una caja donde podemos guardar algo para usar m치s tarde. En el contexto de programaci칩n, lo que se guarda en la caja (variable) es un valor que puede ser un n칰mero, un texto, un booleano, un objeto, entre otros. La variable entonces tiene un nombre 칰nico que se utiliza para acceder a este valor almacenado.

## Nombramiento de las Variables

El nombramiento de las variables es cr칤tico porque proporciona pistas sobre la utilizaci칩n de la variable dentro del programa. Aqu칤 est치n algunas buenas pr치cticas para nombrar variables:

1. **Claridad y Descriptividad:** Los nombres de las variables deben ser claros y descriptivos. Por ejemplo, precioTotal, nombreUsuario son nombres que describen claramente los datos que contienen.
2. **Uso de camelCase:** En JavaScript, es com칰n utilizar camelCase para nombrar variables. Esto significa que la primera palabra est치 en min칰scula y cada palabra subsecuente comienza con una may칰scula. Por ejemplo, cuentaBancaria.
3. **Evitar palabras reservadas:** JavaScript tiene palabras reservadas que no se pueden usar como nombres de variables, como new, return, function, entre otros.
4. **No empezar con n칰meros:** Los nombres de variables no deben comenzar con n칰meros. Un nombre como 2dias es inv치lido.
5. **Expresividad sobre brevedad:** Prefiere nombres que sean m치s expresivos y claros sobre nombres excesivamente cortos y vagos. Por ejemplo, usar numeroPaginas en lugar de simplemente np hace que el c칩digo sea mucho m치s legible y entendible.
6. **Consistencia:** Es esencial ser consistente con las convenciones de nomenclatura a lo largo de todo el proyecto. Esto facilita la lectura y mantenimiento del c칩digo, especialmente en proyectos con m칰ltiples desarrolladores.
7. **Evitar nombres gen칠ricos:** Nombres como data o info no proporcionan informaci칩n 칰til sobre lo que contiene la variable. Nombres m치s espec칤ficos como datosUsuario o informacionPago son preferibles.

<h4 className="font-medium mt-5">Ejemplo</h4>

Aqu칤 te muestro c칩mo podr칤as declarar y utilizar algunas variables en un peque침o fragmento de c칩digo en JavaScript:

```js copy filename="JavaScript"
let nombreUsuario = "Ana L칩pez"; // Almacena el nombre de un usuario
const IVA = 0.16; // Almacena el valor del Impuesto al Valor A침adido
let precioSinIVA = 200; // Precio de un producto sin IVA
let precioConIVA = precioSinIVA + precioSinIVA * IVA; // Calcula el precio con IVA

console.log("El precio final es de $" + precioConIVA); // Muestra el precio final
```

En este ejemplo, nombreUsuario y precioSinIVA son variables que pueden cambiar a lo largo del programa, mientras que IVA es una constante, lo que significa que su valor no cambiar치 una vez asignado.

<Callout emoji="游" type="default">
  El uso adecuado de variables no solo hace que tu c칩digo sea m치s f치cil de
  entender y mantener, sino que tambi칠n es crucial para la gesti칩n eficiente de
  la memoria y el rendimiento de tus aplicaciones. Aprender a nombrar
  correctamente las variables es un paso esencial para cualquier programador, ya
  que mejora la calidad del c칩digo y facilita la colaboraci칩n entre
  desarrolladores en proyectos m치s grandes.
</Callout>

## Declaraci칩n de variables

Cuando declaramos una variable en JavaScript, estamos no solo reservando un nombre, sino tambi칠n asignando espacio en la memoria para almacenar los valores que esta variable pueda tener a lo largo de la ejecuci칩n del programa. Este es un concepto fundamental, pues las variables son los bloques constructores b치sicos de cualquier programa en JavaScript.

### 쮺칩mo se Declara una Variable?

Para declarar variables en JavaScript, tenemos tres palabras clave: var, let, y const. Cada una tiene sus propios usos espec칤ficos y alcances:

1. **var:** Fue la forma original de declarar variables en JavaScript. Al declarar una variable con var, esta tiene un alcance de funci칩n (function scope), pero permite la redeclaraci칩n dentro del mismo alcance, lo que puede conducir a errores sutiles.

```js copy filename="JavaScript"
var height;
var height; // Permitido: redeclarar la variable
console.log(height); // -> undefined
x++;
```

2. **let:** Introducido en las versiones m치s recientes de JavaScript (ES6), let proporciona un alcance de bloque (block scope), que restringe su uso al bloque en el que fue declarado. let no permite la redeclaraci칩n de la misma variable dentro de su alcance, lo que ayuda a evitar algunos errores comunes.

```js copy filename="JavaScript"
let height;
// let height; // Error: 'height' ya ha sido declarada
console.log(height); // -> undefined
```

3. **const:** Similar a let en cuanto al alcance de bloque, pero se utiliza para declarar variables cuyo valor no cambiar치 despu칠s de ser asignado inicialmente. Intentar reasignar un valor a una constante resultar치 en un error.

```js copy filename="JavaScript"
const GRAVITY = 9.8;
// GRAVITY = 9.81; // Error: asignaci칩n a una constante
```

<h4 className="font-medium mt-5">Ejemplo de Declaraci칩n y Uso Inicial</h4>

Un aspecto importante al declarar variables con var o let es que inicialmente toman el valor de undefined hasta que se les asigna expl칤citamente un valor. Este comportamiento es diferente cuando olvidamos declarar una variable y tratamos de usarla, lo que resulta en un ReferenceError.

```js copy filename="JavaScript"
var weight;
console.log(weight); // -> undefined
console.log(age); // -> Uncaught ReferenceError: age is not defined
```

### Buenas Pr치cticas en la Declaraci칩n de Variables

- **Usar let y const en lugar de var:** Las modificaciones en el lenguaje y las buenas pr치cticas actuales sugieren usar let y const para una mayor claridad y control del alcance, adem치s de prevenir errores por redeclaraciones o hoisting.
- **Inicializaci칩n al declarar:** Siempre que sea posible, inicializa las variables al momento de declararlas para evitar el valor undefined.
- **Nombres descriptivos:** Elige nombres que describan claramente el prop칩sito de la variable, lo que aumenta la legibilidad del c칩digo.

## Inicializaci칩n de Variables

La inicializaci칩n de variables es un proceso esencial en la programaci칩n en JavaScript que implica asignar un valor inicial a una variable inmediatamente despu칠s de declararla. Este paso no solo define el estado inicial de la variable, sino que tambi칠n asegura que la variable est칠 lista para su uso en el c칩digo. La falta de inicializaci칩n puede llevar a problemas, ya que las variables no inicializadas en JavaScript tienen un valor predeterminado de undefined, que puede causar comportamientos inesperados en el programa.

### M칠todos de Inicializaci칩n

1. **Inicializaci칩n Directa:** Es el m칠todo m치s com칰n y directo. Consiste en asignar un valor a la variable en el momento de su declaraci칩n utilizando el operador de asignaci칩n =.

```js copy filename="JavaScript"
let height = 180; // Declaraci칩n e inicializaci칩n en una l칤nea
console.log(height); // -> 180
```

2. **Inicializaci칩n con el Valor de Otra Variable:** Una variable puede ser inicializada utilizando el valor de otra variable ya existente.

```js copy filename="JavaScript"
let originalAge = 30;
let age = originalAge; // Inicializaci칩n con el valor de otra variable
console.log(age); // -> 30
```

3. **Inicializaci칩n Post-Declaraci칩n:** En ocasiones, primero se declara la variable y m치s adelante en el c칩digo se le asigna un valor.

```js copy filename="JavaScript"
let weight;
weight = 70; // Asignaci칩n posterior a la declaraci칩n
console.log(weight); // -> 70
```

### Importancia del Contexto y la Clave let

El uso de let en la declaraci칩n e inicializaci칩n de variables aporta claridad y reduce los errores, dado que let tiene un alcance de bloque, limitando el uso de la variable al bloque donde se declara. Esto evita problemas comunes de sobreescritura inadvertida que pueden ocurrir con var, que tiene un alcance m치s amplio y permite redeclaraciones.

### Buenas Pr치cticas en la Inicializaci칩n

- **Inicializar al Declarar:** Siempre que sea posible, es recomendable inicializar las variables en el momento de la declaraci칩n para evitar el estado undefined.
- **Claridad en la Declaraci칩n:** Para mantener el c칩digo legible y mantenible, es preferible declarar e inicializar cada variable en su propia l칤nea, aunque JavaScript permite hacer m칰ltiples declaraciones en una sola l칤nea.

```js copy filename="JavaScript"
// Declaraci칩n m칰ltiple, menos recomendable por legibilidad
let x = 5,
  y = 10,
  z = 15;

// Declaraci칩n individual, m치s clara y preferida
let x = 5;
let y = 10;
let z = 15;
```

- **Sensibilidad a May칰sculas y Min칰sculas:** JavaScript diferencia entre may칰sculas y min칰sculas, por lo que es crucial ser consistente en el uso de may칰sculas y min칰sculas al referirse a variables.

```js copy filename="JavaScript"
let precio = 100;
let Precio = 200;
console.log(precio); // -> 100
console.log(Precio); // -> 200
```

## Declaraciones y Modo Estricto

### Revisi칩n Hist칩rica de JavaScript y la Importancia del Modo Estricto

JavaScript ha evolucionado considerablemente desde su creaci칩n, especialmente con cambios significativos introducidos en 2009 y 2015, que incluyeron no solo extensiones de sintaxis sino tambi칠n mejoras en el comportamiento de los int칠rpretes. Estas modificaciones fueron esenciales para hacer el lenguaje m치s robusto y predecible, especialmente en situaciones potencialmente err칩neas como la inicializaci칩n de variables sin una declaraci칩n previa.

### El Problema de las Declaraciones Impl칤citas

Originalmente, JavaScript permit칤a la pr치ctica de usar variables que no hab칤an sido declaradas formalmente. Esta flexibilidad resultaba en un c칩digo que, aunque funcional, pod칤a conducir a situaciones ambiguas y errores dif칤ciles de rastrear.

```js copy filename="JavaScript"
height = 180;
console.log(height); // -> 180
```

En este caso, la variable height se utiliza sin haber sido declarada formalmente, lo que en contextos antiguos del lenguaje, era permitido y no causaba error alguno.

### Introducci칩n del Modo Estricto

El "modo estricto" fue introducido para abordar estas y otras cuestiones, estableciendo un conjunto de restricciones que mejoran la gesti칩n de errores y la predictibilidad del c칩digo.

### Activaci칩n del Modo Estricto:

El modo estricto se activa a침adiendo la cadena **"use strict"**; al inicio del script o funci칩n. Esta simple l칤nea cambia radicalmente c칩mo el int칠rprete maneja el c칩digo, adheri칠ndose a un est치ndar m치s estricto y moderno de JavaScript.

```js copy filename="JavaScript"
"use strict";
height = 180; // -> Uncaught ReferenceError: height is not defined
console.log(height);
```

Aqu칤, al intentar usar height sin haberla declarado, el int칠rprete genera un error (ReferenceError), indicando que el uso de una variable no declarada no est치 permitido bajo el modo estricto.

### Beneficios del Modo Estricto

1. **Prevenci칩n de Errores:** Al requerir que todas las variables sean declaradas antes de su uso, el modo estricto ayuda a prevenir errores que pueden ser dif칤ciles de detectar y solucionar, especialmente en aplicaciones grandes y complejas.
2. **Mejoras en el Rendimiento:** Al permitir a los motores de JavaScript hacer optimizaciones m치s espec칤ficas, el modo estricto puede mejorar el rendimiento del c칩digo.
3. **C칩digo M치s Limpio y Seguro:** El modo estricto fomenta pr치cticas de codificaci칩n m치s limpias y seguras, alineadas con los est치ndares modernos.

### Mejores Pr치cticas

- **Uso Consistente del Modo Estricto:** Se recomienda usar "use strict"; en todos tus scripts para aprovechar sus beneficios y asegurarte de que tu c칩digo sea compatible con las versiones m치s recientes de JavaScript.
- **Declarar Siempre Todas las Variables:** Evita la tentaci칩n de depender de declaraciones impl칤citas. Aseg칰rate de declarar todas tus variables con var, let o const.

## Reasignaci칩n de Variables

La reasignaci칩n en JavaScript es el proceso mediante el cual se cambia el valor almacenado en una variable existente. Este proceso es fundamental en la programaci칩n din치mica y permite a las variables almacenar diferentes tipos de datos a lo largo del tiempo, reflejando su naturaleza "variable".

### Flexibilidad de Tipos en JavaScript

Una de las caracter칤sticas distintivas de JavaScript es su tipado d칠bil y din치mico, lo que significa que las variables no est치n limitadas a un tipo de dato espec칤fico y pueden cambiar de tipo a lo largo de su vida 칰til. Esto permite una gran flexibilidad pero tambi칠n exige una comprensi칩n clara de c칩mo los datos son manejados y transformados en JavaScript.

```js copy filename="JavaScript"
let greeting = "Hello!";
console.log(greeting); // Imprime: Hello!
greeting = 1;
console.log(greeting); // Imprime: 1
```

En este ejemplo, la variable greeting inicialmente almacena una cadena de texto y luego se reasigna para guardar un n칰mero. JavaScript maneja este cambio de tipo sin errores, adapt치ndose din치micamente al nuevo tipo de dato.

### Operaciones con Variables Reasignadas

La reasignaci칩n no solo implica cambiar el valor de una variable, sino que tambi칠n puede involucrar operaciones que modifiquen ese valor de formas m치s complejas, como la adici칩n o concatenaci칩n.

```js copy filename="JavaScript"
let steps = 100;
console.log(steps); // -> 100
steps = steps + 200;
console.log(steps); // -> 320
```

Aqu칤, steps se inicializa a 100, luego se le suma 200, resultando en 320. Este ejemplo muestra c칩mo una variable puede ser utilizada en una operaci칩n matem치tica y luego reasignada con el resultado.

### Conversi칩n Impl칤cita de Tipos

JavaScript tambi칠n realiza conversiones impl칤citas de tipos cuando es necesario, lo que permite operaciones entre diferentes tipos de datos.

```js copy filename="JavaScript"
let greeting = "Hello!";
let counter = 100;
greeting = greeting + counter;
console.log(greeting); // -> Hello!100
```

En este caso, el n칰mero counter se convierte impl칤citamente en una cadena para poder concatenarse con greeting, demostrando c칩mo JavaScript gestiona los tipos de manera flexible para facilitar operaciones entre ellos.

### Buenas Pr치cticas en la Reasignaci칩n de Variables

- **Claridad en la Modificaci칩n de Variables:** Es crucial utilizar nombres claros y descriptivos para las variables que van a ser modificadas frecuentemente, para evitar confusi칩n sobre el estado actual del dato que almacenan.
- **Precauci칩n con la Conversi칩n de Tipos:** Dado que JavaScript maneja la conversi칩n de tipos de manera impl칤cita, es importante ser consciente de estos cambios para evitar resultados inesperados, especialmente en operaciones complejas o en la integraci칩n de m칰ltiples fuentes de datos.
- **Evitar Reasignaciones Innecesarias:** Aunque JavaScript permite la reasignaci칩n flexible de variables, usar esta caracter칤stica sin restricciones puede llevar a c칩digo dif칤cil de seguir y potencialmente propenso a errores.

## Constantes

En JavaScript, una constante es un tipo de "contenedor" que, a diferencia de las variables comunes, no permite la reasignaci칩n de su valor una vez que ha sido establecido. Esto se logra mediante la palabra clave **const**. La utilizaci칩n de constantes es crucial para asegurar la inmutabilidad de valores que no deben cambiar tras su inicializaci칩n inicial, proporcionando robustez y previsibilidad al c칩digo.

### Caracter칤sticas de las Constantes

1. **Inicializaci칩n Obligatoria:**

- Una constante debe ser inicializada en el momento de su declaraci칩n. Omitir el valor inicial resultar치 en un error sint치ctico, ya que el compilador espera un valor para completar la inicializaci칩n.

```js copy filename="JavaScript"
const greeting = "Hello!";
// const message; // Esto causar칤a un error: Missing initializer in const declaration
```

2. **Finalidad de Uso:**

- Las constantes son especialmente 칰tiles para almacenar informaci칩n que no deber칤a cambiar a lo largo de la ejecuci칩n del programa, como configuraciones, tokens de acceso, y rutas a recursos.
- Adem치s, su uso permite optimizaciones por parte del motor JavaScript, lo cual puede tener un impacto positivo en el rendimiento del programa.

<h4 className="font-medium mt-5">Ejemplos de Uso de Constantes</h4>

1. Declaraci칩n y Modificaci칩n Prohibida:

```js copy filename="JavaScript"
const greeting = "Hello!";
console.log(greeting); // Imprime: Hello!
// greeting = "Hi!"; // Esto causar칤a un error: Assignment to constant variable.
```

2. Constantes en C치lculos y Configuraciones:

```js copy filename="JavaScript"
const BASE_URL = "https://api.example.com";
const API_KEY = "abc123XYZ";
// Uso de constantes para configurar llamadas a APIs
```

3. Uso de Constantes en Bucles:

```js copy filename="JavaScript"
const MAX_ITERATIONS = 10;
for (let i = 0; i < MAX_ITERATIONS; i++) {
  console.log("Iteraci칩n n칰mero ", i);
}
console.log("Bucle finalizado.");
```

En este caso, MAX_ITERATIONS es una constante que define el n칰mero de iteraciones en un bucle, facilitando cambios durante el desarrollo sin necesidad de modificar el cuerpo del bucle.

### Consideraciones Adicionales

**Constantes No Son Siempre Inmutables:**

Es importante distinguir entre la reasignaci칩n de la constante y la mutabilidad de su contenido. Por ejemplo, las constantes que almacenan objetos o arrays pueden tener contenidos que se modifican:

```js copy filename="JavaScript"
const configuration = {
  server: "localhost",
  port: 8080,
};
configuration.port = 3000; // Esto es v치lido
// configuration = {}; // Esto no es v치lido y resultar치 en un error
```

**Nomenclatura:**

Para las constantes de valor fijo, es com칰n utilizar SNAKE_UPPER_CASE para su denominaci칩n, lo cual las hace f치cilmente identificables en el c칩digo. Para constantes que podr칤an ser ajustadas durante el desarrollo, este estilo de nombrado tambi칠n es 칰til para localizarlas r치pidamente.

<Callout emoji="游" type="default">
  Las constantes son una herramienta poderosa en JavaScript que ayuda a escribir
  c칩digo m치s seguro y estable, al prevenir cambios no intencionados en valores
  que deben permanecer constantes. Su correcta utilizaci칩n no solo facilita la
  gesti칩n de configuraciones y par치metros fijos, sino que tambi칠n contribuye a
  la optimizaci칩n y eficiencia del c칩digo.
</Callout>

## Scope

El "scope" o 치mbito de una variable se refiere a la regi칩n del programa donde esta variable es accesible. Entender el scope es crucial porque dicta c칩mo y d칩nde se pueden utilizar las variables en un programa. Aunque el concepto puede parecer simple, tiene profundas implicaciones en c칩mo se estructura el c칩digo y se evitan errores comunes como colisiones de nombres o problemas de acceso a datos.

### Tipos de Scope

**Global Scope**

- Si una variable se declara fuera de cualquier funci칩n o bloque, se encuentra en el 치mbito global. Esto significa que puede ser accesible desde cualquier parte del c칩digo que se ejecute despu칠s de su declaraci칩n.
- El uso excesivo del 치mbito global puede llevar a problemas de mantenimiento y a conflictos entre nombres de variables, especialmente en proyectos grandes.

```js copy filename="JavaScript"
var globalVar = "Accessible everywhere";
function testFunction() {
  console.log(globalVar); // Imprime: Accessible everywhere
}
console.log(globalVar); // Tambi칠n imprime: Accessible everywhere
```

**Local Scope (Function Scope)**

Las variables declaradas dentro de una funci칩n tienen un scope local a esa funci칩n, lo que significa que solo pueden ser accesibles dentro de ella. Este 치mbito protege a las variables de ser accesibles globalmente, lo que ayuda a evitar modificaciones no deseadas y conflictos.

```js copy filename="JavaScript"
function testLocalScope() {
  var localVar = "Accessible only in this function";
  console.log(localVar); // Imprime: Accessible only in this function
}
testLocalScope();
// console.log(localVar); // Error: localVar is not defined
```

**Block Scope**

- Con la introducci칩n de let y const en ES6, JavaScript gan칩 la capacidad de definir variables con 치mbito de bloque, limitando su acceso al bloque en el que son declaradas, como dentro de bucles o condiciones.
- Un bloque se define como cualquier secci칩n de c칩digo encerrada entre llaves {}.
- Este tipo de scope es particularmente 칰til para controlar la **`vida 칰til de las variables`** y reducir efectos secundarios fuera del bloque.

```js copy filename="JavaScript"
let counter;
console.log(counter); // -> undefined
{
  counter = 1;
  console.log(counter); // -> 1
}
counter = counter + 1;
console.log(counter); // -> 2
```

En este ejemplo, counter es accesible dentro y fuera del bloque porque fue declarada fuera del mismo. Sin embargo, su valor es modificado dentro del bloque y el cambio persiste fuera del mismo.

<Callout emoji="游땟" type="info">

<h4 className="font-medium">쯏 Qu칠 es la Vida 칔til de las Variables?</h4>

La "vida 칰til" de una variable en JavaScript se refiere al per칤odo durante el cual
la variable existe en la memoria y puede ser accedida o modificada. La vida 칰til
de una variable est치 intr칤nsecamente ligada a su 치mbito o "scope", y determina
cu치ndo y c칩mo se crean, utilizan y destruyen las variables.

</Callout>

---

### Hoisting

El hoisting es un mecanismo en JavaScript por el cual las declaraciones de variables y funciones son movidas a la parte superior de su 치mbito antes de que el c칩digo sea ejecutado. Este comportamiento puede ser confuso porque permite el uso de funciones y variables antes de que est칠n visualmente declaradas en el c칩digo. Aunque se le describe a menudo como un "levantamiento", es m치s precisamente un comportamiento del int칠rprete de JavaScript que procesa declaraciones durante la fase de compilaci칩n.

#### Mecanismo de Hoisting

1. **Hoisting de Variables:**

- **Variables var:** Las declaraciones de variables realizadas con var son elevadas al inicio de su contexto de ejecuci칩n (al inicio de la funci칩n si son locales, o al inicio del script si son globales). Estas variables son inicializadas con undefined en el momento del hoisting.
- **Variables let y const:** Aunque tambi칠n son hoisted, no son inicializadas con undefined. En lugar de eso, entran en una zona llamada Temporal Dead Zone (TDZ) hasta que su declaraci칩n es alcanzada en el flujo del c칩digo, momento en el cual pueden ser inicializadas. Acceder a estas variables antes de su inicializaci칩n resultar치 en un ReferenceError.

<Callout emoji="游땟" type="info">

<h4 className="font-medium">쯏 Qu칠 es el Temporal Dead Zone (TDZ)?</h4>

La Temporal Dead Zone (TDZ) representa un periodo durante el cual estas variables
est치n en un estado "muerto" en el que no pueden ser accedidas ni utilizadas de ninguna
manera. La TDZ empieza desde el bloque de c칩digo donde la variable es declarada y
termina cuando la variable es inicializada.

En otras palabras la TDZ es un mecanismo de seguridad que JavaScript implementa para garantizar que las variables se utilicen de manera correcta, previniendo errores que podr칤an surgir al acceder a variables antes de que est칠n debidamente inicializadas. Esto contrasta con las variables declaradas con var, que son inicializadas con undefined y son accesibles antes de su declaraci칩n expl칤cita en el c칩digo.

```js copy filename="JavaScript"
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 3;
```

En este ejemplo, intentar imprimir a antes de que sea declarada resulta en un ReferenceError porque a est치 en la TDZ en ese momento.

</Callout>

2. **Hoisting de Funciones:**

Las funciones declaradas (aquellas definidas mediante una declaraci칩n de funci칩n, no mediante expresiones de funci칩n) son hoisted completamente, lo que significa que pueden ser llamadas antes de su declaraci칩n en el c칩digo.

<h4 className="font-medium top-5">Ejemplo</h4>

1. Ejemplo de Hoisting con var:

```js copy filename="JavaScript"
console.log(num); // undefined
var num = 6;
console.log(num); // 6
```

En este ejemplo, la variable num se hoistea al inicio de su 치mbito y se inicializa con undefined, lo que permite que el primer console.log ejecute sin error, mostrando undefined.

2. Ejemplo de Hoisting con Funci칩n:

```js copy filename="JavaScript"
greet(); // "Hello, world!"
function greet() {
  console.log("Hello, world!");
}
```

Aqu칤, la funci칩n greet puede ser invocada antes de su declaraci칩n visual en el c칩digo debido al hoisting.

3. Ejemplo de Hoisting con let y Impacto de TDZ:

```js copy filename="JavaScript"
console.log(value); // ReferenceError: Cannot access 'value' before initialization
let value = 10;
```

A pesar de que value est치 hoisted, intentar acceder a ella antes de su l칤nea de declaraci칩n resulta en un error debido a que est치 en la TDZ.

---

### Scope de let y const

Las palabras clave let y const introducidas en ECMAScript 2015 trajeron consigo una nueva manera de manejar el scope de las variables en JavaScript. A diferencia de var, que proporciona un scope de funci칩n, let y const ofrecen un scope de bloque [Block Scope](#block-scope), lo que significa que limitan el alcance de las variables al bloque en el que se declaran.

<h4 className="font-medium mt-5">Ejemplos</h4>

1. **Scope Global y Local:**

```js copy filename="JavaScript"
let globalLet = "Visible en todo el programa";
const globalConst = "Tambi칠n visible en todo el programa";

{
  let blockLet = "Visible solo en este bloque";
  const blockConst = "Igualmente visible solo en este bloque";
  console.log(globalLet); // -> "Visible en todo el programa"
  console.log(globalConst); // -> "Tambi칠n visible en todo el programa"
  console.log(blockLet); // -> "Visible solo en este bloque"
  console.log(blockConst); // -> "Igualmente visible solo en este bloque"
}

console.log(globalLet); // -> "Visible en todo el programa"
console.log(globalConst); // -> "Tambi칠n visible en todo el programa"
// console.log(blockLet);    // Error: blockLet is not defined
// console.log(blockConst);  // Error: blockConst is not defined
```

2. **Ejemplo con Bucle for:**

```js copy filename="JavaScript"
console.log("Antes: ", typeof p); // -> "undefined"

for (let p = 0; p < 3; p++) {
  console.log("Valor de p: ", p); // -> 0, 1, 2
}

console.log("Despu칠s: ", typeof p); // -> "undefined"
```

En este ejemplo, p solo existe dentro del bucle for. Fuera de este, p no est치 definida, demostrando el block scope de let.

3. **Scope en Bloques Anidados:**

```js copy filename="JavaScript"
let outerVariable = 200;
{
  let innerVariable = 100;
  {
    let innerMostVariable = "interior";
    console.log(outerVariable); // -> 200
    console.log(innerVariable); // -> 100
    console.log(innerMostVariable); // -> "interior"
  }
  console.log(outerVariable); // -> 200
  console.log(innerVariable); // -> 100
  // console.log(innerMostVariable);  // Error: innerMostVariable is not defined
}
```

Aqu칤, cada variable est치 confinada a su respectivo bloque, con innerMostVariable accesible solo en su bloque m치s interno.

### Scope de var

La declaraci칩n de variables utilizando var en JavaScript es un tema fundamental que abarca varios aspectos del comportamiento de las variables en diferentes contextos. Aunque hoy en d칤a el uso de var es considerado obsoleto en favor de let y const, es importante entender su funcionamiento para comprender c칩digo legado o para manejar situaciones donde se requiere compatibilidad con versiones antiguas de JavaScript.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos el siguiente escenario para ilustrar c칩mo var se comporta dentro de un bucle, pero afecta el 치mbito fuera de 칠l:

```js copy filename="JavaScript"
console.log("Antes: ", i); // Error: i is not defined
for (var i = 0; i < 3; i++) {
  console.log("Valor de i: ", i); // Muestra 0, 1, 2
}
console.log("Despu칠s: ", i); // Muestra 3
```

En este ejemplo, aunque i se declara dentro del bucle for, sigue siendo accesible fuera de este. Esto se debe a que var no respeta el 치mbito de bloque, y eleva la variable al 치mbito funcional m치s cercano, o al 치mbito global si no est치 dentro de una funci칩n.

#### Comportamiento de var en Diferentes 츼mbitos

Como se mencion칩 anteriormente, var tiene un comportamiento particular cuando se trata de 치mbitos de variable:

1. **Scope Global:** Al declarar una variable con var fuera de cualquier funci칩n, esta se vuelve global. Esto significa que ser치 accesible desde cualquier punto del script despu칠s de su declaraci칩n. Es importante notar que el uso de var en este contexto puede llevar a posibles conflictos o errores dif칤ciles de rastrear debido a la contaminaci칩n del scope global.

2. **Scope a nivel de funci칩n:** var tiene un comportamiento particular cuando se utiliza dentro de funciones. A diferencia de otros bloques (como los de if o ciclos for), solo las funciones crean un nuevo 치mbito para las variables declaradas con var.

El 치mbito funcional de var se hace evidente cuando se usa dentro de funciones. Aqu칤, var se comporta de manera m치s controlada:

```js copy filename="JavaScript"
var outerVar = "Soy global";
{
  var innerVar = "쯊ambi칠n soy global?";
  console.log(outerVar); // Muestra "Soy global"
  console.log(innerVar); // Muestra "쯊ambi칠n soy global?"
}
console.log(innerVar); // Muestra "쯊ambi칠n soy global?"
```

En este ejemplo, innerVar parece ser una variable local al bloque {}, pero debido a que var no reconoce estos bloques como 치mbitos separados (a excepci칩n de las funciones), innerVar es accesible globalmente.

#### Importancia de Entender var

Aunque var es menos utilizado en c칩digo moderno, entender su comportamiento es crucial para:

1. **Mantenimiento de C칩digo Legado:** Muchos proyectos antiguos a칰n utilizan var, por lo que comprender su comportamiento permite modificar o actualizar esos proyectos sin introducir errores.
2. **Comprender Conceptos Fundamentales:** Aprender sobre var y su comportamiento puede ser una excelente manera de entender c칩mo JavaScript maneja los 치mbitos de variables.

#### Variables var y el Objeto window

En un entorno de navegador, las variables globales declaradas con var se a침aden al objeto window, lo que significa que son accesibles como propiedades de este objeto global:

```js copy filename="JavaScript"
var globalVar = "accesible";
console.log(window.globalVar); // "accesible"
```

Este comportamiento puede tener implicaciones de seguridad y rendimiento, ya que las propiedades del objeto window son accesibles globalmente en todo el script que se ejecuta en la ventana del navegador.

### Fases del Scope

En JavaScript, el manejo del scope y la vida 칰til de las variables atraviesan varias fases que son cruciales para entender c칩mo y cu치ndo las variables son creadas, utilizadas y eliminadas. Estas fases incluyen la declaraci칩n, la inicializaci칩n, el uso y, finalmente, la salida de scope que lleva a la recolecci칩n de basura en algunos casos. Vamos a desglosar estas fases para entender mejor el proceso:

1. **Declaraci칩n**

La fase de declaraci칩n es donde el nombre de la variable es registrado en su 치mbito correspondiente. Durante esta fase, el motor de JavaScript reconoce la variable y asigna un espacio en la memoria para ella, aunque a칰n no se le ha asignado un valor (excepto en el caso de las constantes, que deben ser inicializadas en su declaraci칩n).

- **Variables var:** Se procesan al inicio de la ejecuci칩n de la funci칩n o del script global debido al hoisting. Inicialmente, se inicializan con el valor undefined.
- **Variables let y const:** No se inicializan durante la fase de hoisting, lo que significa que no pueden ser accesadas hasta que la declaraci칩n sea ejecutada expl칤citamente en el c칩digo. El acceso antes de su inicializaci칩n resulta en un ReferenceError.

2. **Inicializaci칩n**

La inicializaci칩n ocurre cuando a la variable se le asigna un valor por primera vez. En el caso de var, esto puede ser inmediatamente despu칠s del hoisting si la declaraci칩n y la asignaci칩n est치n en la misma l칤nea. Para let y const, la inicializaci칩n debe ocurrir expl칤citamente despu칠s de la declaraci칩n en el c칩digo.

3. **Uso**

Durante la fase de uso, la variable puede ser le칤da o modificada, dependiendo de su tipo (const no permite modificaciones despu칠s de la inicializaci칩n). Esta fase contin칰a hasta que la variable sale de su 치mbito o hasta que el programa termina, en el caso de las variables globales.

4. **Salida de Scope**

Una variable sale de scope cuando el bloque de c칩digo en el que fue declarada termina su ejecuci칩n. En el caso de las funciones, esto ocurre cuando la funci칩n termina de ejecutarse. Las variables que salen de scope ya no son accesibles desde el c칩digo.

## Breves palabras sobre las funciones

Las funciones en JavaScript son una de las piezas fundamentales en la construcci칩n de programas eficientes y organizados. Permiten encapsular c칩digo que realiza una tarea espec칤fica para reutilizarlo m칰ltiples veces sin necesidad de repetirlo, lo cual es crucial para mantener el c칩digo limpio y f치cil de mantener.

### 쯇or qu칠 usar funciones?

Usar funciones hace que el c칩digo sea m치s legible y f치cil de depurar. Si una tarea particular necesita ser modificada, puedes hacerlo en un solo lugar, en la definici칩n de la funci칩n, en lugar de buscar y cambiar m칰ltiples instancias del mismo c칩digo dispersas por todo el programa.

### Declaraci칩n de Funciones

Las funciones se declaran usando la palabra clave function, seguida de un nombre, par칠ntesis que pueden incluir par치metros, y un bloque de c칩digo encerrado en llaves. Aqu칤 tienes un ejemplo simple:

```js copy filename="JavaScript"
function mostrarMensaje() {
  console.log("Hola, soy una funci칩n");
}
```

### Llamada a Funciones

Para ejecutar la funci칩n, la "llamamos" usando su nombre seguido de par칠ntesis. Si la funci칩n toma par치metros, los valores de esos par치metros se colocan dentro de los par칠ntesis.

```js copy filename="JavaScript"
mostrarMensaje(); // Llama a la funci칩n y muestra: Hola, soy una funci칩n
```

<h4 className="font-medium mt-5">Ejemplo de Reusabilidad de Funciones</h4>

Las funciones no solo ahorran tiempo durante la escritura del c칩digo, sino que tambi칠n hacen que el mantenimiento sea m치s sencillo. Aqu칤 hay un ejemplo que ilustra c칩mo se puede usar una funci칩n para evitar la repetici칩n de c칩digo:

```js copy filename="JavaScript"
function repetirFrase(frase, veces) {
  for (let i = 0; i < veces; i++) {
    console.log(frase);
  }
}

repetirFrase("Hola mundo", 3);
```

En este caso, la funci칩n repetirFrase toma dos par치metros: la frase a repetir y el n칰mero de veces que se debe repetir. Esto muestra c칩mo las funciones pueden ser herramientas poderosas para escribir c칩digo modular y reutilizable.

## Sombreado de Variables

El sombreado de variables ocurre cuando una variable de 치mbito local tiene el mismo nombre que una variable en un 치mbito superior o global. En JavaScript, esto significa que la variable local "oculta" a la variable global dentro de su propio 치mbito, permitiendo comportamientos y valores diferentes a los de la variable global.

### Impacto del Sombreado de Variables

El sombreado permite una flexibilidad considerable en c칩mo se manejan los datos dentro de funciones o bloques espec칤ficos, pero tambi칠n puede introducir complejidad y posibles errores si no se maneja cuidadosamente. Por ello, es crucial comprender completamente c칩mo y por qu칠 ocurre el sombreado.

<h4 className="font-medium mt-5">Ejemplos</h4>

**Sin Sombreado**

Primero, observemos un caso sin sombreado. Aqu칤, counter se modifica dentro de un bloque, afectando su valor globalmente:

```js copy filename="JavaScript"
let counter = 100;
console.log(counter); // -> 100
{
  counter = 200;
  console.log(counter); // -> 200
}
console.log(counter); // -> 200
```

En este ejemplo, no se introduce una nueva declaraci칩n dentro del bloque, por lo que counter referenciado dentro del bloque sigue siendo la variable global.

**Con Sombreado**

Ahora, veamos un caso con sombreado. Aqu칤, counter dentro del bloque es una nueva variable local que sombrea a la global:

```js copy filename="JavaScript"
let counter = 100;
console.log(counter); // -> 100
{
  let counter = 200; // Sombreado aqu칤
  console.log(counter); // -> 200
}
console.log(counter); // -> 100
```

Este ejemplo demuestra c칩mo la declaraci칩n con let dentro del bloque crea una nueva instancia de counter que no afecta a la variable global del mismo nombre fuera del bloque.

### Sombreado en Funciones

El sombreado tambi칠n es com칰n en el contexto de las funciones, especialmente con el uso de var, que tiene un 치mbito limitado a la funci칩n:

```js copy filename="JavaScript"
var counter = 100;

function testFunction() {
  var counter = 200; // Sombreado dentro de la funci칩n
  console.log(counter); // -> 200
}

console.log(counter); // -> 100
testFunction(); // Accede a la versi칩n sombreada de counter
console.log(counter); // -> 100
```

## Ejercicios

A continuaci칩n, presento una serie de quizes, preguntas y ejercicios dise침ados para ayudarte a consolidar tu comprensi칩n sobre los conceptos b치sicos de JavaScript que hemos discutido. Cada ejercicio incluye una soluci칩n para que puedas verificar tu trabajo.

### Quizes

<h4 className="font-medium mt-5">쯈u칠 es una variable en JavaScript?</h4>

<p className="my-2">a) Una funci칩n que almacena datos</p>
<p>b) Un contenedor para almacenar datos</p>
<p className="my-2">c) Un tipo de bucle</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Un contenedor para almacenar datos</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 palabra clave en JavaScript declara una variable que no puede ser
  reasignada?
</h4>

<p className="my-2">a) let</p>
<p>b) var</p>
<p className="my-2">c) const</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) const</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  En JavaScript, 쯖u치l de las siguientes opciones representa una pr치ctica
  correcta de nombramiento de variables?
</h4>

<p className="my-2">a) Comenzar con un n칰mero</p>
<p>b) Usar espacios entre palabras</p>
<p className="my-2">c) Usar camelCase</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Usar camelCase</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쮺u치l es el resultado de una variable declarada con var fuera de cualquier
  funci칩n?
</h4>

<p className="my-2">a) Scope global</p>
<p>b) Scope local</p>
<p className="my-2">c) No tiene scope</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Scope global</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">쯈u칠 es el hoisting en JavaScript?</h4>

<p className="my-2">a) Priorizar la ejecuci칩n de funciones</p>
<p>b) Elevar las declaraciones de variables al inicio de su contexto</p>
<p className="my-2">c) Ignorar declaraciones de variables</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Elevar las declaraciones de variables al inicio de su contexto
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 sucede cuando intentas reasignar una variable const?
</h4>

<p className="my-2">a) La variable es reasignada sin problemas</p>
<p>b) Se lanza un error de tipo</p>
<p className="my-2">c) Se ignora la reasignaci칩n</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Se lanza un error de tipo</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 m칠todo se utiliza para imprimir informaci칩n en la consola de JavaScript?
</h4>

<p className="my-2">a) console.print()</p>
<p>b) console.log()</p>
<p className="my-2">c) console.output()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) console.log()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 describe mejor el 'scope' de una variable en JavaScript?
</h4>

<p className="my-2">a) El valor de la variable</p>
<p>b) El tipo de la variable</p>
<p className="my-2">c) El 치rea del programa donde la variable es accesible</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      c) El 치rea del programa donde la variable es accesible
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 es sombreado de variables en JavaScript?
</h4>

<div className="my-2">
  a) Cambiar el valor de una variable global dentro de una funci칩n
</div>
<p>b) Declarar una nueva variable local con el mismo nombre que una global</p>
<p className="my-2">c) Eliminar una variable global</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Declarar una nueva variable local con el mismo nombre que una global
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쮺u치l es una caracter칤stica de las funciones en JavaScript?
</h4>

<p className="my-2">a) No pueden retornar valores</p>
<p>b) Pueden contener otras funciones</p>
<p className="my-2">c) Pueden contener otras funciones</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Pueden contener otras funciones</AccordionContent>
  </AccordionItem>
</Accordion>

### Preguntas

<h4 className="font-medium mt-5">
  쮺칩mo diferir칤as el uso de var, let y const en la declaraci칩n de variables?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      - **var** es la forma m치s antigua de declarar variables y tiene un scope a nivel de funci칩n o global si se declara fuera de una funci칩n. Se deber칤a usar con precauci칩n, principalmente en situaciones donde la compatibilidad con navegadores antiguos es necesaria.
      - **let** permite declarar variables con un scope limitado al bloque, declaraci칩n o expresi칩n donde se usa. Es 칰til en la mayor칤a de los casos donde se requiere cambiar el valor de la variable despu칠s de su inicializaci칩n, como en bucles o condicionales.
      - **const** se utiliza para declarar variables que no deben cambiar su valor inicial una vez asignado, es decir, son constantes. Su scope tambi칠n es de bloque y ayuda a garantizar que los valores no sean reasignados, lo cual es 칰til para configuraciones y valores que no deber칤an cambiar a lo largo del tiempo.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯇uede explicar c칩mo el scope global afecta la seguridad y la gesti칩n de la
  memoria en una aplicaci칩n web?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El uso de variables globales puede llevar a problemas de seguridad ya que cualquier script incluido en la p치gina puede acceder y modificar estas variables, potencialmente llevando a comportamientos no deseados o ataques de tipo XSS (Cross-Site Scripting). En cuanto a la gesti칩n de memoria, las variables globales permanecen en memoria durante todo el ciclo de vida de la p치gina, lo que puede llevar a un uso ineficiente de recursos si las variables acumulan grandes cantidades de datos o si no se liberan adecuadamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Describe un escenario donde el hoisting podr칤a causar un bug en el c칩digo.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Supongamos que intentas utilizar una variable antes de declararla con var, pensando que ser칤a undefined, pero otro bloque de c칩digo anterior en el mismo scope la ha inicializado con un valor diferente. Por ejemplo:

      ```js copy filename="JavaScript"
      function ejemploHoisting() {
        console.log(miVar); // Esperas undefined, pero muestra 'Hola'
        var miVar = 'Mundo';
      }
      var miVar = 'Hola';
      ejemploHoisting();
      ```

      Aqu칤, el hoisting causa que miVar se declare al inicio de la funci칩n, pero toma el valor del miVar global inicializado previamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쮺칩mo podr칤as implementar el sombreado de variables para manejar
  configuraciones regionales en una aplicaci칩n?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Podr칤as tener una configuraci칩n regional global definida para toda la aplicaci칩n y luego, en funciones espec칤ficas que manejan l칩gica relacionada con localidades espec칤ficas, podr칤as declarar variables locales (sombreadas) que tengan configuraciones ajustadas a esas localidades. Esto permite una gran flexibilidad y mantiene el c칩digo limpio y modular.

      ```js copy filename="JavaScript"
      var configuracionGlobal = { moneda: 'USD', idioma: 'en' };
      function mostrarPrecios() {
        var configuracionGlobal = { moneda: 'EUR', idioma: 'es' }; // Sombreado
        console.log('Configuraci칩n usada:', configuracionGlobal);
      }
      mostrarPrecios();
      console.log('Configuraci칩n global:', configuracionGlobal);
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Explique la diferencia entre declarar una funci칩n con una declaraci칩n de
  funci칩n y una expresi칩n de funci칩n.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Las declaraciones de funci칩n son hoisted, lo que significa que pueden ser llamadas antes de que sean definidas en el c칩digo. Son ideales cuando se necesita que una funci칩n est칠 disponible globalmente a lo largo de todo el script.

      ```js copy filename="JavaScript"
      funcionEjemplo();
      function funcionEjemplo() {
        console.log('Funciona');
      }
      ```

      Las expresiones de funci칩n pueden ser an칩nimas o nombradas y no son hoisted, lo que significa que s칩lo pueden ser llamadas despu칠s de su definici칩n.

      ```js copy filename="JavaScript"
      var ejemploExpresion = function() {
        console.log('Funciona despu칠s de la declaraci칩n');
      };
      ejemploExpresion();
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쮺u치l es la importancia de inicializar variables correctamente en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Inicializar variables correctamente ayuda a evitar errores en tiempo de ejecuci칩n, facilita la lectura y mantenimiento del c칩digo, y asegura que las variables sean utilizadas con los valores esperados desde su primer uso, previniendo comportamientos indeseados o bugs dif칤ciles de rastrear.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쮺칩mo afecta use strict al comportamiento de las declaraciones de variables en
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El modo 'use strict' impide la declaraci칩n impl칤cita de variables globales, lo cual ayuda a prevenir errores comunes como asignaciones a variables no declaradas. Esto conduce a un c칩digo m치s seguro y predecible, obligando a los desarrolladores a declarar expl칤citamente sus variables antes de usarlas.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 t칠cnicas podr칤as usar para evitar colisiones de nombres en un espacio de
  nombres global grande?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una t칠cnica com칰n es el uso de IIFEs (Immediately Invoked Function Expressions) para encapsular el c칩digo en su propio 치mbito local. Otra t칠cnica es el uso de m칩dulos o espacios de nombres que agrupan funcionalidades relacionadas bajo un 칰nico objeto global.

      ```js copy filename="JavaScript"
      var MiAplicacion = MiAplicacion || {};
      MiAplicacion.Modulo = (function() {
        var variablePrivada = 'privada';
        return {
          metodoPublico: function() { console.log(variablePrivada); }
        };
      })();
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Discute c칩mo y por qu칠 podr칤as usar console.table() en el desarrollo de una
  aplicaci칩n.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      console.table() es 칰til para mostrar datos tabulares, como listas de objetos, en un formato legible en la consola. Esto es especialmente 칰til en el desarrollo cuando necesitas inspeccionar listas de datos, resultados de pruebas o cualquier informaci칩n estructurada. Ayuda a visualizar r치pidamente las propiedades y valores de los objetos sin necesidad de iterar manualmente a trav칠s de ellos.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  쯈u칠 estrategias usar칤as para optimizar la reasignaci칩n de variables en un
  bucle intensivo en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una estrategia es minimizar el n칰mero de reasignaciones dentro del bucle, por ejemplo, usando acumuladores o valores temporales fuera del bucle. Otra es evitar el uso de variables que no son necesarias fuera del bucle, restringi칠ndolas al 치mbito del bucle cuando sea posible, utilizando let en lugar de var para asegurar que el 치mbito de la variable sea limitado al bloque del bucle.

    </AccordionContent>

  </AccordionItem>
</Accordion>

### Ejercicios

<h4 className="font-medium mt-5">
  Declara dos variables, base y altura de un tri치ngulo. Inicial칤zalas con 10 y 5
  respectivamente. Calcula el 치rea (area = (base * altura) / 2) e impr칤melo con
  console.log().
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu칤 tu c칩digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let base = 10;
        let altura = 5;
        let area = (base * altura) / 2;
        console.log("El 치rea del tri치ngulo es:", area);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Crea una constante PI y as칤gnale 3.14159. Usa esta constante para calcular el
  치rea de un c칤rculo con radio 4. Imprime el resultado.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu칤 tu c칩digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const PI = 3.14159;
        let radio = 4;
        let areaCirculo = PI * radio * radio;
        console.log("El 치rea del c칤rculo es:", areaCirculo);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Declara una variable global color y as칤gnale "rojo". Dentro de una funci칩n,
  declara una variable local color y as칤gnale "azul". Muestra ambos colores
  usando console.log() dentro y fuera de la funci칩n.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu칤 tu c칩digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let color = "rojo";
        function cambiarColor() {
          let color = "azul";
          console.log("Color dentro de la funci칩n:", color);
        }
        cambiarColor();
        console.log("Color fuera de la funci칩n:", color);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Escribe una funci칩n que acepte dos par치metros y los multiplique. Retorna el
  resultado y gu치rdalo en una variable. Muestra este resultado.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu칤 tu c칩digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function multiplicar(a, b) {
          return a * b;
        }
        let resultado = multiplicar(6, 7);
        console.log("El resultado de la multiplicaci칩n es:", resultado);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Crea un array de n칰meros del 1 al 5. Usa un bucle para modificar cada elemento
  del array multiplic치ndolo por 2. Muestra el array modificado.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu칤 tu c칩digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let numeros = [1, 2, 3, 4, 5];
        for (let i = 0; i < numeros.length; i++) {
          numeros[i] *= 2;
        }
        console.log("Array modificado:", numeros);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>
