import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Tipos de Datos

En JavaScript, los tipos de datos son fundamentales para el manejo y la manipulaci√≥n de la informaci√≥n. Entender los tipos de datos y c√≥mo clasificarlos es esencial para escribir programas efectivos y eficientes.

## Definici√≥n de Tipos de Datos

Un tipo de dato en JavaScript define la naturaleza del valor que puede almacenar una variable. Los tipos de datos determinan qu√© operaciones se pueden realizar sobre los valores y c√≥mo se almacenan en la memoria. JavaScript es un lenguaje de tipado d√©bil y din√°mico, lo que significa que el tipo de una variable puede cambiar durante la ejecuci√≥n del programa y no necesita ser declarado expl√≠citamente.

### Clasificaci√≥n de los Tipos de Datos

En Javascript disponemos de los siguientes tipos de datos principales:

<table className="table-fixed my-5 w-full text-start">
  <thead className="bg-sky-900 text-white text-sm">
    <tr>
      <th>Tipo de Dato</th>
      <th>Descripci√≥n</th>
      <th>Ejemplo</th>
    </tr>
  </thead>
  <tbody>
    {[
      {
        tipoDeDato: "Number",
        descripci√≥n:
          "Representa valores num√©ricos, incluidos enteros y de punto flotante.",
        ejemplo: "let age = 30;",
      },
      {
        tipoDeDato: "BigInt",
        descripci√≥n:
          "Utilizado para almacenar n√∫meros m√°s grandes que el l√≠mite para un tipo Number.",
        ejemplo: "let bigNumber = 9007199254740991n;",
      },
      {
        tipoDeDato: "String",
        descripci√≥n: "Representa secuencias de caracteres.",
        ejemplo: 'let name = "Alice";',
      },
      {
        tipoDeDato: "Boolean",
        descripci√≥n: "Representa valores l√≥gicos true o false.",
        ejemplo: "let isActive = true;",
      },
      {
        tipoDeDato: "Undefined",
        descripci√≥n:
          "Indica que una variable ha sido declarada pero no inicializada.",
        ejemplo: "let result;",
      },
      {
        tipoDeDato: "Null",
        descripci√≥n: "Representa la ausencia intencional de un valor.",
        ejemplo: "let data = null;",
      },
      {
        tipoDeDato: "Symbol",
        descripci√≥n:
          "Representa un valor √∫nico e inmutable, a menudo usado como identificador √∫nico.",
        ejemplo: "let id = Symbol('id');",
      },
      {
        tipoDeDato: "Function",
        descripci√≥n:
          "Un tipo especial de objeto que se puede invocar para realizar una tarea.",
        ejemplo: 'function greet() { console.log("Hello World!"); }',
      },
      {
        tipoDeDato: "Object",
        descripci√≥n:
          "Representa una colecci√≥n de propiedades, donde cada propiedad tiene un nombre y un valor.",
        ejemplo: 'let user = {name: "Alice", age: 25};',
      },
      {
        tipoDeDato: "Array",
        descripci√≥n:
          "Un tipo especial de objeto que representa una lista ordenada de valores.",
        ejemplo: "let numbers = [1, 2, 3, 4, 5];",
      },
    ].map((item) => (
      <tr key={item.tipoDeDato}>
        <td>{item.tipoDeDato}</td>
        <td>{item.descripci√≥n}</td>
        <td>{item.ejemplo}</td>
      </tr>
    ))}
  </tbody>
</table>

### Importancia de los Tipos de Datos

Los diferentes tipos de datos en JavaScript permiten a los programadores realizar diversas operaciones y manipular datos de manera eficiente. Por ejemplo:

- **Operaciones matem√°ticas** son principalmente realizadas con el tipo Number.
- **Manipulaci√≥n de textos** se realiza con el tipo String, utilizando m√©todos como .toUpperCase(), .substring(), entre otros.
- **Control de flujo** se maneja a menudo con valores Boolean, permitiendo ejecutar diferentes secciones de c√≥digo basadas en condiciones verdaderas o falsas.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo simple para ilustrar c√≥mo se utilizan los tipos de datos en JavaScript:

```js copy filename="JavaScript"
// Declaraci√≥n de diferentes tipos de datos
let year = 2021; // Number
let welcomeMessage = "Hello, welcome to 2021!"; // String
let isLeapYear = false; // Boolean
let user = { name: "John Doe", age: 28 }; // Object

// Uso de tipos de datos
console.log(welcomeMessage); // Muestra el mensaje de bienvenida
if (!isLeapYear) {
  console.log(year, "is not a leap year."); // Eval√∫a la condici√≥n y muestra el mensaje
}

// Acceso a propiedad de objeto
console.log("User:", user.name, "Age:", user.age); // Muestra informaci√≥n del usuario
```

<Callout emoji="üëÄ" type="default">
  Entender y utilizar correctamente los tipos de datos en JavaScript es crucial
  para el desarrollo de aplicaciones robustas y mantenibles. Cada tipo de datos
  ofrece caracter√≠sticas y m√©todos espec√≠ficos que facilitan la implementaci√≥n
  de funcionalidades complejas en programas de cualquier escala. La selecci√≥n
  adecuada del tipo de datos no solo impacta en la claridad del c√≥digo sino
  tambi√©n en el rendimiento y la gesti√≥n de recursos dentro de la aplicaci√≥n.
</Callout>

### ¬øQu√© Tipo de Dato Tiene?

En JavaScript, es com√∫n necesitar identificar el tipo de dato de una variable, especialmente porque es un lenguaje de tipado din√°mico donde el tipo de una variable puede cambiar. Para realizar esta tarea, JavaScript proporciona dos herramientas principales: el operador typeof y la propiedad constructor.name. Estas herramientas ayudan a los desarrolladores a comprender y manejar los datos con los que trabajan de manera m√°s efectiva.

1. **Operador typeof**

El operador typeof es una herramienta r√°pida y f√°cil para identificar el tipo b√°sico de una variable. Es un operador unario, lo que significa que toma un solo operando y devuelve una cadena que describe el tipo de dato del valor. Aqu√≠ est√°n los posibles valores que typeof puede retornar:

- **"undefined"** ‚Äî para variables no definidas o no inicializadas.
- **"boolean"** ‚Äî para valores booleanos (true o false).
- **"number"** ‚Äî para n√∫meros, ya sean enteros o flotantes.
- **"bigint"** ‚Äî para n√∫meros enteros muy grandes que no pueden ser representados por el tipo number.
- **"string"** ‚Äî para cadenas de caracteres.
- **"symbol"** ‚Äî para valores del tipo Symbol.
- **"function"** ‚Äî para funciones.
- **"object"** ‚Äî para objetos, que incluyen objetos de tipo Array y null (debido a un error hist√≥rico en JavaScript, null se considera un objeto).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let name = "Alice";
console.log(typeof name); // "string"

let age = 30;
console.log(typeof age); // "number"

let isActive = true;
console.log(typeof isActive); // "boolean"

let user = null;
console.log(typeof user); // "object" ‚Äì Caso especial para null

let calculateAge = function () {
  return age;
};
console.log(typeof calculateAge); // "function"
```

2. **constructor.name**

Aunque typeof es √∫til para identificar tipos primitivos y distinguir entre funciones y objetos gen√©ricos, no proporciona detalles sobre el tipo espec√≠fico de objetos como instancias de clases personalizadas, arrays, o fechas. Para obtener el nombre del constructor que cre√≥ la instancia del objeto, podemos utilizar constructor.name.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let numbers = [1, 2, 3];
console.log(numbers.constructor.name); // "Array"

let today = new Date();
console.log(today.constructor.name); // "Date"

class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
let user = new User("Bob", 25);
console.log(user.constructor.name); // "User"
```

Es importante tener en cuenta que constructor.name puede no ser completamente fiable en entornos de producci√≥n donde el c√≥digo puede ser minificado o ofuscado, ya que los nombres de los constructores pueden ser alterados.

<Callout emoji="üëÄ" type="error">
  **OJO:** S√≥lo funciona en variables definidas (no undefined) y s√≥lo en o
  superiores.
</Callout>

### Referencia de una Variable

En JavaScript, la comprensi√≥n de c√≥mo las variables se asocian a valores primitivos y complejos es fundamental para entender c√≥mo se manejan los datos dentro del lenguaje. Este concepto es crucial para operar con eficiencia y precisi√≥n en el desarrollo de aplicaciones web.

1. **Valores Primitivos**

Los valores primitivos en JavaScript son datos que no poseen propiedades ni m√©todos. Estos incluyen tipos como number, string, boolean, undefined, null, symbol, y bigint. Una caracter√≠stica clave de los valores primitivos es que cuando asignas un valor primitivo a una variable, la variable accede directamente a ese valor. No hay una referencia o un objeto involucrado en este proceso. Esto se conoce como **asignaci√≥n por valor**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let x = 10;
let y = x;

// Modificar 'y' no afectar√° 'x'
y = 20;

console.log(x); // Muestra 10
console.log(y); // Muestra 20
```

En este ejemplo, x y y son completamente independientes entre s√≠ a pesar de que y fue inicialmente creada como una copia de x.

**Gr√°fico**

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    }
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso person esta apilado en nuestra lista, pero a su vez sus datos se almacenan en otra pila, a la cual acceder√° a esta, por su referencia.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },
    let newName = name;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName = Jhoswe",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso ahora tenemos una nueva variable llamada newName el cual tendr√° el valor que la variable name que en este caso es Jhoswe; Ojo que name sigue teniendo el valor de Jhoswe.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName=Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora nosotros cambiamos el valor de newName a Sau, pero el valor de name seguir√° siendo la misma de la original, es decir Jhoswe

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'

    let newPerson = person
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "newPerson",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "newName = Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora newPerson apunta a la misma referencia de person, por lo que si hay alg√∫n cambio dentro del objeto de person o newPerson, este cambio lo tendr√°n ambos.

2. **Valores Complejos**

Los valores complejos (tambi√©n conocidos como objetos) incluyen object, array, function, entre otros. A diferencia de los valores primitivos, cuando asignas un objeto a una variable, lo que se guarda en la variable es una referencia al objeto, no el objeto en s√≠. Esto significa que si tienes varias variables apuntando al mismo objeto y modificas el objeto a trav√©s de una de ellas, el cambio es visible a trav√©s de todas las variables que referencian ese objeto. Esto se conoce como **asignaci√≥n por referencia**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let obj1 = { value: 10 };
let obj2 = obj1;

// Modificar 'obj2' afecta 'obj1'
obj2.value = 20;

console.log(obj1.value); // Muestra 20
console.log(obj2.value); // Muestra 20
```

En este ejemplo, tanto obj1 como obj2 apuntan al mismo objeto en memoria. Cambiar una propiedad a trav√©s de obj2 altera el objeto al que tambi√©n apunta obj1.

**Importancia de Comprender Estas Diferencias**

Comprender la diferencia entre c√≥mo se manejan los valores primitivos y los complejos es esencial por varias razones:

- **Mutabilidad:**

En JavaScript, los tipos primitivos como number, string, boolean, null, undefined, symbol, y bigint son inmutables. Esto significa que los valores contenidos en estas variables no pueden ser alterados despu√©s de su creaci√≥n. Si necesitas modificar un valor primitivo, lo que realmente sucede es que se crea un nuevo valor primitivo y se asigna a la variable, mientras que el valor original permanece sin cambios.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let str = "Hello";
str = str + " World"; // Aqu√≠, "Hello World" es un nuevo string, no una modificaci√≥n del original.
```

**Objetos Mutables**

A diferencia de los primitivos, los objetos como Array, Object, y Function son mutables. Esto significa que sus contenidos o propiedades pueden ser cambiados despu√©s de ser creados. Si una variable almacena una referencia a un objeto, las modificaciones al contenido del objeto afectar√°n a todas las referencias a ese objeto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let array = [1, 2, 3];
array.push(4); // Modifica el array original a√±adiendo un elemento al final.
```

- **Gesti√≥n de Memoria:**

Cuando se declara una variable en JavaScript y se le asigna un valor, el lenguaje gestiona autom√°ticamente la memoria necesaria para almacenar ese valor. Para valores primitivos, la cantidad de memoria necesaria es fija y relativamente peque√±a, mientras que para objetos, la memoria requerida puede variar considerablemente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let num1 = 42; // Almacena 42 directamente en la memoria asignada a num1.
let obj1 = { value: 42 }; // Crea un objeto en la memoria, y obj1 almacena una referencia a √©l.
let obj2 = obj1; // obj2 no almacena otro objeto, sino una referencia al mismo objeto que obj1.
```

- **Rendimiento:**

El manejo de objetos y sus referencias puede tener implicaciones significativas en el rendimiento, especialmente en aplicaciones grandes y complejas.

- Asignaci√≥n y Copia: La asignaci√≥n de objetos y la copia de referencias son operaciones r√°pidas porque no implican duplicar el objeto subyacente. Sin embargo, la creaci√≥n de objetos nuevos puede ser costosa en t√©rminos de tiempo y memoria.
- Modificaci√≥n de Objetos: Modificar objetos es eficiente en cuanto a que no requiere la creaci√≥n de un nuevo objeto, pero si muchas referencias apuntan al mismo objeto, los cambios pueden tener efectos secundarios en partes no previstas del programa, lo que puede llevar a bugs o comportamientos inesperados.
- Garbage Collection: JavaScript utiliza un recolector de basura para liberar memoria que ya no es accesible. La gesti√≥n de muchos objetos y referencias puede complicar el proceso de recolecci√≥n de basura, potencialmente llevando a pausas o retrasos en la ejecuci√≥n del programa.

## Number

En JavaScript, los Number son uno de los tipos de datos b√°sicos (tipos primitivos) que se utilizan para representar valores num√©ricos, tanto enteros como fracciones decimales. Vamos a explorar en detalle c√≥mo funcionan y c√≥mo se manejan en este lenguaje.

**Declaraci√≥n de Variables Num√©ricas**

JavaScript permite la creaci√≥n de variables num√©ricas de manera sencilla y flexible. Existen dos formas principales de declarar n√∫meros: utilizando la notaci√≥n literal y el constructor Number. A continuaci√≥n, se presentan ambas t√©cnicas junto con ejemplos pr√°cticos para comprender su uso y diferencias.

- **Notaci√≥n Literal (Preferida)**

La notaci√≥n literal es la forma m√°s com√∫n y recomendada para declarar variables num√©ricas en JavaScript debido a su simplicidad y eficiencia. Para declarar un n√∫mero, simplemente se escribe el valor num√©rico directamente:

```js copy filename="JavaScript"
const numero = 4;
const decimal = 15.8;
const numeroLegible = 5_000_000;
```

**numero** es un n√∫mero entero.
**decimal** es un n√∫mero con parte decimal.
**numeroLegible** es un n√∫mero grande con guiones bajos para mejorar la legibilidad, introducido en ECMAScript 2021.

- **Notaci√≥n con Objetos (Evitar)**

Aunque es posible declarar n√∫meros utilizando el constructor Number, esta pr√°ctica es menos com√∫n y generalmente desaconsejada debido a su complejidad y posibles resultados inesperados. Al utilizar el constructor Number, se crean objetos en lugar de valores primitivos, lo cual puede llevar a comportamientos no deseados:

```js copy filename="JavaScript"
const numeroObjeto = new Number(4);
const decimalObjeto = new Number(15.8);
const letra = new Number("A");
```

**numeroObjeto y decimalObjeto** crean objetos Number.
**letra** intenta convertir la cadena "A" en un n√∫mero, resultando en NaN (Not A Number).

La notaci√≥n literal es preferida no solo por su claridad y simplicidad, sino tambi√©n porque evita la creaci√≥n innecesaria de objetos, lo que puede optimizar el rendimiento del c√≥digo.

**Manejo de Decimales y Separadores**

En JavaScript, los n√∫meros con decimales se representan utilizando un punto (.). Adem√°s, se puede usar el gui√≥n bajo (\_) como separador visual para hacer m√°s legibles los n√∫meros grandes.

```js copy filename="JavaScript"
const decimal = 123.45;
const numeroGrande = 1_000_000;

console.log(decimal); // 123.45
console.log(numeroGrande); // 1000000
```

El gui√≥n bajo no afecta el valor num√©rico, simplemente mejora la legibilidad.

**Notaci√≥n Cient√≠fica y Diferentes Bases Num√©ricas**

JavaScript permite representar n√∫meros en diferentes bases num√©ricas y en notaci√≥n cient√≠fica, lo cual es √∫til para trabajar con n√∫meros muy grandes o muy peque√±os.

```js copy filename="JavaScript"
// Notaci√≥n cient√≠fica
const grande = 1.23e5; // 123000
const peque√±o = 1.23e-5; // 0.0000123

// Diferentes bases num√©ricas
const decimal = 255; // Decimal
const hexadecimal = 0xff; // Hexadecimal
const octal = 0o377; // Octal
const binario = 0b11111111; // Binario

console.log(grande); // 123000
console.log(peque√±o); // 0.0000123
console.log(hexadecimal); // 255
console.log(octal); // 255
console.log(binario); // 255
```

### Rango Seguro de Enteros

En JavaScript, el manejo de n√∫meros es cr√≠tico, especialmente cuando se trata de grandes cantidades o c√°lculos precisos. La representaci√≥n est√°ndar de n√∫meros en JavaScript se hace mediante el formato de doble precisi√≥n de 64 bits IEEE 754, tambi√©n conocido como coma flotante de doble precisi√≥n. Este formato permite un amplio rango de valores, pero con limitaciones importantes en t√©rminos de precisi√≥n y rango seguro.

**Comprendiendo la Representaci√≥n en Coma Flotante**

Los n√∫meros en JavaScript, al almacenarse en formato de coma flotante, pueden no ser capaces de representar ciertos valores de manera exacta. Esto se debe a que el formato de coma flotante prioriza un amplio rango sobre la precisi√≥n absoluta en ciertos casos. Aunque puede manejar n√∫meros extremadamente grandes o peque√±os, el rango en el que los n√∫meros se pueden representar de manera segura sin perder precisi√≥n es mucho m√°s limitado.

**Constantes de Rango Seguro**

JavaScript define varias constantes para ayudar a los desarrolladores a entender los l√≠mites de la representaci√≥n num√©rica segura:

- **Number.MAX_SAFE_INTEGER:** El entero positivo m√°s grande que se puede representar de manera segura. Este valor es ${2^{53}-1}$, que es 9,007,199,254,740,991.
- **Number.MIN_SAFE_INTEGER:** El entero negativo m√°s grande (en valor absoluto) que se puede representar de manera segura. Este valor es ‚àí(${2^{53}-1}$).
- **Number.MAX_VALUE:** El valor m√°s grande que se puede representar en JavaScript, aproximadamente 1.79ùëí+308. No es recomendable para c√°lculos precisos ya que valores m√°s all√° del rango seguro pueden conducir a imprecisiones.
- **Number.MIN_VALUE:** El valor m√°s peque√±o que se puede representar en JavaScript, que es aproximadamente 5ùëí‚àí324. Es importante notar que este no es un negativo, sino el positivo m√°s peque√±o.

**Utilizando Number.EPSILON**

Number.EPSILON: Representa la diferencia m√°s peque√±a posible entre un n√∫mero en JavaScript y el siguiente n√∫mero representable m√°s grande, que es ${2^{-52}}$. Es √∫til para c√°lculos que necesitan una precisi√≥n extremadamente alta y para evaluar la igualdad de n√∫meros de punto flotante.

### Valores Infinitos

En JavaScript, existen dos constantes especiales para representar valores infinitos: Infinity y -Infinity. Estas constantes son √∫tiles cuando necesitas trabajar con valores extremadamente grandes o peque√±os, que no pueden ser representados de manera precisa dentro de los l√≠mites normales de los n√∫meros en JavaScript.

**Constantes de Infinito**

Las dos constantes que representan valores infinitos en JavaScript son:

- **Number.POSITIVE_INFINITY** o **simplemente Infinity:** Representa el infinito positivo (+‚àû).
- **Number.NEGATIVE_INFINITY** o **simplemente -Infinity:** Representa el infinito negativo (-‚àû).

```js copy filename="JavaScript"
console.log(Number.POSITIVE_INFINITY); // Output: Infinity
console.log(Number.NEGATIVE_INFINITY); // Output: -Infinity
```

Estas constantes se comportan de la manera esperada en operaciones aritm√©ticas:

- Cualquier n√∫mero positivo multiplicado por Infinity resulta en Infinity.
- Cualquier n√∫mero negativo multiplicado por Infinity resulta en -Infinity.
- Dividir un n√∫mero positivo por Infinity resulta en 0.
- Dividir un n√∫mero negativo por Infinity resulta en -0.

### Comprobaciones Num√©ricas

En JavaScript, es fundamental realizar comprobaciones num√©ricas para asegurarse de que los valores se manejan de manera correcta y segura. Estas comprobaciones permiten verificar la naturaleza de las variables num√©ricas, como si son finitas, enteras o seguras. JavaScript proporciona varios m√©todos est√°ticos del objeto Number para realizar estas verificaciones.

**Verificar si un Valor es Finito**

El m√©todo Number.isFinite(number) se utiliza para comprobar si un valor es un n√∫mero finito. Esta funci√≥n devuelve true si el valor es finito y false si es infinito o no es un n√∫mero.

```js copy filename="JavaScript"
console.log(Number.isFinite(42)); // true
console.log(Number.isFinite(551.3)); // true
console.log(Number.isFinite(Infinity)); // false
console.log(Number.isFinite(-Infinity)); // false
console.log(Number.isFinite(NaN)); // false
console.log(Number.isFinite("42")); // false
```

En este ejemplo, Number.isFinite(42) devuelve true porque 42 es un n√∫mero finito. Sin embargo, Number.isFinite(Infinity) devuelve false porque Infinity no es un n√∫mero finito.

**Verificar si un Valor es Entero**

El m√©todo Number.isInteger(number) verifica si un valor es un n√∫mero entero. Devuelve true si el valor es un entero y false si es un n√∫mero decimal o no es un n√∫mero.

```js copy filename="JavaScript"
console.log(Number.isInteger(5)); // true
console.log(Number.isInteger(4.6)); // false
console.log(Number.isInteger(NaN)); // false
console.log(Number.isInteger(Infinity)); // false
console.log(Number.isInteger("5")); // false
```

En este ejemplo, Number.isInteger(5) devuelve true porque 5 es un n√∫mero entero, mientras que Number.isInteger(4.6) devuelve false porque 4.6 es un n√∫mero decimal.

**Verificar si un Valor es un Entero Seguro**

El m√©todo Number.isSafeInteger(number) verifica si un valor es un entero seguro. Un entero seguro es un n√∫mero que se puede representar con precisi√≥n en JavaScript, sin riesgo de perder precisi√≥n debido al formato de coma flotante de 64 bits. El rango de enteros seguros est√° definido entre Number.MIN_SAFE_INTEGER y Number.MAX_SAFE_INTEGER.

```js copy filename="JavaScript"
console.log(Number.isSafeInteger(9007199254740991)); // true
console.log(Number.isSafeInteger(9007199254740992)); // false
console.log(Number.isSafeInteger(1e15)); // true
console.log(Number.isSafeInteger(1e16)); // false
console.log(Number.isSafeInteger(Infinity)); // false
console.log(Number.isSafeInteger("9007199254740991")); // false
```

En este ejemplo, Number.isSafeInteger(9007199254740991) devuelve true porque el valor est√° dentro del rango seguro, mientras que Number.isSafeInteger(9007199254740992) devuelve false porque excede el rango seguro.

**Comprobaci√≥n en Algoritmos**

En algoritmos que manejan grandes cantidades de datos num√©ricos, es crucial asegurarse de que todos los valores utilizados sean v√°lidos y seguros para evitar errores y resultados imprecisos.

```js copy filename="JavaScript"
function calcularSuma(numeros) {
  let suma = 0;
  for (const numero de numeros) {
    if (!Number.isFinite(numero)) {
      throw new Error("N√∫mero no finito en la lista.");
    }
    suma += numero;
  }
  if (!Number.isSafeInteger(suma)) {
    throw new Error("La suma resultante no es un n√∫mero seguro.");
  }
  return suma;
}

try {
  const numeros = [1000000000000000, 2000000000000000, 3000000000000000];
  const suma = calcularSuma(numeros);
  console.log("La suma es:", suma);
} catch (error) {
  console.error(error.message);
}
```

En este ejemplo, se verifica que todos los n√∫meros en la lista sean finitos antes de sumarlos, y se asegura de que la suma resultante sea un n√∫mero seguro.

**Comparaci√≥n de N√∫meros de Punto Flotante**

Al trabajar con n√∫meros de punto flotante, las comparaciones directas pueden no ser precisas debido a los errores de redondeo. Es mejor usar un margen de error para las comparaciones.

```js copy filename="JavaScript"
function compararFlotantes(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

const num1 = 0.1 + 0.2;
const num2 = 0.3;

if (compararFlotantes(num1, num2)) {
  console.log("Los n√∫meros son iguales.");
} else {
  console.log("Los n√∫meros no son iguales.");
}
```

En este ejemplo, se usa Number.EPSILON para comparar los n√∫meros de punto flotante con un margen de error muy peque√±o, asegurando una comparaci√≥n m√°s precisa.

### Representaci√≥n Num√©rica

En JavaScript, la representaci√≥n num√©rica es fundamental para manejar adecuadamente los diversos formatos en los que se pueden presentar o requerir los n√∫meros en aplicaciones web y de software. JavaScript ofrece varios m√©todos para manipular la presentaci√≥n de n√∫meros, permitiendo cambiar entre notaci√≥n exponencial y notaci√≥n de punto fijo, adem√°s de ajustar la precisi√≥n de los n√∫meros.

**Notaci√≥n Exponencial**

La notaci√≥n exponencial es √∫til para representar n√∫meros extremadamente grandes o peque√±os de manera concisa. En JavaScript, se puede convertir un n√∫mero a notaci√≥n exponencial usando el m√©todo .toExponential(digits), donde digits es el n√∫mero de decimales despu√©s del punto.

```js copy filename="JavaScript"
let numero = 123456;
console.log(numero.toExponential(1)); // "1.2e+5"
console.log(numero.toExponential(3)); // "1.235e+5"
```

Este m√©todo redondea el n√∫mero a la cantidad especificada de d√≠gitos decimales y lo muestra en formato exponencial.

**Notaci√≥n de Punto Fijo**

La notaci√≥n de punto fijo es otra forma de representar n√∫meros, especificando el n√∫mero de d√≠gitos que se deben mostrar despu√©s del punto decimal. Esto se realiza con el m√©todo .toFixed(digits), que tambi√©n redondea el n√∫mero a la cantidad especificada de decimales.

```js copy filename="JavaScript"
let numeroFijo = 1.23456;
console.log(numeroFijo.toFixed(1)); // "1.2"
console.log(numeroFijo.toFixed(3)); // "1.235"
```

**Ajuste de Precisi√≥n**

Para especificar el n√∫mero total de d√≠gitos significativos que debe tener un n√∫mero, se puede utilizar el m√©todo .toPrecision(size). Este m√©todo ajusta la cantidad total de d√≠gitos en un n√∫mero, combinando d√≠gitos enteros y decimales, y decide la mejor forma de mostrar el n√∫mero (punto fijo o exponencial) basado en el tama√±o especificado.

```js copy filename="JavaScript"
let numeroPrecision = 12345.6789;
console.log(numeroPrecision.toPrecision(3)); // "1.23e+4"
console.log(numeroPrecision.toPrecision(5)); // "12346"
console.log(numeroPrecision.toPrecision(7)); // "12345.68"
```

Estos m√©todos proporcionan una flexibilidad considerable en c√≥mo se presentan los n√∫meros, permitiendo ajustes precisos para la visualizaci√≥n y manejo de datos num√©ricos en JavaScript. Si necesitas m√°s recursos o informaci√≥n adicional para enriquecer esta secci√≥n, puedo buscar libros en PDF o textos acad√©micos que sean √∫tiles para expandir y mejorar nuestra explicaci√≥n.

### ¬øQu√© es NaN (Not A Number)?

NaN, acr√≥nimo de "Not A Number" (No es un N√∫mero), es un valor especial dentro del universo de JavaScript utilizado para indicar que un resultado num√©rico esperado no pudo ser obtenido. Aunque el nombre sugiere que no es un n√∫mero, t√©cnicamente, NaN pertenece al tipo de datos num√©rico en JavaScript. Este valor es √∫nico en comparaci√≥n con otros valores num√©ricos, ya que no es igual a ning√∫n otro valor, incluido s√≠ mismo.

**Propiedades de NaN**

- **Tipo de dato num√©rico:** A pesar de su nombre, el tipo de NaN es number. Esto puede resultar confuso, pero es esencial para operaciones que esperan un tipo num√©rico aunque el resultado no sea definido matem√°ticamente.

```js copy filename="JavaScript"
console.log(typeof NaN); // "number"
```

- **Comparaci√≥n √∫nica:** NaN no es comparable de forma directa con ning√∫n otro valor, incluso con otro NaN. Esto significa que NaN === NaN y NaN == NaN resultan en false. La √∫nica forma de verificar de manera fiable si un valor es NaN es mediante Number.isNaN() o la funci√≥n global isNaN().

```js copy filename="JavaScript"
console.log(NaN === NaN); // false
console.log(Number.isNaN(NaN)); // true
```

**Generaci√≥n de NaN**

NaN puede resultar de operaciones que no tienen un resultado num√©rico l√≥gico:

- **Indeterminaciones matem√°ticas:** Como dividir cero entre cero.
- **Operaciones inv√°lidas:** Como sumar una cadena de texto no num√©rica a un n√∫mero.
- **Funciones matem√°ticas fuera de dominio:** Como calcular la ra√≠z cuadrada de un n√∫mero negativo en los reales.

```js copy filename="JavaScript"
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // NaN
console.log("texto" * 2); // NaN
```

**M√©todos Relacionados con NaN**

- **Number.isNaN():** M√©todo est√°tico que proporciona una verificaci√≥n precisa de NaN sin forzar la conversi√≥n de tipo.

```js copy filename="JavaScript"
console.log(Number.isNaN("texto")); // false
console.log(Number.isNaN(NaN)); // true
```

- **isNaN():** Funci√≥n global que intenta convertir el argumento a n√∫mero y verifica si el resultado es NaN. Puede dar resultados inesperados si la conversi√≥n es exitosa pero no deseada.

```js copy filename="JavaScript"
console.log(isNaN("123ABC")); // true, "123ABC" convierte a NaN
```

**Tratamiento de NaN en Operaciones**

Cuando NaN participa en operaciones aritm√©ticas, el resultado tambi√©n ser√° NaN, propagando as√≠ el error a trav√©s de c√°lculos sucesivos si no se maneja adecuadamente.

```js copy filename="JavaScript"
console.log(NaN + 10); // NaN
console.log(NaN * 32); // NaN
```

**Uso Pr√°ctico de NaN**

- **Validaciones:** NaN es √∫til para validar y manejar entradas que se suponen num√©ricas pero que podr√≠an no serlo, especialmente en aplicaciones web donde las entradas del usuario son impredecibles.

```js copy filename="JavaScript"
function procesarEntrada(usuarioInput) {
  const numero = parseFloat(usuarioInput);
  if (Number.isNaN(numero)) {
    return "La entrada debe ser num√©rica.";
  }
  return numero * 10;
}

console.log(procesarEntrada("abc")); // "La entrada debe ser num√©rica."
console.log(procesarEntrada("10")); // 100
```

### Conversiones Num√©ricas en JavaScript

En JavaScript, convertir diferentes tipos de datos a n√∫meros es una operaci√≥n fundamental, especialmente dado que JavaScript es un lenguaje de tipado din√°mico donde las conversiones de tipos pueden no ser tan expl√≠citas. Entender c√≥mo manejar estas conversiones es crucial para realizar operaciones matem√°ticas correctamente y para procesar adecuadamente la entrada de datos.

**M√©todos para Convertir Texto a N√∫meros**

JavaScript ofrece varios m√©todos y funciones para convertir cadenas y otros tipos de datos a n√∫meros. Estos m√©todos incluyen:

1. **Number.parseInt()**

La funci√≥n parseInt() en JavaScript es una herramienta esencial para convertir cadenas de texto en n√∫meros enteros. Su utilidad se extiende especialmente en escenarios donde los datos no vienen tipificados, como es com√∫n en JavaScript, un lenguaje de tipado d√©bil. Esto hace que parseInt() sea indispensable para preparar datos para operaciones matem√°ticas, conversiones de base num√©rica, entre otras necesidades.

**Funcionamiento de parseInt**

parseInt() analiza una cadena y devuelve un entero en la base especificada o en base decimal por defecto. Si el primer car√°cter no puede ser convertido a un n√∫mero, devuelve NaN. Esto lo convierte en una herramienta poderosa y a la vez delicada que requiere atenci√≥n en su uso para evitar resultados inesperados.

**Sintaxis y Uso**

```js copy filename="JavaScript"
parseInt(string, base);
```

- **string:** Convierte string a un entero utilizando la base decimal.
- **string, base:** Convierte string a un entero utilizando la base especificada, donde base es el sistema num√©rico (de 2 a 36).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(parseInt("10")); // 10, interpretado como base 10
console.log(parseInt("10", 10)); // 10, expl√≠citamente en base 10
console.log(parseInt("10", 8)); // 8, interpretado como base 8
console.log(parseInt("10", 16)); // 16, interpretado como base 16
console.log(parseInt("1010", 2)); // 10, interpretado como binario
```

**Detalles de Implementaci√≥n**

- **Ignorar Caracteres No Num√©ricos:** parseInt() comienza a parsear desde el inicio de la cadena y contin√∫a hasta que encuentra un car√°cter que no es v√°lido en el sistema num√©rico especificado, en cuyo punto detiene el parseo y devuelve el n√∫mero parseado hasta ese momento.

```js copy filename="JavaScript"
console.log(parseInt("123abc")); // 123
console.log(parseInt("abc123")); // NaN, porque empieza con no num√©rico
console.log(parseInt("70 kg", 10)); // 70
```

- **Manejo de Decimales:** Si la cadena representa un n√∫mero decimal, parseInt() descartar√° cualquier fracci√≥n y devolver√° solo la parte entera.

```js copy filename="JavaScript"
console.log(parseInt("123.45")); // 123
console.log(parseInt("123.999")); // 123
console.log(parseInt("0.99")); // 0
```

**Aplicaciones Pr√°cticas de ParseInt()**

- **Extracci√≥n de N√∫meros de Cadenas en Formatos de Datos:** A menudo, especialmente en aplicaciones web, los datos num√©ricos vienen incorporados en cadenas con unidades o etiquetas, donde parseInt() puede ser utilizado para extraer el n√∫mero puro.

```js copy filename="JavaScript"
function extraerNumeroDeCadena(cadena) {
  return parseInt(cadena);
}

console.log(extraerNumeroDeCadena("200px")); // 200
console.log(extraerNumeroDeCadena("ID123")); // NaN, comienza con no num√©rico
```

- **Conversi√≥n de Bases Num√©ricas: parseInt()** es √∫til para convertir cadenas en diferentes bases a un n√∫mero decimal, lo que es esencial en computaci√≥n y electr√≥nica.

```js copy filename="JavaScript"
function convertirBase(cadena, base) {
  return parseInt(cadena, base);
}

console.log(convertirBase("ff", 16)); // 255
console.log(convertirBase("110", 2)); // 6
```

<Callout emoji="üëÄ" type="error">
  **OJO:** Estos ejemplos subrayan la flexibilidad y potencia de parseInt() para
  la conversi√≥n de cadenas a n√∫meros enteros en JavaScript. Es una herramienta
  vital para la manipulaci√≥n y preparaci√≥n de datos en un entorno no tipificado,
  permitiendo realizar operaciones num√©ricas y t√©cnicas efectivas con datos
  inicialmente representados como cadenas.
</Callout>

2. **Number.parseFloat()**

parseFloat() es una funci√≥n en JavaScript dise√±ada espec√≠ficamente para la conversi√≥n de cadenas a n√∫meros de punto flotante. A diferencia de parseInt(), que solo devuelve la parte entera de un n√∫mero, parseFloat() es capaz de mantener la precisi√≥n decimal, lo que es crucial para operaciones matem√°ticas que requieren exactitud en los decimales.

**Funcionamiento de parseFloat**

La funci√≥n parseFloat() analiza una cadena desde el principio hasta que encuentra un car√°cter que no se puede interpretar como parte de un n√∫mero. Si el primer car√°cter no puede ser convertido a un n√∫mero, la funci√≥n devuelve NaN.

**Sintaxis y Uso**

```js copy filename="JavaScript"
parseFloat(string);
```

**string:** Cadena de caracteres que se desea convertir a un n√∫mero de punto flotante.

**Caracter√≠sticas Principales de ParseFloat()**

1. **Retenci√≥n de Decimales:** A diferencia de parseInt(), parseFloat() interpreta y retiene cualquier parte decimal del n√∫mero, lo que la hace ideal para datos financieros, cient√≠ficos y cualquier otro uso donde los decimales son necesarios.

2. **Ignora Espacios Iniciales:** Los espacios blancos al inicio de la cadena son ignorados autom√°ticamente por parseFloat().

3. **Terminaci√≥n al Encontrar un Car√°cter no Num√©rico:** Si parseFloat() encuentra un car√°cter que no puede formar parte de un n√∫mero, detiene el an√°lisis y devuelve el n√∫mero formado hasta ese punto. Si no encuentra ning√∫n car√°cter num√©rico al inicio, devuelve NaN.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(parseFloat("10.50")); // 10.5
console.log(parseFloat("3.14159")); // 3.14159
console.log(parseFloat("0.0314E+2")); // 3.14
console.log(parseFloat("314e-2")); // 3.14
console.log(parseFloat("  123.45")); // 123.45
console.log(parseFloat("123.45kg")); // 123.45
console.log(parseFloat("abc123.45")); // NaN, comienza con caracteres no num√©ricos
```

**Conversi√≥n entre Bases Num√©ricas**

Las conversiones entre bases num√©ricas son fundamentales en muchas aplicaciones de programaci√≥n, desde criptograf√≠a hasta manejo de permisos en sistemas operativos. JavaScript facilita estas conversiones a trav√©s de m√©todos incorporados como parseInt() para conversiones a decimal y toString() para convertir desde decimal a otras bases.

1. **¬øQu√© es una Base Num√©rica?**

Una base num√©rica es el n√∫mero de d√≠gitos √∫nicos, incluyendo el cero, que un sistema num√©rico utiliza para representar n√∫meros. La m√°s familiar para nosotros es la base decimal (base 10), pero otros sistemas como el binario (base 2), el octal (base 8) y el hexadecimal (base 16) son esenciales en computaci√≥n.

- **Conversi√≥n de Otras Bases a Decimal:** Para convertir un n√∫mero de cualquier base a decimal, se utiliza parseInt(string, base), donde string es la representaci√≥n en cadena del n√∫mero y base es la base del n√∫mero original.

```js copy filename="JavaScript"
// Binario a Decimal
console.log(parseInt("11101", 2)); // 29

// Octal a Decimal
console.log(parseInt("31", 8)); // 25

// Hexadecimal a Decimal
console.log(parseInt("FF", 16)); // 255
```

- **Conversi√≥n desde Decimal a Otra Base:** Para convertir un n√∫mero decimal a otra base, se usa el m√©todo number.toString(base). El m√©todo toString() en JavaScript tiene dos prop√≥sitos principales:

  - **Conversi√≥n a Cadenas de Texto:** Objetos a Cadenas: Convierte cualquier objeto en una cadena de texto que representa ese objeto. Este es el uso gen√©rico del m√©todo toString() y es √∫til para generar representaciones legibles de objetos para la depuraci√≥n o visualizaci√≥n.

  - **Conversi√≥n de N√∫meros a Diferentes Bases:** N√∫meros a Cadenas en Diferentes Bases: Cuando se aplica a n√∫meros, toString(base) convierte el n√∫mero a una cadena que representa el n√∫mero en la base especificada (entre 2 y 36). Este uso es particularmente √∫til en programaci√≥n, criptograf√≠a, y otras √°reas que requieren trabajar con diferentes sistemas num√©ricos.

```js copy filename="JavaScript"
// Decimal a Binario
console.log((26).toString(2)); // "11010"

// Decimal a Octal
console.log((80).toString(8)); // "120"

// Decimal a Hexadecimal
console.log((245123).toString(16)); // "3bd83"
```

2. **Utilizaci√≥n de Prefijos en Literales Num√©ricos**

JavaScript tambi√©n soporta literales num√©ricos con prefijos que indican la base del n√∫mero, lo cual simplifica la conversi√≥n autom√°tica a decimal durante la ejecuci√≥n del c√≥digo.

```js copy filename="JavaScript"
// Binario con prefijo 0b
console.log(0b11101); // 29

// Octal con prefijo 0o
console.log(0o31); // 25

// Hexadecimal con prefijo 0x
console.log(0xff); // 255
```

**Aplicaciones Pr√°cticas**

1. **Validaci√≥n de Entradas**

Es com√∫n necesitar validar y convertir datos ingresados como cadenas a un formato num√©rico espec√≠fico para c√°lculos o l√≥gica de control.

```js copy filename="JavaScript"
function validarYConvertir(input, base) {
  let numero = parseInt(input, base);
  return isNaN(numero) ? "Entrada inv√°lida" : numero;
}

console.log(validarYConvertir("11101", 2)); // 29
console.log(validarYConvertir("XYZ", 16)); // 'Entrada inv√°lida'
```

2. **Formateo y Presentaci√≥n de Datos**

Convertir n√∫meros a diferentes bases puede ser √∫til para mostrar datos de manera que sean m√°s comprensibles o relevantes para una aplicaci√≥n espec√≠fica, como mostrar permisos de archivos en notaci√≥n octal o direcciones de memoria en hexadecimal.

```js copy filename="JavaScript"
function mostrarComoHexadecimal(numero) {
  return numero.toString(16);
}

console.log(mostrarComoHexadecimal(255)); // "ff"
```

<Callout emoji="üëÄ" type="error">
  **OJO:** Estas t√©cnicas subrayan c√≥mo JavaScript maneja la conversi√≥n de
  n√∫meros entre diversas bases num√©ricas, proporcionando flexibilidad y potencia
  para aplicaciones que necesitan manejar diferentes sistemas num√©ricos
</Callout>

### El objeto Math

El objeto Math de JavaScript proporciona una serie de propiedades y m√©todos que facilitan la realizaci√≥n de tareas matem√°ticas. Este objeto no es un constructor y todos sus m√©todos son est√°ticos, accesibles directamente desde el objeto Math.

**Constantes de Math**

El objeto Math incluye varias constantes matem√°ticas √∫tiles que pueden ser necesarias en diversas aplicaciones matem√°ticas:

- **Math.E:** El n√∫mero de Euler, la base de los logaritmos naturales, aproximadamente 2.718.
- **Math.PI:** El n√∫mero œÄ, aproximadamente 3.14159, √∫til en c√°lculos geom√©tricos y trigonom√©tricos.
- **Math.SQRT2:** La ra√≠z cuadrada de 2, aproximadamente 1.414, √∫til en c√°lculos de geometr√≠a.
- **Math.SQRT1_2:** La ra√≠z cuadrada de 1/2, aproximadamente 0.707, tambi√©n utilizada en c√°lculos geom√©tricos.

Estas constantes son esenciales para garantizar la precisi√≥n y facilitar el acceso a valores que de otro modo requerir√≠an c√°lculos complicados o tablas de b√∫squeda.

**M√©todos Matem√°ticos de Math**

Math proporciona una amplia gama de funciones que son fundamentales en casi todos los campos de la programaci√≥n que requieren matem√°ticas, desde simples c√°lculos hasta operaciones complejas:

1. **M√©todo Math.abs(x)**

El m√©todo Math.abs(x) en JavaScript es utilizado para obtener el valor absoluto de un n√∫mero, x. El valor absoluto de un n√∫mero es su valor sin considerar el signo. Por ejemplo, tanto para -5 como para 5, el valor absoluto es 5.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.abs(-10); // Retorna 10
Math.abs(5); // Retorna 5
```

Este m√©todo es especialmente √∫til en situaciones donde necesitas garantizar que est√°s trabajando con valores no negativos, como en c√°lculos de distancias o en algoritmos que requieren valores absolutos para su l√≥gica.

2. **M√©todo Math.sign(x)**

El m√©todo Math.sign(x) es usado para determinar el signo de un n√∫mero que puede ser positivo, negativo o cero. Este m√©todo retorna 1 para n√∫meros positivos, -1 para n√∫meros negativos, y 0 para el n√∫mero cero.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.sign(-20); // Retorna -1
Math.sign(20); // Retorna 1
Math.sign(0); // Retorna 0
```

Math.sign es √∫til para ajustar la l√≥gica de control en funciones y algoritmos donde el signo del n√∫mero afecta el flujo del proceso o el resultado final, como en m√©todos de ordenamiento o en simulaciones f√≠sicas.

3. **M√©todo Math.exp(x)**

Este m√©todo devuelve e elevado a la potencia de x, donde e es la base de los logaritmos naturales, aproximadamente igual a 2.71828. Este es un exponente constante utilizado en muchos c√°lculos en ciencias e ingenier√≠a. La funci√≥n es especialmente √∫til para c√°lculos en los que se necesita crecimiento exponencial o decaimiento, como modelar poblaciones o inter√©s compuesto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.exp(1)); // Aproximadamente 2.71828
console.log(Math.exp(0)); // 1
console.log(Math.exp(-1)); // Aproximadamente 0.36788
```

4. **M√©todo Math.expm1(x)**

Math.expm1(x) es una funci√≥n relacionada que calcula e elevado a la potencia de x, menos 1. Es decir, devuelve Math.exp(x) - 1. Esto es √∫til para c√°lculos que requieren alta precisi√≥n en rangos donde x es muy peque√±o. Cuando x es peque√±o, Math.exp(x) se acerca a 1 muy de cerca, y restar 1 de un n√∫mero cercano a 1 puede llevar a una p√©rdida significativa de precisi√≥n. Math.expm1(x) maneja esto de manera m√°s precisa.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.expm1(1)); // Aproximadamente 1.71828
console.log(Math.expm1(0)); // 0
console.log(Math.expm1(-1)); // Aproximadamente -0.63212
```

5. **M√©todo Math.max**

Este m√©todo devuelve el mayor de los argumentos que recibe. Si alguno de los argumentos no es un n√∫mero y no puede ser convertido en uno, devolver√° NaN.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.max(3, 1, 2); // Devuelve 3
Math.max(-10, -20, -30); // Devuelve -10
Math.max(0, 150, 30); // Devuelve 150
Math.max(); // Devuelve -Infinity
```

Este m√©todo es especialmente √∫til cuando necesitas asegurar que un valor no caiga por debajo de un cierto m√≠nimo o no exceda un cierto m√°ximo al comparar din√°micamente m√∫ltiples valores.

6. **M√©todo Math.min**

El m√©todo Math.min funciona de manera similar a Math.max pero devuelve el menor de los argumentos. Si no se proporcionan argumentos, devuelve Infinity, lo cual es √∫til para comparaciones cuando se inicializan variables en ciclos de optimizaci√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.min(3, 1, 2); // Devuelve 1
Math.min(-10, -20, -30); // Devuelve -30
Math.min(0, 150, 30); // Devuelve 0
Math.min(); // Devuelve Infinity
```

Estos m√©todos pueden ser extremadamente √∫tiles en muchos contextos de programaci√≥n, desde la optimizaci√≥n de rendimiento y la validaci√≥n de datos, hasta su uso en algoritmos matem√°ticos y estad√≠sticos.

Por ejemplo, si est√°s desarrollando una funci√≥n para encontrar el rango de valores en un conjunto de datos, puedes usar ambos m√©todos para determinar los l√≠mites superior e inferior del rango.

```js copy filename="JavaScript"
function calcularRango(valores) {
  return Math.max(...valores) - Math.min(...valores);
}

// Uso de la funci√≥n
console.log(calcularRango([3, 7, 9, 1])); // Devuelve 8
```

Este c√≥digo define una funci√≥n calcularRango que calcula la diferencia entre el valor m√°ximo y m√≠nimo de un array de n√∫meros, ilustrando una aplicaci√≥n pr√°ctica de Math.max y Math.min para resolver problemas espec√≠ficos en JavaScript.

7. **M√©todo Math.pow(base, exp)**

El m√©todo Math.pow(base, exp) es una funci√≥n incorporada en JavaScript que se utiliza para calcular una base elevada a la potencia de un exponente. Es fundamental en situaciones donde necesitas realizar c√°lculos de potenciaci√≥n r√°pidos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let resultadoPotencia = Math.pow(5, 3);
console.log(resultadoPotencia); // Imprime 125
```

Este ejemplo muestra c√≥mo elevar 5 a la potencia de 3. Este m√©todo es extremadamente √∫til en c√°lculos matem√°ticos que requieren exponenciaci√≥n, como en c√°lculos financieros, computaciones cient√≠ficas o incluso en algoritmos de gr√°ficos.

8. **M√©todo Math.sqrt(x)**

Por otro lado, Math.sqrt(x) calcula la ra√≠z cuadrada de un n√∫mero. Este m√©todo es esencial para operaciones que necesitan determinar la ra√≠z cuadrada de un n√∫mero, como en c√°lculos estad√≠sticos, resoluci√≥n de ecuaciones en f√≠sica, o en algoritmos de machine learning para calcular distancias euclidianas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let resultadoRaiz = Math.sqrt(144);
console.log(resultadoRaiz); // Imprime 12
```

Este ejemplo demuestra la obtenci√≥n de la ra√≠z cuadrada de 144, resultando en 12. Es una herramienta vital en √°reas donde la normalizaci√≥n o la estandarizaci√≥n de datos es requerida.

9. **M√©todo Math.cbrt(x)**

El m√©todo Math.cbrt(x) calcula la ra√≠z c√∫bica de un n√∫mero x. Este m√©todo es √∫til cuando necesitas determinar el valor de un n√∫mero elevado al cubo. Por ejemplo, si est√°s trabajando con vol√∫menes en un contexto geom√©trico o f√≠sico y conoces el volumen de un cubo, puedes usar Math.cbrt(x) para encontrar la longitud de los lados del cubo.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que est√°s calculando el tama√±o de un contenedor c√∫bico que tiene un volumen de 27 metros c√∫bicos. Podr√≠as usar Math.cbrt(27) para encontrar que cada lado del cubo mide 3 metros.

```js copy filename="JavaScript"
let volumen = 27;
let lado = Math.cbrt(volumen);
console.log(lado); // Output: 3
```

10. **M√©todo Math.imul(a, b)**

El m√©todo Math.imul(a, b) realiza una multiplicaci√≥n de 32 bits de dos argumentos, a y b. Este m√©todo es particularmente √∫til para ciertas operaciones de bajo nivel que requieren precisi√≥n en la manipulaci√≥n de enteros, como en gr√°ficos computacionales o algoritmos que dependen de operaciones aritm√©ticas exactas a nivel de bits.

<h4 className="font-medium mt-5">Ejemplo</h4>

Si est√°s desarrollando un juego y necesitas calcular posiciones de p√≠xeles o manipular datos gr√°ficos en el que cada operaci√≥n cuenta para el rendimiento, Math.imul() puede ser crucial para asegurar que las operaciones sean eficientes y precisas.

```js copy filename="JavaScript"
let factor1 = 65536;
let factor2 = 65536;
let resultado = Math.imul(factor1, factor2);
console.log(resultado); // Output depende de la arquitectura, posiblemente 0 debido a overflow
```

11. **M√©todo Math.clz32(x)**

El m√©todo Math.clz32() devuelve el n√∫mero de ceros a la izquierda en la representaci√≥n binaria de 32 bits de un n√∫mero. clz32 significa "count leading zero bits in 32-bit binary representation." Este m√©todo es √∫til para determinar la cantidad de ceros que preceden a la parte significativa de un n√∫mero. Es especialmente relevante en aplicaciones de bajo nivel que interact√∫an con datos binarios, donde la posici√≥n del primer bit significativo es importante.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.clz32(1)); // 31, porque en binario 1 es 000...0001, con 31 ceros delante
console.log(Math.clz32(1000)); // 22, porque en binario 1000 tiene 22 ceros al inicio
console.log(Math.clz32(0)); // 32, un caso especial, todos son ceros
```

**M√©todo Math.random()**

El m√©todo Math.random() es una herramienta esencial en JavaScript para generar n√∫meros pseudoaleatorios. Aqu√≠, te proporciono una exploraci√≥n detallada de c√≥mo funciona y algunos ejemplos pr√°cticos para utilizarlo eficazmente en diversos escenarios.

- **Caracter√≠sticas del M√©todo Math.random()**

Math.random() genera un n√∫mero flotante aleatorio en el rango de 0 (inclusive) hasta casi 1 (exclusivo), con hasta 16 decimales de precisi√≥n. Este comportamiento lo hace incre√≠blemente √∫til para todo tipo de aplicaciones de programaci√≥n que requieren elementos de aleatoriedad.

- **Generaci√≥n B√°sica de N√∫meros Aleatorios**

La funci√≥n Math.random() por s√≠ sola simplemente devuelve un n√∫mero entre 0 y 1. Esto es √∫til para simular probabilidades o para operaciones que requieren una selecci√≥n aleatoria dentro de un rango muy limitado.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let randomNumber = Math.random();
console.log(randomNumber);
```

- **Uso Avanzado: Generaci√≥n de N√∫meros Enteros Aleatorios**

Para utilizar Math.random() para generar un n√∫mero entero dentro de un rango espec√≠fico, se puede adaptar utilizando multiplicaciones y la funci√≥n Math.floor() para redondear hacia abajo al n√∫mero entero m√°s cercano.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let randomInt = Math.floor(Math.random() * 5);
console.log(randomInt);
```

- **Optimizaci√≥n de la Generaci√≥n de N√∫meros Aleatorios**

Para casos donde se necesita un redondeo m√°s eficiente sin la sobrecarga de Math.floor(), puedes utilizar el operador de doble negaci√≥n bitwise ~~, que es una forma r√°pida de descartar la parte decimal de un n√∫mero:

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let quickRandomInt = ~~(Math.random() * 5);
console.log(quickRandomInt);
```

Esta t√©cnica es especialmente √∫til en entornos de alto rendimiento donde cada milisegundo de ejecuci√≥n cuenta, como en juegos o aplicaciones gr√°ficas intensivas.

**M√©todos de logaritmos**

En JavaScript, el objeto Math proporciona m√©todos para c√°lculos matem√°ticos avanzados que incluyen varias funciones de logaritmos.

1. **Math.log(x)**

x. Este es un c√°lculo fundamental en muchos problemas matem√°ticos, especialmente en aquellos que involucran crecimiento exponencial o descomposici√≥n, como en finanzas para calcular intereses compuestos, en biolog√≠a para modelar crecimiento de poblaciones, o en f√≠sica para decaimiento radioactivo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Logaritmo natural de 10
console.log(Math.log(10)); // Aproximadamente 2.3026
```

2. **Math.log10(x)**

Por otro lado, Math.log10(x) calcula el logaritmo decimal (en base 10) de un n√∫mero ùë•. Este m√©todo es √∫til cuando necesitas determinar cu√°ntas veces tienes que multiplicar 10 para llegar a ùë•. Es com√∫n en ciencias para medir la acidez (pH), en ingenier√≠a para decibelios en medidas de sonido, o en astronom√≠a para escalas de magnitud estelar.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Logaritmo base 10 de 100
console.log(Math.log10(100)); // Exactamente 2
```

3. **Math.log2(x)**

El m√©todo Math.log2(x) calcula el logaritmo base 2 de un n√∫mero ùë•. Este c√°lculo es fundamental en campos como ciencias de la computaci√≥n y tecnolog√≠a de la informaci√≥n, donde los logaritmos base 2 se utilizan para determinar la eficiencia de algoritmos, especialmente aquellos que se dividen a la mitad progresivamente, como los algoritmos de b√∫squeda y ordenamiento.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que necesitas determinar el n√∫mero de niveles en una estructura de datos de √°rbol binario completo. Si tienes ùëõ elementos, el n√∫mero de niveles ùêø necesarios para almacenar estos elementos en un √°rbol binario es aproximadamente Math.log2(n) + 1.

```js copy filename="JavaScript"
function calcularNiveles(n) {
  return Math.ceil(Math.log2(n) + 1);
}
console.log(calcularNiveles(1024)); // Resultado: 11
```

4. **Math.log1p(x)**

Math.log1p(x) es particularmente √∫til para c√°lculos en los que
ùë• es muy peque√±o y los resultados de log(1+ùë•) pueden ser inexactos debido a la precisi√≥n de punto flotante. Este m√©todo es ampliamente utilizado en an√°lisis financiero, estad√≠sticas y ciencias de la salud para modelos que dependen de crecimiento logar√≠tmico o ajustes exponenciales.

<h4 className="font-medium mt-5">Ejemplo</h4>

En estad√≠sticas, Math.log1p(x) es crucial para transformar datos que incluyen valores cercanos a cero, lo cual es com√∫n en medidas de concentraciones qu√≠micas o biol√≥gicas en experimentos cient√≠ficos.

```js copy filename="JavaScript"
function transformarDatos(dato) {
  return Math.log1p(dato);
}
console.log(transformarDatos(0.000001)); // Resultado: un n√∫mero muy peque√±o cercano a 0.000001
```

**M√©todos de redondeo**

Como hemos visto anteriormente, es muy com√∫n necesitar m√©todos para redondear n√∫meros y reducir el n√∫mero de decimales o aproximar a una cifra concreta. Para ello, de forma nativa, Javascript proporciona los siguientes m√©todos de redondeo:

1. **Math.round(x)**

El m√©todo Math.round(x) se utiliza para redondear un n√∫mero al entero m√°s cercano. En el caso de n√∫meros que est√°n exactamente a mitad de camino entre dos enteros, sigue la regla del redondeo sim√©trico alejado de cero en la mayor√≠a de los casos, lo que significa que redondea al entero m√°s cercano con preferencia por un resultado positivo infinito en caso de empate.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que queremos redondear algunos valores para comprender c√≥mo funciona este m√©todo:

```js copy filename="JavaScript"
console.log(Math.round(0.9)); // Resultado: 1
console.log(Math.round(1.2)); // Resultado: 1
console.log(Math.round(1.5)); // Resultado: 2
console.log(Math.round(1.95)); // Resultado: 2
console.log(Math.round(-1.5)); // Resultado: -1
```

2. **Math.ceil(x)**

El m√©todo Math.ceil(x), por otro lado, siempre redondea un n√∫mero hacia arriba al pr√≥ximo entero mayor, independientemente de la fracci√≥n. Esto es especialmente √∫til en situaciones donde necesitamos asegurar que un n√∫mero sea redondeado hacia arriba para evitar subestimaciones en c√°lculos cr√≠ticos, como dimensionamientos y contabilizaciones.

<h4 className="font-medium mt-5">Ejemplo</h4>

Veamos c√≥mo Math.ceil(x) act√∫a sobre varios n√∫meros:

```js copy filename="JavaScript"
console.log(Math.ceil(0.1)); // Resultado: 1
console.log(Math.ceil(1.2)); // Resultado: 2
console.log(Math.ceil(1.5)); // Resultado: 2
console.log(Math.ceil(1.99)); // Resultado: 2
console.log(Math.ceil(-1.5)); // Resultado: -1
```

3. **Math.floor(x)**

El m√©todo Math.floor(x) redondea un n√∫mero x hacia abajo, es decir, al entero m√°s cercano menor que o igual a x. Este m√©todo es muy √∫til cuando necesitas eliminar cualquier fracci√≥n decimal de un n√∫mero, especialmente en c√°lculos que requieren valores enteros como √≠ndices de matriz, iteraciones de bucle, entre otros.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que est√°s implementando una funci√≥n que distribuye √≠tems en diferentes categor√≠as basadas en rangos de precios que aumentan en incrementos de 50. Usar Math.floor() puede ayudar a asignar un precio a la categor√≠a correcta:

```js copy filename="JavaScript"
function categorizarPrecio(precio) {
  return Math.floor(precio / 50);
}

console.log(categorizarPrecio(137)); // Imprime 2, correspondiente al rango de 100-149
console.log(categorizarPrecio(49)); // Imprime 0, correspondiente al rango 0-49
```

4. **Math.fround(x)**

El m√©todo Math.fround(x) devuelve la representaci√≥n flotante de precisi√≥n simple m√°s cercana de un n√∫mero x. Esto es √∫til en contextos donde la precisi√≥n de doble punto flotante no es necesaria o donde operaciones de precisi√≥n simple pueden ser m√°s r√°pidas dependiendo del hardware y el navegador.

<h4 className="font-medium mt-5">Ejemplo</h4>

En aplicaciones gr√°ficas o de simulaci√≥n, a veces la precisi√≥n de doble punto no es requerida, y el uso de Math.fround() puede optimizar el rendimiento:

```js copy filename="JavaScript"
function calcularDistancia(velocidad, tiempo) {
  return Math.fround(velocidad * tiempo);
}

console.log(calcularDistancia(0.1, 0.2)); // Resultado aproximado con precisi√≥n simple
```

5. **Math.trunc(x)**

Por otro lado, Math.trunc(x) simplemente elimina la parte decimal de un n√∫mero, sin importar si los decimales son mayores o menores que .5. Este m√©todo es esencial cuando simplemente deseas truncar un n√∫mero para obtener su parte entera, sin realizar ning√∫n tipo de redondeo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Truncando el n√∫mero
console.log(Math.trunc(3.95)); // Resultado: 3
console.log(Math.trunc(4.75)); // Resultado: 4
console.log(Math.trunc(-1.5)); // Resultado: -1
```

Aqu√≠, Math.trunc() elimina los decimales de cualquier n√∫mero proporcionado, lo que es especialmente notable en el caso de los n√∫meros negativos, donde simplemente se descarta la parte decimal.

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øQu√© valor tiene Number.MAX_VALUE en JavaScript?
</h4>

<p className="my-2">a) ${2^{1024}}$</p>
<p>b) El valor m√°s grande posible que JavaScript puede representar</p>
<p className="my-2">c) 1.7976931348623157√ó${10^{308}}$</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 1.7976931348623157√ó${10^{308}}$</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">2. ¬øQu√© devuelve parseInt("7*6", 10)?</h4>

<p className="my-2">a) 42</p>
<p>b) 7</p>
<p className="my-2">b) NaN</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 7</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øQu√© m√©todo se utilizar√≠a para convertir 123456789n a un n√∫mero regular,
  asumiendo que est√° dentro del rango seguro?
</h4>

<p className="my-2">a) BigInt.toNumber()</p>
<p>b) Number()</p>
<p className="my-2">c) No es posible convertir BigInt a Number</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Number()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">4. ¬øQu√© resultado produce Math.round(4.7)?</h4>

<p className="my-2">a) 4</p>
<p>b) 5</p>
<p className="my-2">c) 4.5</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 5</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l de las siguientes no es una representaci√≥n v√°lida de un n√∫mero en
  JavaScript?
</h4>

<p className="my-2">a) 0x1A</p>
<p>b) 2e10</p>
<p className="my-2">c) 000123</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 000123</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo generar√≠as un n√∫mero aleatorio entero entre 1 y 10?
</h4>

<p className="my-2">a) Math.floor(Math.random() * 10) + 1</p>
<p>b) Math.ceil(Math.random() * 10)</p>
<p className="my-2">c) Math.round(Math.random() * 10)</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Math.floor(Math.random() * 10) + 1</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">7. ¬øQu√© devuelve Math.log10(100)?</h4>

<p className="my-2">a) 10</p>
<p>b) 2</p>
<p className="my-2">c) 1</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 2</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øQu√© sucede cuando ejecutas Number.isNaN('NaN')?
</h4>

<p className="my-2">a) True</p>
<p>b) False</p>
<p className="my-2">c) TypeError</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) False</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øCu√°l de las siguientes es correcta para obtener la ra√≠z c√∫bica de 27 en
  JavaScript?
</h4>

<p className="my-2">a) Math.pow(27, 1/3)</p>
<p>b) Math.sqrt(27)</p>
<p className="my-2">c) Math.cbrt(27)</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Math.cbrt(27)</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© es Number.MAX_SAFE_INTEGER en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Es la constante que representa el m√°ximo valor entero seguro que JavaScript puede manejar sin perder precisi√≥n, equivalente a ${2^{53}-1}$

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øC√≥mo se puede convertir un string a un n√∫mero en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Se puede utilizar parseInt() para obtener una representaci√≥n entera, o parseFloat() para obtener un n√∫mero con decimales.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. Explica el resultado de 0.1 + 0.2 === 0.3 en JavaScript.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Esta expresi√≥n devuelve false debido a la imprecisi√≥n de la representaci√≥n de n√∫meros flotantes en JavaScript.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øQu√© m√©todo usar√≠as para obtener el valor absoluto de un n√∫mero en
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Se usar√≠a el m√©todo Math.abs().

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øC√≥mo generas un n√∫mero aleatorio entre 0 y 50 en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Utilizando Math.random() multiplicado por 50 y luego aplicando Math.floor() al resultado para obtener un entero.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øPara qu√© se utiliza el m√©todo Number.isNaN() y c√≥mo se diferencia de isNaN() global?

</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Number.isNaN() es m√°s estricto y solo devuelve true para el valor NaN. El isNaN() global convierte el argumento en un n√∫mero, lo que puede llevar a resultados verdaderos para valores no num√©ricos que se comportan como NaN tras la conversi√≥n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øCu√°l es la utilidad de Math.pow() y c√≥mo se podr√≠a replicar su
  funcionalidad con operadores en ES6 o superior?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Math.pow(a, b) eleva a a la potencia de b. En ES6, se puede replicar con el operador de exponenciaci√≥n **, como en a ** b.


    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. Explica la diferencia entre Math.floor() y Math.ceil().
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Math.floor() redondea hacia abajo, hacia el entero m√°s cercano, mientras que Math.ceil() redondea hacia arriba, hacia el entero m√°s cercano.

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Escribe un programa que calcule y muestre el √°rea de un c√≠rculo con un
  radio de 7 usando Math.PI.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const radio = 7;
        const area = Math.PI * radio ** 2;
        console.log(area);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Genera un n√∫mero aleatorio entre 50 y 100.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const aleatorio = Math.floor(Math.random() * 51) + 50;
        console.log(aleatorio);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  3. Redondea 6.25 a la unidad m√°s cercana usando Math.round().
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const redondeado = Math.round(6.25);
        console.log(redondeado);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Convierte "123.456" en un n√∫mero entero.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const numero = parseInt("123.456");
        console.log(numero);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  5. Verifica si 9007199254740991 es un entero seguro en JavaScript.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const esSeguro = Number.isSafeInteger(9007199254740991);
        console.log(esSeguro);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">6. Calcula el logaritmo base 10 de 1000.</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const log10 = Math.log10(1000);
        console.log(log10);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  7. Usa Math.ceil() para redondear 7.004 al entero m√°s alto.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const redondeoAlto = Math.ceil(7.004);
        console.log(redondeoAlto);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  8. Determina el m√°ximo y el m√≠nimo de los n√∫meros 4, 19, 8, 1 y 4 usando
  Math.max() y Math.min().
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const maximo = Math.max(4, 19, 8, 1, 4);
        const minimo = Math.min(4, 19, 8, 1, 4);
        console.log(`M√°ximo: ${maximo}, M√≠nimo: ${minimo}`);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## BigInt

BigInt es un tipo de dato en JavaScript dise√±ado para manejar n√∫meros enteros extremadamente grandes que sobrepasan los l√≠mites del tipo de dato Number. Con BigInt, puedes realizar operaciones matem√°ticas precisas con grandes enteros sin temor a perder precisi√≥n, lo cual es crucial en √°reas como la criptograf√≠a, la ciencia de datos y cualquier aplicaci√≥n que requiera manejar grandes n√∫meros.

**Caracter√≠sticas de BigInt**

- **Creaci√≥n:** Para crear un BigInt, puedes a√±adir n al final de un n√∫mero entero literal o usar el constructor BigInt() para convertir un Number o string a un BigInt.
- **Precisi√≥n:** BigInt permite representar y operar con n√∫meros enteros m√°s grandes que el l√≠mite de 2^53 - 1, que es el valor m√°ximo seguro que JavaScript puede representar con el tipo Number.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Crear un BigInt utilizando la notaci√≥n literal
let largeNumber = 1234567890123456789012345678901234567890n;

// Crear un BigInt a partir de un string
let fromString = BigInt("1234567890123456789012345678901234567890");

// Operaciones aritm√©ticas con BigInt
console.log(largeNumber + fromString); // Suma de BigInts
```

**Operaciones con BigInt**

Dado que BigInt es un tipo diferente, no puedes mezclar operaciones directamente entre BigInt y Number. Cualquier operaci√≥n matem√°tica debe realizarse entre valores del mismo tipo, es decir, o entre BigInts o entre Numbers.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const firstBigNumber = 9007199254740991n;
const secondBigNumber = 10n;

// Operaci√≥n v√°lida: sumando BigInts
console.log(firstBigNumber + secondBigNumber); // 9007199254741001n

// Operaci√≥n inv√°lida: sumando BigInt y Number
// console.log(firstBigNumber + 10);  // Error
```

### Mezcla de Tipos de Datos

En JavaScript, mezclar diferentes tipos de datos, especialmente BigInt y Number, puede ser complejo y requiere un entendimiento detallado para evitar errores y p√©rdida de precisi√≥n. A continuaci√≥n, se profundiza en c√≥mo manejar estos casos y las precauciones que se deben tomar.

**Conversiones y Operaciones entre BigInt y Number**

- **Operaciones Directas:** JavaScript no permite operaciones directas entre BigInt y Number sin una conversi√≥n expl√≠cita. Intentar realizar una operaci√≥n entre estos dos tipos sin convertir uno de ellos resultar√° en un error.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Intento de suma directa entre BigInt y Number
// const result = 5n + 5;  // Error: Cannot mix BigInt and other types
```

- **Conversiones Apropiadas:** Para realizar operaciones entre BigInt y Number, uno de los tipos debe ser convertido expl√≠citamente al otro. Sin embargo, cada conversi√≥n tiene implicaciones que deben ser consideradas cuidadosamente para evitar p√©rdida de datos o precisi√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Conversi√≥n de Number a BigInt y suma
const numberBigInt = BigInt(5) + 5n; // 10n, conversi√≥n segura si el Number es exacto

// Conversi√≥n de BigInt a Number y suma
const bigIntNumber = 5 + Number(5n); // 10, seguro mientras BigInt est√© dentro del rango seguro de Number
```

**Implicaciones de las Conversiones**

- **P√©rdida de Precisi√≥n:** Convertir BigInt a Number puede llevar a p√©rdida de precisi√≥n si el BigInt es mayor que el valor m√°ximo seguro que Number puede representar (Number.MAX_SAFE_INTEGER).

- **Errores en Tiempo de Ejecuci√≥n:** Convertir Number a BigInt puede ser problem√°tico si el Number ha perdido precisi√≥n debido a su tama√±o o c√°lculos previos.

**Comparaci√≥n de BigInt y Number**

- **Comparaci√≥n Estricta (===):** Devuelve false siempre que se comparen BigInt y Number, incluso si los valores num√©ricos son iguales, debido a la diferencia en tipos de datos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(5n === 5); // false, tipos diferentes
```

- **Comparaci√≥n de Igualdad (==):** Permite una conversi√≥n de tipos impl√≠cita y podr√≠a devolver true si los valores num√©ricos son iguales.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(5n == 5); // true, valor num√©rico igual
```

**Conversiones a String**

- **Conversi√≥n de BigInt a String:** Utilizar String() o .toString() sobre un BigInt elimina la n al final y proporciona una representaci√≥n en forma de cadena del n√∫mero.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(String(2n ** 53n)); // "9007199254740992"
console.log((2n ** 53n).toString()); // "9007199254740992"
```

### M√©todos de BigInt

BigInt en JavaScript ofrece capacidades √∫nicas para manejar n√∫meros extremadamente grandes, incluso m√°s all√° de los l√≠mites de los n√∫meros enteros normales. Entre sus herramientas, destacan los m√©todos .asIntN() y .asUintN(), que permiten manipular BigInts a nivel de bits con precisi√≥n controlada. Estos m√©todos son fundamentales cuando necesitamos implementar operaciones de bit a bit con un n√∫mero espec√≠fico de bits, asegurando as√≠ que el comportamiento en envolturas o truncamientos sea predecible y correcto.

**M√©todo .asIntN()**

El m√©todo .asIntN(bits, bigNumber) ajusta el n√∫mero bigNumber a una cantidad espec√≠fica de bits, interpretando el resultado como un entero con signo. Este m√©todo es crucial cuando trabajamos con sistemas que requieren una cantidad fija de bits y pueden tener valores negativos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Representaci√≥n de enteros con signo usando 2 bits
console.log(BigInt.asIntN(2, -3n)); // Resultado: representa incorrectamente -3 como 1n debido a la truncaci√≥n
console.log(BigInt.asIntN(2, -2n)); // Resultado: -2n (10 en binario)
console.log(BigInt.asIntN(2, 1n)); // Resultado: 1n (01 en binario)
console.log(BigInt.asIntN(2, 3n)); // Resultado: -1n (representa 3 incorrectamente como -1 debido a la envoltura)
```

**M√©todo .asUintN()**

Por otro lado, .asUintN(bits, bigNumber) tambi√©n ajusta bigNumber a bits especificados, pero lo interpreta como un entero sin signo. Este m√©todo es ideal para casos en los que todos los valores deben ser no negativos y es crucial evitar la interpretaci√≥n de signos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Representaci√≥n de enteros sin signo usando 2 bits
console.log(BigInt.asUintN(2, -1n)); // Resultado: 3n (interpreta -1 como 3, lo cual es incorrecto sin contexto adecuado)
console.log(BigInt.asUintN(2, 2n)); // Resultado: 2n (10 en binario)
console.log(BigInt.asUintN(2, 4n)); // Resultado: 0n (representa 4 como 0 debido a la envoltura)
```

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øQu√© m√©todo usar√≠as para convertir un BigInt a un tipo Number, asumiendo
  que el valor est√° dentro del rango seguro?
</h4>

<p className="my-2">a) A) Number.toBigInt()</p>
<p>b) BigInt.toNumber()</p>
<p className="my-2">c) Number()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Number()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© sucede si intentas sumar 10n y 5 directamente en JavaScript?
</h4>

<p className="my-2">a) Devuelve 15n</p>
<p>b) Lanza un TypeError</p>
<p className="my-2">b) Devuelve 15</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Lanza un TypeError</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øCu√°l es el resultado de comparar 10n === 10?
</h4>

<p className="my-2">a) true</p>
<p>b) false</p>
<p className="my-2">c) TypeError</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) false</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© representa BigInt en JavaScript y por qu√© es necesario?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      BigInt es un tipo de dato en JavaScript dise√±ado para manejar enteros muy grandes que superan el valor m√°ximo seguro de Number. Es necesario para realizar operaciones precisas con n√∫meros grandes, especialmente en contextos como la criptograf√≠a o el procesamiento de grandes vol√∫menes de datos.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øC√≥mo se crea un BigInt a partir de un n√∫mero literal?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Para crear un BigInt a partir de un n√∫mero literal, se a√±ade n al final del n√∫mero. Por ejemplo, 123n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øEs posible realizar operaciones mixtas entre BigInt y Number directamente?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      No, JavaScript no permite operaciones directas entre BigInt y Number debido a diferencias en su precisi√≥n y representaci√≥n. Las operaciones deben realizarse convirtiendo expl√≠citamente uno de los tipos al otro.

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Escribe un script que use BigInt para calcular ${2^{100}}$ sin perder precisi√≥n.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const result = 2n ** 100n;
        console.log(result);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Convierte el BigInt 123456789012345678901234567890n a un Number y verifica
  si la conversi√≥n es segura.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const bigIntValue = 123456789012345678901234567890n;
        if (bigIntValue <= BigInt(Number.MAX_SAFE_INTEGER)) {
            const numberValue = Number(bigIntValue);
            console.log(numberValue);
        } else {
            console.log("Conversi√≥n no segura");
        }
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  3. Realiza una operaci√≥n de suma entre dos BigInt y muestra el resultado.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const bigIntOne = 1000000000000000000000000n;
        const bigIntTwo = 2000000000000000000000000n;
        const sum = bigIntOne + bigIntTwo;
        console.log(sum);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## String

En programaci√≥n, un string es una secuencia de caracteres utilizada para representar texto. Los strings en JavaScript son un tipo de dato primitivo y se utilizan ampliamente para almacenar y manipular datos textuales. Un string puede contener letras, n√∫meros, s√≠mbolos y espacios, y se define utilizando comillas simples ('), comillas dobles ("), o backticks (`).

```js copy filename="JavaScript"
let stringSimple = "Hola, mundo";
let stringDoble = "Hola, mundo";
let stringBackticks = `Hola, mundo`;
```

**Declaraci√≥n de Variables de Tipo String**

JavaScript proporciona dos formas principales de crear variables de tipo string: utilizando la notaci√≥n literal y el constructor String. La notaci√≥n literal es la m√°s recomendada debido a su simplicidad y eficiencia. A continuaci√≥n, se detallan ambas t√©cnicas junto con ejemplos pr√°cticos.

- **Notaci√≥n Literal (Preferida)**

La notaci√≥n literal para strings en JavaScript es la forma m√°s com√∫n y preferida de declarar variables de texto. Simplemente se encierran los caracteres entre comillas simples ('), comillas dobles ("), o backticks (`).

```js copy filename="JavaScript"
const texto1 = "¬°Hola a todos!";
const texto2 = "Otro mensaje de texto";
const texto3 = `Este es un string con backticks`;
```

**texto1** y **texto2** son ejemplos de strings utilizando comillas simples y dobles, respectivamente.
**texto3** es un string utilizando backticks, permitiendo la interpolaci√≥n de variables y multilineas.

- **Notaci√≥n con Objetos (Evitar)**

Aunque es posible crear strings utilizando el constructor String, esta pr√°ctica es menos com√∫n y generalmente desaconsejada debido a su complejidad y posible confusi√≥n. Utilizar new String() crea un objeto en lugar de un valor primitivo, lo cual puede llevar a comportamientos inesperados.

```js copy filename="JavaScript"
const texto1 = new String("¬°Hola a todos!");
const texto2 = new String("Otro mensaje de texto");
```

En este ejemplo, **texto1** y **texto2** son objetos String, no valores primitivos, lo cual puede complicar comparaciones y otras operaciones.

**Caracter√≠sticas de los Strings**

- **Inmutabilidad:** Los strings en JavaScript son inmutables, lo que significa que una vez creados, no pueden ser modificados. Cualquier operaci√≥n que parezca modificar un string en realidad crea un nuevo string.

```js copy filename="JavaScript"
let original = "Hola";
let modificado = original + ", mundo";
console.log(original); // 'Hola'
console.log(modificado); // 'Hola, mundo'
```

- **Uso de Unicode:** JavaScript utiliza Unicode para representar caracteres, lo que permite incluir caracteres de casi todos los idiomas y muchos s√≠mbolos especiales.

**Escapando Caracteres en Strings**

Para incluir caracteres especiales dentro de un string, como comillas, saltos de l√≠nea o tabulaciones, se utilizan secuencias de escape con una barra invertida (\):

```js copy filename="JavaScript"
let comillasSimples = "It's a beautiful day";
let comillasDobles = 'He said, "Hello"';
let saltoLinea = "Primera l√≠nea\nSegunda l√≠nea";
let tabulacion = "Columna1\tColumna2";
console.log(comillasSimples); // "It's a beautiful day"
console.log(comillasDobles); // "He said, "Hello""
console.log(saltoLinea);
// Primera l√≠nea
// Segunda l√≠nea
console.log(tabulacion); // "Columna1  Columna2"
```

**Concatenaci√≥n de Strings**

Puedes unir (concatenar) dos o m√°s strings utilizando el operador + o el operador +=. Esto es √∫til para crear nuevos strings a partir de otros existentes:

```js copy filename="JavaScript"
let parte1 = "Hola";
let parte2 = "mundo";
let completo = parte1 + " " + parte2;
console.log(completo); // "Hola mundo"

parte1 += ", c√≥mo est√°s?";
console.log(parte1); // "Hola, c√≥mo est√°s?"
```

**Uso de Literales de Plantilla**

Las plantillas literales (template literals) son una caracter√≠stica de ES6 que permite crear strings complejos de manera m√°s legible y manejable. Usan backticks (`) en lugar de comillas y permiten la interpolaci√≥n de variables y expresiones mediante la sintaxis ${}:

```js copy filename="JavaScript"
let nombre = "Ana";
let edad = 25;
let presentacion = `Me llamo ${nombre} y tengo ${edad} a√±os.`;
console.log(presentacion); // "Me llamo Ana y tengo 25 a√±os."
```

**Interpolaci√≥n de Variables**

La interpolaci√≥n de variables en JavaScript es una t√©cnica introducida en ECMAScript 6 (ES6) que permite insertar variables y expresiones directamente dentro de un string, haciendo que el c√≥digo sea m√°s legible y f√°cil de escribir. Esta t√©cnica utiliza los template literals, que son delimitados por backticks (`) en lugar de comillas simples (') o dobles (").

1. **Template Literals**

Como vimos anteriormente a los template literals, estos tambi√©n permiten crear strings que incluyen variables y expresiones embebidas utilizando la sintaxis \$\{expresion}. Esta forma de crear strings ofrece varias ventajas:

- **Interpolaci√≥n de variables y expresiones:** Puedes insertar variables y resultados de expresiones directamente en el string.
- **Strings multil√≠nea:** Facilita la creaci√≥n de strings que abarcan m√∫ltiples l√≠neas sin necesidad de caracteres de escape.
- **Inclusi√≥n de comillas:** Permite usar comillas simples y dobles dentro del string sin necesidad de escaparlas.

2. **Interpolaci√≥n B√°sica de Variables**

Para insertar una variable en un template literal, se utiliza la sintaxis \$\{variable} dentro de los backticks. JavaScript evaluar√° la variable y la insertar√° en el string resultante.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let nombre = "Jhoswe";
let saludo = `Hola, ${nombre}!`;
console.log(saludo); // "Hola, Jhoswe!"
```

En este ejemplo, la variable nombre se inserta directamente en el string saludo.

3. **Interpolaci√≥n de Expresiones**

Adem√°s de variables, tambi√©n se pueden insertar expresiones dentro de los template literals. Las expresiones se evaluar√°n y el resultado se incluir√° en el string.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let a = 5;
let b = 10;
let suma = `${a} + ${b} = ${a + b}`;
console.log(suma); // "5 + 10 = 15"
```

En este ejemplo, las expresiones \$\{a}, \$\{b}, y \$\{a + b} se eval√∫an y sus resultados se incluyen en el string suma.

4. **Strings Multil√≠nea**

Los template literals facilitan la creaci√≥n de strings que abarcan m√∫ltiples l√≠neas sin necesidad de caracteres de escape como \n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let mensaje = `Querido Jhoswe,

Espero que est√©s bien. Este es un mensaje
multil√≠nea que se ve muy legible y claro.

Saludos,
Pepue`;
console.log(mensaje);
```

Este string multil√≠nea se define simplemente utilizando backticks y saltos de l√≠nea.

5. **Incluir Comillas dentro de Template Literals**

Los template literals permiten incluir comillas simples y dobles sin necesidad de escaparlas, lo cual facilita la construcci√≥n de strings con diferentes tipos de comillas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let frase = `Ella dijo, "JavaScript es genial" y yo estuve de acuerdo.`;
console.log(frase); // "Ella dijo, "JavaScript es genial" y yo estuve de acuerdo."
```

En este caso, las comillas dobles se incluyen directamente dentro del string delimitado por backticks.

6. **Usos Avanzados de Template Literals**

6.1. **Interpolaci√≥n en HTML:** Los template literals son ideales para crear plantillas de HTML din√°mico. Permiten insertar variables y expresiones directamente en el c√≥digo HTML, lo que facilita la creaci√≥n de contenido din√°mico.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let titulo = "Bienvenido";
let contenido = `<div>
    <h1>${titulo}</h1>
    <p>Este es un ejemplo de interpolaci√≥n de variables en HTML.</p>
</div>`;
document.body.innerHTML = contenido;
```

6.2. **Funciones y Template Literals:** Los template literals pueden ser utilizados dentro de funciones para crear contenido din√°mico basado en los argumentos de la funci√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function crearBoton(clase, texto) {
  return `<button class="${clase}">${texto}</button>`;
}

let botonPrimario = crearBoton("btn-primario", "Aceptar");
let botonAdvertencia = crearBoton("btn-advertencia", "Eliminar");
console.log(botonPrimario); // "<button class="btn-primario">Aceptar</button>"
console.log(botonAdvertencia); // "<button class="btn-advertencia">Eliminar</button>"
```

### Propiedades de un String

En JavaScript, los strings tienen varias propiedades importantes que permiten obtener informaci√≥n sobre el string y manipularlo de diversas maneras. A continuaci√≥n, exploramos estas propiedades en detalle.

1. **Propiedad length**

La propiedad length es la m√°s utilizada y la √∫nica propiedad fundamentalmente importante de un string. Devuelve el n√∫mero de caracteres en el string, incluyendo espacios, signos de puntuaci√≥n y caracteres especiales.

**Caracter√≠sticas de la propiedad length**

- Es de solo lectura: no puedes modificar la longitud de un string directamente a trav√©s de esta propiedad.
- Devuelve un valor num√©rico que representa el total de caracteres en el string.
- Se puede acceder a ella directamente desde cualquier string sin necesidad de guardarlo en una variable.

```js copy filename="JavaScript"
let str = "java script language";
console.log(str.length); // 20
```

<div className="flex justify-center my-5">
  <Image
    src="/assets/img/length.png"
    alt="Elemento en HTML"
    width={750}
    height={750}
  />
</div>

2. **Propiedad constructor**

La propiedad constructor devuelve una referencia a la funci√≥n que cre√≥ la instancia del objeto String. En JavaScript, todas las instancias de string son creadas por la funci√≥n String.

**Caracter√≠sticas de la propiedad constructor**

- Es √∫til para verificar el tipo de un objeto.
- Permite crear nuevas instancias de objetos String.
- Se hereda de Object.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo.constructor); // function String() { [native code] }
```

3. **Propiedad prototype**

La propiedad prototype permite agregar nuevas propiedades y m√©todos a todos los objetos String. Esto es √∫til cuando se desea extender la funcionalidad de los strings en todas las instancias.

**Caracter√≠sticas de la propiedad prototype**

- Permite extender la funcionalidad de los strings.
- Los m√©todos y propiedades a√±adidos a String.prototype estar√°n disponibles para todas las instancias de string.
- Es una caracter√≠stica poderosa para personalizar y ampliar las capacidades de los strings.

```js copy filename="JavaScript"
String.prototype.despedir = function () {
  return "Adi√≥s, " + this;
};
```

4. **Propiedad \_\_proto\_\_**

La propiedad **proto** es una referencia al prototipo del objeto, del cual hereda propiedades y m√©todos. Aunque es accesible, no es recomendable modificar **proto** directamente. En su lugar, se deben utilizar m√©todos como Object.getPrototypeOf() y Object.setPrototypeOf().

**Caracter√≠sticas de la propiedad \_\_proto\_\_**

- Permite acceder al prototipo del objeto.
- Se utiliza principalmente para inspecci√≥n y depuraci√≥n.
- Modificar **proto** directamente no es una pr√°ctica recomendada debido a posibles problemas de rendimiento y mantenimiento del c√≥digo.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo.__proto__ === String.prototype); // true
```

**Acceso a un Car√°cter**

En JavaScript, los strings son secuencias de caracteres, y a menudo es necesario acceder a un car√°cter espec√≠fico dentro de un string. Existen varias formas de lograr esto, cada una con sus propias caracter√≠sticas y usos. A continuaci√≥n, se detallan los m√©todos m√°s comunes para acceder a un car√°cter en un string.

**Acceso mediante √çndices**

Los strings en JavaScript se comportan como arrays de caracteres, lo que permite acceder a un car√°cter espec√≠fico utilizando la notaci√≥n de corchetes ([]) con un √≠ndice. Los √≠ndices en JavaScript comienzan en 0, por lo que el primer car√°cter de un string tiene el √≠ndice 0, el segundo el √≠ndice 1, y as√≠ sucesivamente.

**Caracter√≠sticas de este m√©todo**

- **Acceso Directo:** Permite acceder directamente a cualquier car√°cter dentro del string utilizando su posici√≥n.
- **Inmutabilidad:** Aunque puedes acceder a caracteres individuales, no puedes modificar un car√°cter directamente utilizando esta notaci√≥n debido a que los strings en JavaScript son inmutables.
- **√çndice fuera de rango:** Si intentas acceder a un √≠ndice que no existe, no se lanzar√° un error, pero obtendr√°s undefined.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo[0]); // "H"
console.log(saludo[7]); // "u"
console.log(saludo[10]); // "o"
console.log(saludo[20]); // undefined
```

### Posiciones y substrings

Antes de profundizar en los m√©todos, es importante entender dos conceptos clave:

1. **Substring:** Un substring es una subcadena de texto, es decir, una secuencia de caracteres que forma parte de un string m√°s grande. Por ejemplo, en el string "Hola amigos", la subcadena "amigos" es un substring.

2. **Posici√≥n o √çndice:** La posici√≥n o √≠ndice es un n√∫mero que representa el lugar donde se encuentra un car√°cter en el string, comenzando desde 0. Por ejemplo, en el string "Hola amigos", el car√°cter 'a' en "amigos" est√° en la posici√≥n 5.

```js copy filename="JavaScript"
"Hola amigos";
0123456789;
```

**Obtener la Posici√≥n o √çndice de un Car√°cter**

Para encontrar la posici√≥n o √≠ndice de un car√°cter dentro de un string, JavaScript ofrece varios m√©todos.

1. **Car√°cter en cierta posici√≥n**

**M√©todo .charAt(pos)**

El m√©todo .charAt(pos) devuelve el car√°cter en la posici√≥n especificada dentro de un string. Es √∫til para acceder a caracteres individuales, especialmente en versiones antiguas de JavaScript donde la notaci√≥n de corchetes ([]) no es compatible.

- **Sintaxis**

```js copy filename="JavaScript"
string.charAt(pos);
```

**pos:** La posici√≥n (√≠ndice) del car√°cter que se desea obtener. El √≠ndice comienza en 0.

- **Caracter√≠sticas del M√©todo .charAt(pos)**

  - **Compatibilidad:** Es compatible con versiones m√°s antiguas de JavaScript.
  - **Valor de retorno:** Devuelve una cadena de longitud 1 (un solo car√°cter) que se encuentra en la posici√≥n especificada.
  - **√çndice fuera de rango:** Si el √≠ndice est√° fuera del rango del string, devuelve una cadena vac√≠a ("").

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let str = "java script language";
console.log(texto.charAt(0)); // "j"
console.log(texto.charAt(4)); // " "
console.log(texto.charAt(9)); // "p"
console.log(texto.charAt(10)); // "t"
```

En este ejemplo, charAt se usa para obtener los caracteres en las posiciones 0, 4 y 9 del string "JavaScript". Tambi√©n muestra c√≥mo se comporta cuando el √≠ndice est√° fuera del rango del string, devolviendo una cadena vac√≠a.

<div className="flex justify-center my-5">
  <Image
    src="/assets/img/charAt.png"
    alt="Elemento en HTML"
    width={750}
    height={750}
  />
</div>

2. **Posici√≥n de cierto car√°cter**

En JavaScript, localizar la posici√≥n de un car√°cter o subcadena espec√≠fica dentro de un string es una tarea com√∫n. Los m√©todos .indexOf(text) y .indexOf(text, from) son herramientas esenciales para realizar estas b√∫squedas. A continuaci√≥n, explicaremos en detalle c√≥mo funcionan estos m√©todos y c√≥mo utilizarlos de manera efectiva.

**M√©todo .indexOf(text)**

El m√©todo .indexOf(text) busca la primera aparici√≥n de una subcadena dentro de un string y devuelve el √≠ndice correspondiente. Si no se encuentra la subcadena, devuelve -1. Este m√©todo es √∫til cuando necesitas saber si una subcadena espec√≠fica est√° presente en un string y, de ser as√≠, en qu√© posici√≥n se encuentra.

- **Sintaxis**

```js copy filename="JavaScript"
string.indexOf(searchValue);
```

**searchValue:** La subcadena que se desea buscar dentro del string.

- **Caracter√≠sticas de .indexOf(text)**

  - **Devuelve el √≠ndice:** El √≠ndice de la primera aparici√≥n del searchValue en el string.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial";
let posicion = texto.indexOf("Script"); // 4
console.log(posicion); // 4

let noEncontrado = texto.indexOf("script"); // -1 (debido a la sensibilidad a may√∫sculas y min√∫sculas)
console.log(noEncontrado); // -1
```

En este ejemplo, indexOf busca la subcadena "Script" dentro del string "JavaScript es genial", devolviendo el √≠ndice 4. Si se busca "script" (en min√∫sculas), se devuelve -1 porque la b√∫squeda es sensible a may√∫sculas y min√∫sculas.

**M√©todo .indexOf(text, from)**

El m√©todo .indexOf(text, from) es una extensi√≥n de .indexOf(text) que permite especificar un √≠ndice desde el cual comenzar la b√∫squeda. Esto es √∫til cuando necesitas buscar la subcadena a partir de una posici√≥n espec√≠fica dentro del string, proporcionando mayor control y flexibilidad.

- **Sintaxis**

```js copy filename="JavaScript"
string.indexOf(searchValue, fromIndex);
```

**searchValue:** La subcadena que se desea buscar dentro del string.
**fromIndex:** La posici√≥n desde la cual se desea comenzar la b√∫squeda. El valor por defecto es 0.

- **Caracter√≠sticas de .indexOf(text, from)**

- **Devuelve el √≠ndice:** El √≠ndice de la primera aparici√≥n del searchValue en el string, comenzando desde fromIndex.
- **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
- **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.
- **Permite especificar el punto de inicio:** La b√∫squeda comienza desde el √≠ndice fromIndex, proporcionando mayor flexibilidad.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let primeraPosicion = texto.indexOf("JavaScript"); // 0
console.log(primeraPosicion); // 0

let segundaPosicion = texto.indexOf("JavaScript", 15); // 22
console.log(segundaPosicion); // 22
```

En este ejemplo, indexOf busca la subcadena "JavaScript" dentro del string "JavaScript es genial. JavaScript es vers√°til.". La primera b√∫squeda comienza desde el inicio del string, devolviendo el √≠ndice 0. La segunda b√∫squeda comienza desde el √≠ndice 15, devolviendo el √≠ndice 23.

3. **Posici√≥n desde el Final**

En JavaScript, los m√©todos .lastIndexOf(text) y .lastIndexOf(text, from) se utilizan para buscar la √∫ltima aparici√≥n de un car√°cter o subcadena dentro de un string, comenzando la b√∫squeda desde el final del string. Estos m√©todos son √∫tiles para encontrar la posici√≥n de la √∫ltima ocurrencia de un car√°cter o subcadena espec√≠fica, lo que puede ser esencial en muchas operaciones de manipulaci√≥n de texto.

**M√©todo .lastIndexOf(text)**

El m√©todo .lastIndexOf(text) busca la √∫ltima aparici√≥n de una subcadena dentro de un string y devuelve el √≠ndice correspondiente. Si no se encuentra la subcadena, devuelve -1. Este m√©todo es particularmente √∫til cuando necesitas encontrar la posici√≥n de la √∫ltima ocurrencia de una subcadena espec√≠fica en un string.

- **Sintaxis**

```js copy filename="JavaScript"
string.lastIndexOf(searchValue);
```

**searchValue:** La subcadena que se desea buscar dentro del string.

- **Caracter√≠sticas de .lastIndexOf(text)**

  - **Devuelve el √≠ndice:** El √≠ndice de la √∫ltima aparici√≥n del searchValue en el string.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let ultimaPosicion = texto.lastIndexOf("JavaScript");
console.log(ultimaPosicion); // 22

let noEncontrado = texto.lastIndexOf("script");
console.log(noEncontrado); // -1
```

En este ejemplo, lastIndexOf busca la subcadena "JavaScript" dentro del string "JavaScript es genial. JavaScript es vers√°til.", devolviendo el √≠ndice 23. Si se busca "script" (en min√∫sculas), se devuelve -1 porque la b√∫squeda es sensible a may√∫sculas y min√∫sculas.

**M√©todo .lastIndexOf(text, from)**

El m√©todo .lastIndexOf(text, from) permite especificar un √≠ndice desde el cual comenzar la b√∫squeda hacia atr√°s. Esto proporciona mayor control y flexibilidad, permitiendo encontrar la √∫ltima aparici√≥n de una subcadena comenzando desde una posici√≥n espec√≠fica dentro del string.

- **Sintaxis**

```js copy filename="JavaScript"
string.lastIndexOf(searchValue, fromIndex);
```

**searchValue:** La subcadena que se desea buscar dentro del string.
**fromIndex:** La posici√≥n desde la cual se desea comenzar la b√∫squeda hacia atr√°s. El valor por defecto es la longitud del string menos uno.

- **Caracter√≠sticas de .lastIndexOf(text, from)**

  - **Devuelve el √≠ndice:** El √≠ndice de la √∫ltima aparici√≥n del searchValue en el string, comenzando desde fromIndex.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.
  - **Permite especificar el punto de inicio:** La b√∫squeda comienza desde el √≠ndice fromIndex hacia atr√°s, proporcionando mayor flexibilidad.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let ultimaPosicionDesde = texto.lastIndexOf("es", 11);
console.log(ultimaPosicionDesde); // 11

let ultimaPosicionCompleta = texto.lastIndexOf("es", texto.length - 1);
console.log(ultimaPosicionCompleta); // 33
```

An√°lisis del Ejemplo 1:

String: "JavaScript es genial. JavaScript es vers√°til."
Subcadena Buscada (text): "es"
Punto de Inicio (from): 11
En este ejemplo, el m√©todo .lastIndexOf("es", 11) busca la subcadena "es" empezando desde el √≠ndice 11 y movi√©ndose hacia atr√°s (hacia el inicio del string).

La b√∫squeda comienza desde el √≠ndice 11 y encuentra "es" justo en esa posici√≥n, que es parte de la palabra "es" en la frase "JavaScript es genial."
Por lo tanto, el m√©todo devuelve 11, que es el √≠ndice donde comienza la subcadena "es" encontrada al realizar la b√∫squeda hacia atr√°s desde el √≠ndice 11.

An√°lisis del Ejemplo 2:

String: "JavaScript es genial. JavaScript es vers√°til."
Subcadena Buscada (text): "es"
Punto de Inicio (from): texto.length - 1 (que es 43 - 1 = 42)
En este caso, el m√©todo .lastIndexOf("es", 42) inicia la b√∫squeda de la subcadena "es" desde el √≠ndice 42, que es el √∫ltimo √≠ndice del string.

La b√∫squeda se realiza hacia atr√°s desde el final del string.
Encuentra la subcadena "es" en la parte "es" de la palabra "vers√°til" hacia el final del string.
El √≠ndice donde comienza esta subcadena es 33, que es el resultado devuelto por el m√©todo.

**Obtener Fragmentos (Substrings)**

Javascript tambi√©n posee una serie de m√©todos mediante los cuales podemos crear substrings formados por un fragmento del original.

1. **Repetir cadena de texto**

**M√©todo .repeat(num)**

El m√©todo .repeat(num) devuelve un nuevo string que contiene la concatenaci√≥n del string original repetido num veces. Este m√©todo es √∫til para generar patrones repetitivos, crear rellenos o simplemente repetir contenido.

- **Sintaxis**

```js copy filename="JavaScript"
string.repeat(count);
```

**count:** Un n√∫mero entero que indica cu√°ntas veces se repetir√° el string. Debe ser un valor mayor o igual a 0.

- **Caracter√≠sticas de .repeat(num)**

  - **Devuelve un nuevo string:** El string original se repite count veces, y el resultado es un nuevo string.
  - **Par√°metro count:** Debe ser un n√∫mero entero. Si es un n√∫mero decimal, se redondear√° hacia abajo.
  - **Valor count negativo o infinito:** Lanza un RangeError.
  - **Valor count igual a 0:** Devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let saludo = "Hola";
let repetido = saludo.repeat(3);
console.log(repetido); // "HolaHolaHola"

let relleno = "*".repeat(5);
console.log(relleno); // "*****"

let vacio = "JavaScript".repeat(0);
console.log(vacio); // ""
```

En este ejemplo, el m√©todo repeat se utiliza para repetir el string "Hola" tres veces, creando el string "HolaHolaHola". Tambi√©n se usa para generar un relleno de asteriscos y para demostrar que repetir un string 0 veces resulta en una cadena vac√≠a.

2. **Fragmento de texto (substring)**

**M√©todo .substring(start, end)**

El m√©todo .substring(start, end) se utiliza para extraer partes de un string. Devuelve una nueva cadena que contiene los caracteres desde el √≠ndice start hasta, pero sin incluir, el √≠ndice end. Si end se omite, extrae hasta el final del string.

- **Sintaxis**

```js copy filename="JavaScript"
string.substring(start, end);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena.
**end (opcional):** El √≠ndice del primer car√°cter que no se incluir√° en la subcadena. Si se omite, substring extraer√° caracteres desde start hasta el final del string.

- **Caracter√≠sticas**

  - **Indices positivos:** Ambos √≠ndices deben ser n√∫meros no negativos.
  - **Intercambio de √≠ndices:** Si start es mayor que end, los valores se intercambian.
  - **Ajuste de l√≠mites:** Los valores fuera del rango del string se ajustan al inicio o al final del string.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.substring(3); // "marino"
let subcadena2 = texto.substring(3, 5); // "ma"
let subcadena3 = texto.substring(5, 3); // "ma" (intercambio de √≠ndices)
console.log(subcadena1); // "marino"
console.log(subcadena2); // "ma"
console.log(subcadena3); // "ma"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.substring(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer entre dos √≠ndices:** En el ejemplo texto.substring(3, 5), se extraen los caracteres desde el √≠ndice 3 hasta el 5, sin incluir el car√°cter en el √≠ndice 5.

**Intercambio de √≠ndices:** En el ejemplo texto.substring(5, 3), como el primer √≠ndice es mayor que el segundo, el m√©todo intercambia los valores y extrae los caracteres desde el √≠ndice 3 hasta el 5.

**M√©todo .substr(start, size)**

El m√©todo .substr(start, size) devuelve una nueva cadena de texto que contiene los caracteres de la cadena original comenzando desde el √≠ndice start y extendi√©ndose por size caracteres.

- **Sintaxis**

```js copy filename="JavaScript"
string.substr(start, size);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena. Puede ser negativo para contar desde el final del string.
**size (opcional):** El n√∫mero de caracteres que se incluir√°n en la subcadena. Si se omite, substr extraer√° caracteres desde start hasta el final del string.

- **Caracter√≠sticas**

  - **Inicio negativo:** Si start es negativo, la posici√≥n se cuenta desde el final del string.
  - **Longitud positiva:** size debe ser un n√∫mero positivo. Si es 0 o negativo, se devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.substr(3); // "marino"
let subcadena2 = texto.substr(3, 5); // "marin"
let subcadena3 = texto.substr(-3); // "ino"
let subcadena4 = texto.substr(-3, 2); // "in"
console.log(subcadena1); // "marino"
console.log(subcadena2); // "marin"
console.log(subcadena3); // "ino"
console.log(subcadena4); // "in"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.substr(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer una cantidad espec√≠fica de caracteres:** En el ejemplo texto.substr(3, 5), se extraen 5 caracteres comenzando desde el √≠ndice 3.

**Inicio negativo:** En el ejemplo texto.substr(-3), se extraen los caracteres desde el tercer √≠ndice desde el final del string hasta el final.

**Inicio negativo con tama√±o espec√≠fico:** En el ejemplo texto.substr(-3, 2), se extraen 2 caracteres comenzando desde el tercer √≠ndice desde el final del string.

**M√©todo .slice(start, end)**

El m√©todo .slice(start, end) devuelve una nueva cadena de texto que contiene los caracteres de la cadena original desde el √≠ndice start hasta, pero sin incluir, el √≠ndice end. Funciona de manera similar a substring, pero admite √≠ndices negativos.

- **Sintaxis**

```js copy filename="JavaScript"
string.slice(start, end);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena. Puede ser negativo para contar desde el final del string.
**end (opcional):** El √≠ndice del primer car√°cter que no se incluir√° en la subcadena. Si se omite, slice extraer√° caracteres desde start hasta el final del string. Puede ser negativo para contar desde el final del string.

- **Caracter√≠sticas**

  - **Inicio y fin negativos:** Ambos √≠ndices pueden ser negativos, contando desde el final del string.
  - **No intercambia √≠ndices:** Si start es mayor que end, no intercambia los valores, sino que devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.slice(3); // "marino"
let subcadena2 = texto.slice(3, 5); // "ma"
let subcadena3 = texto.slice(-3); // "ino"
let subcadena4 = texto.slice(-6, -3); // "Submar"
console.log(subcadena1); // "marino"
console.log(subcadena2); // "ma"
console.log(subcadena3); // "ino"
console.log(subcadena4); // "mar"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.slice(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer entre dos √≠ndices:** En el ejemplo texto.slice(3, 5), se extraen los caracteres desde el √≠ndice 3 hasta el 5, sin incluir el car√°cter en el √≠ndice 5.

**Inicio negativo:** En el ejemplo texto.slice(-3), se extraen los caracteres desde el tercer √≠ndice desde el final del string hasta el final.

**Inicio y fin negativos:** En el ejemplo texto.slice(-6, -3), se extraen los caracteres desde el noveno √≠ndice desde el final del string hasta el tercer √≠ndice desde el final.

<div className="flex justify-center my-5">
  <Image
    src="/assets/img/slice.png"
    alt="Elemento en HTML"
    width={750}
    height={750}
  />
</div>

**Dividir un texto en partes (array)**

El m√©todo .split() en JavaScript ofrece una flexibilidad considerable para dividir strings en arrays utilizando separadores espec√≠ficos. Este m√©todo se puede aplicar de varias maneras, dependiendo de si el separador es una cadena fija, una expresi√≥n regular, o si se establece un l√≠mite en la cantidad de splits. Profundicemos en los detalles t√©cnicos y las variantes de este m√©todo para entender mejor su aplicaci√≥n y comportamiento en diferentes contextos.

- **Divisi√≥n con Texto Fijo**

Cuando se utiliza una cadena fija como separador, .split() divide el string en cada punto donde encuentra esta cadena.

**M√©todo .split(text)**

Cuando utilizas .split(text) sin un segundo par√°metro, divides el string original en tantos elementos como ocurrencias del separador haya en el string. Este m√©todo es √∫til para descomponer un string en un array basado en un delimitador fijo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const poem = "The quick brown fox jumps over the lazy dog";
const words = poem.split(" ");
console.log(words);
```

const poem = "The quick brown fox jumps over the lazy dog";
const words = poem.split(" ");
console.log(words);

**.split(text, limit)**

El par√°metro limit controla el n√∫mero m√°ximo de elementos que ser√°n incluidos en el array resultante. Si el n√∫mero de divisiones producidas por el separator es mayor que limit, las subdivisiones adicionales son descartadas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const data = "apple,orange,banana,pear,grape";
const limitedItems = data.split(",", 3);
console.log(limitedItems);
```

Aqu√≠, limitedItems ser√° ["apple", "orange", "banana"]. Aunque hay m√°s elementos que podr√≠an ser extra√≠dos, el limit de 3 asegura que solo los tres primeros sean incluidos.

**.split(regexp)**

Utilizar expresiones regulares como el separator permite un control m√°s refinado sobre c√≥mo se divide el string. Puedes especificar un patr√≥n que puede no ser un substring fijo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const complexData = "word1, word2: word3; word4. word5";
const parts = complexData.split(/[\s,;:.]+/);
console.log(parts);
```

En este caso, parts ser√° ["word1", "word2", "word3", "word4", "word5"]. La expresi√≥n regular /[\s,;:.]+/ indica que el string debe dividirse en cualquier punto donde uno o m√°s espacios, comas, puntos y comas, dos puntos o puntos se encuentren.

**.split(regexp, limit)**

Combinar una expresi√≥n regular con un limit te permite dividir un string seg√∫n un patr√≥n complejo, pero tambi√©n controlar cu√°ntos substrings quieres extraer, lo cual es √∫til para evitar procesamiento innecesario.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const message =
  "This is a sentence. This is another sentence. And yet another one.";
const firstTwoSentences = message.split(/[.!?]\s/, 2);
console.log(firstTwoSentences);
```

Aqu√≠, firstTwoSentences ser√° ["This is a sentence", "This is another sentence"]. La divisi√≥n se realiza en puntos, signos de exclamaci√≥n o interrogaci√≥n seguidos de un espacio, pero se limita a las dos primeras sentencias.

- **Detalles Adicionales sobre .split() y Caracteres Especiales**

Es importante destacar que si el separator es una cadena vac√≠a, el resultado es un array de caracteres individuales del string. Esto es particularmente √∫til para tareas como la inversi√≥n de un string o la realizaci√≥n de operaciones en cada car√°cter.

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const message =
  "This is a sentence. This is another sentence. And yet another one.";
const firstTwoSentences = message.split(/[.!?]\s/, 2);
console.log(firstTwoSentences);
```

Este script divide word en caracteres, los invierte y luego los une de nuevo, resultando en "sdrawkcab".

<div className="flex justify-center my-5">
  <Image
    src="/assets/img/split.png"
    alt="Elemento en HTML"
    width={750}
    height={750}
  />
</div>

### Buscar y Reemplazar

En JavaScript, las operaciones de b√∫squeda y reemplazo son fundamentales para manipular cadenas de texto. Estas operaciones permiten identificar subcadenas espec√≠ficas dentro de una cadena mayor y, si es necesario, reemplazarlas con una nueva subcadena. Esto es extremadamente √∫til en muchas aplicaciones web, como la validaci√≥n de formularios, la limpieza de datos de entrada, o simplemente la transformaci√≥n de textos seg√∫n las necesidades del usuario.

üîçVerificar(üîç): Este es el m√°s sencillo de los tres m√©todos. S√≥lo comprueba si existe un fragmento de texto. üïµÔ∏è‚Äç‚ôÄÔ∏è Buscar (üîç üïµÔ∏è‚Äç‚ôÄÔ∏è): busca un fragmento de texto y devuelve informaci√≥n sobre el texto encontrado (ubicaci√≥n, texto...). üîÅ Reemplazar (üîç üïµÔ∏è‚Äç‚ôÄÔ∏è üîÅ): busca y reemplaza texto. En general, es m√°s caro.

**M√©todo .startsWith(text, from)**

El m√©todo .startsWith() en JavaScript se utiliza para determinar si una cadena de texto comienza con los caracteres especificados, devolviendo true si es as√≠ y false de lo contrario. Es fundamental en situaciones donde es necesario validar los inicios de las cadenas, como c√≥digos de productos, protocolos en URLs, o simplemente condiciones de formato.

- **Sintaxis**

```js copy filename="JavaScript"
string.startsWith(searchString, position);
```

**searchString:** La subcadena que se busca al comienzo del string principal.
**position (opcional):** La posici√≥n en la cadena desde la cual se debe empezar a buscar. El valor por defecto es 0, lo que implica que la b√∫squeda comienza desde el inicio del string.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos algunos ejemplos que ilustran c√≥mo se utiliza .startsWith() en diferentes contextos:

```js copy filename="JavaScript"
const str1 = "Buenos d√≠as, mundo!";
console.log(str1.startsWith("Buenos")); // true

const str2 = "JavaScript es genial";
console.log(str2.startsWith("Script", 4)); // true

const filename = "reporte_final.doc";
console.log(filename.startsWith("reporte")); // true
```

- En el primer ejemplo, se verifica si el string "Buenos d√≠as, mundo!" comienza con la subcadena "Buenos", lo cual es verdadero.
- En el segundo ejemplo, "JavaScript es genial" se verifica si comienza con "Script" empezando desde el √≠ndice 4, mostrando c√≥mo se puede ajustar el punto de inicio de la b√∫squeda.
- El tercer ejemplo verifica si el nombre de archivo comienza con "reporte", algo com√∫n en la validaci√≥n de formatos de archivo o en sistemas de manejo de documentos.

**M√©todo .endsWith(text, to)**

El m√©todo .endsWith() es utilizado para determinar si una cadena de texto termina con los caracteres de otra cadena especificada, devolviendo true si es as√≠, y false en caso contrario. Este m√©todo es particularmente √∫til cuando necesitas asegurarte de que un string cumple con ciertos criterios al final, como extensiones de archivo o ciertas terminaciones en idiomas program√°ticos o humanos.

- **Sintaxis**

```js copy filename="JavaScript"
string.endsWith(searchString, length);
```

**searchString:** La cadena que se buscar√° al final del string.
**length (opcional):** Si se especifica, se trata el string como si tuviera exactamente este n√∫mero de caracteres (esencialmente, ajusta el string a este tama√±o antes de realizar la b√∫squeda).

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const file = "example.txt";
console.log(file.endsWith(".txt")); // true

const greeting = "Hello world!";
console.log(greeting.endsWith("world", 11)); // true
```

En el primer ejemplo, se verifica si el nombre del archivo termina en .txt, √∫til para manipulaci√≥n de archivos. En el segundo ejemplo, se verifica si la cadena "Hello world!" termina con "world" cuando se consideran los primeros 11 caracteres, demostrando c√≥mo el par√°metro de longitud puede alterar el resultado.

**M√©todo .includes(text, from)**

El m√©todo .includes() permite verificar si una cadena contiene otra subcadena dentro de ella, devolviendo true si la encuentra, y false si no. Este m√©todo es insustituible en la b√∫squeda de contenido dentro de un string, y su capacidad para iniciar la b√∫squeda desde un √≠ndice espec√≠fico lo hace muy vers√°til.

- **Sintaxis**

```js copy filename="JavaScript"
string.includes(searchString, position);
```

**searchString:** La subcadena que se buscar√° dentro del string.
**position (opcional):** El √≠ndice desde donde comenzar la b√∫squeda dentro del string. Por defecto es 0.

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const phrase = "Finding substrings in strings";
console.log(phrase.includes("sub")); // true

const message = "Case sensitive search";
console.log(message.includes("case")); // false
console.log(message.includes("case", 5)); // true
```

En estos ejemplos, el m√©todo .includes() demuestra su utilidad para encontrar subcadenas. El segundo ejemplo tambi√©n resalta la sensibilidad a may√∫sculas y min√∫sculas del m√©todo, y c√≥mo el inicio de la b√∫squeda puede afectar el resultado.

### B√∫squeda de Cadenas

La b√∫squeda de cadenas de texto es una operaci√≥n fundamental en la programaci√≥n. Permite localizar posiciones espec√≠ficas, verificar la existencia de patrones y mucho m√°s. En JavaScript, uno de los m√©todos m√°s poderosos para realizar estas b√∫squedas es .search(), que utiliza expresiones regulares (regex).

**M√©todo .search(regexp)**

El m√©todo .search() busca una coincidencia entre una expresi√≥n regular y el string sobre el que se aplica. Devuelve el √≠ndice de la primera coincidencia o -1 si no se encuentra ninguna coincidencia. Es una herramienta esencial cuando se necesita comprobar la presencia de patrones complejos dentro de un string.

- **Sintaxis**

```js copy filename="JavaScript"
string.search(regexp);
```

**regexp:** Una expresi√≥n regular que describe el patr√≥n a buscar.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const text = "JavaScript es un lenguaje de programaci√≥n vers√°til.";
const position = text.search(/lenguaje/);
console.log(position); // 17
```

En este ejemplo, la palabra "lenguaje" se encuentra en la posici√≥n 14 del string.

**M√©todo .match(regexp)**

El m√©todo .match() se utiliza para obtener todas las coincidencias de una expresi√≥n regular en una cadena. Devuelve un array que contiene las coincidencias encontradas o null si no se encuentra ninguna coincidencia.

- **Sintaxis**

```js copy filename="JavaScript"
string.match(regexp);
```

**regexp:** Una expresi√≥n regular que describe el patr√≥n a buscar.

- **Caracter√≠sticas**

  - Si la expresi√≥n regular no tiene el flag global (g), .match() devolver√° solo la primera coincidencia y algunos detalles adicionales.
  - Si la expresi√≥n regular tiene el flag global (g), .match() devolver√° todas las coincidencias encontradas.

<h4 className="font-medium mt-5">Ejemplo sin el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const result = text.match(/JavaScript/);
console.log(result); // ["JavaScript", index: 0, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
```

En este caso, .match() devuelve la primera coincidencia junto con su posici√≥n en el string y otros detalles.

<h4 className="font-medium mt-5">Ejemplo con el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const result = text.match(/JavaScript/g);
console.log(result); // ["JavaScript", "JavaScript"]
```

Aqu√≠, al usar el flag global (g), .match() devuelve todas las ocurrencias de "JavaScript" en un array.

**M√©todo .matchAll(regexp)**

El m√©todo .matchAll() es una versi√≥n m√°s reciente y avanzada de .match(). Devuelve un iterador que produce todas las coincidencias completas, incluidas las subcadenas capturadas. Requiere el flag global (g) en la expresi√≥n regular.

- **Sintaxis**

```js copy filename="JavaScript"
string.matchAll(regexp);
```

- **Caracter√≠sticas**

Devuelve un iterador de todas las coincidencias encontradas, lo que es √∫til para manejar grandes conjuntos de datos de manera eficiente.
Incluye detalles completos de cada coincidencia, incluidos los grupos de captura.

<h4 className="font-medium mt-5">Ejemplo con el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const matches = text.matchAll(/JavaScript/g);

for (const match of matches) {
  console.log(match); // ["JavaScript", index: 0, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
  // ["JavaScript", index: 27, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
}
```

En este ejemplo, el iterador produce todas las coincidencias una por una.

### Reemplazar cadenas de texto

Reemplazar cadenas de texto es una tarea fundamental en la manipulaci√≥n de strings en JavaScript. Los m√©todos .replace() y .replaceAll() son esenciales para estas operaciones, permitiendo tanto reemplazos simples como complejos con expresiones regulares.

**M√©todo .replace(text, newText)**

El m√©todo .replace() se utiliza para reemplazar la primera coincidencia de una subcadena o una expresi√≥n regular dentro de un string. Su uso es bastante vers√°til, permitiendo realizar reemplazos b√°sicos y tambi√©n m√°s avanzados mediante el uso de expresiones regulares.

- **Sintaxis**

```js copy filename="JavaScript"
string.replace(searchValue, newValue);
```

**searchValue:** La subcadena o expresi√≥n regular que se va a buscar en el string.
**newValue:** La subcadena que reemplazar√° la primera coincidencia de searchValue.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludo = "Hola mundo";
const nuevoSaludo = saludo.replace("mundo", "amigo");
console.log(nuevoSaludo); // "Hola amigo"
```

En este ejemplo, la primera aparici√≥n de "mundo" se reemplaza por "amigo". Esto es √∫til para situaciones donde solo necesitas cambiar la primera instancia de una palabra o frase.

<h4 className="font-medium mt-5">Ejemplo usando expresiones regulares</h4>

```js copy filename="JavaScript"
const frase = "El color es rojo. El color es verde.";
const nuevaFrase = frase.replace(/color/, "tono");
console.log(nuevaFrase); // "El tono es rojo. El color es verde."
```

Aqu√≠, se utiliza una expresi√≥n regular para buscar la primera aparici√≥n de "color" y reemplazarla por "tono". Las expresiones regulares ofrecen una manera poderosa de buscar patrones dentro de un string.

<h4 className="font-medium mt-5">Ejemplo de reemplazo con funci√≥n</h4>

```js copy filename="JavaScript"
const texto = "Hola mundo";
const nuevoTexto = texto.replace("mundo", (match) => `amigo (${match})`);
console.log(nuevoTexto); // "Hola amigo (mundo)"
```

En este caso, en lugar de simplemente proporcionar un string para reemplazar, se usa una funci√≥n. La funci√≥n recibe como argumento la coincidencia encontrada y devuelve el nuevo valor. Esto permite generar reemplazos din√°micos basados en el contenido original.

**M√©todo .replaceAll(text, newText)**

El m√©todo .replaceAll() se utiliza para reemplazar todas las coincidencias de una subcadena espec√≠fica o una expresi√≥n regular dentro de un string. Es especialmente √∫til cuando necesitas modificar m√∫ltiples apariciones de un texto en una sola operaci√≥n.

- **Sintaxis**

```js copy filename="JavaScript"
string.replaceAll(searchValue, newValue);
```

**searchValue:** La subcadena o expresi√≥n regular que se va a buscar en el string.
**newValue:** La subcadena que reemplazar√° todas las coincidencias de searchValue.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludo = "Hola mundo mundo";
const nuevoSaludo = saludo.replaceAll("mundo", "amigo");
console.log(nuevoSaludo); // "Hola amigo amigo"
```

En este caso, todas las apariciones de "mundo" se reemplazan por "amigo". Esto es muy √∫til cuando necesitas asegurarte de que todas las instancias de un texto espec√≠fico se cambien.

<h4 className="font-medium mt-5">Ejemplo usando expresiones regulares</h4>

```js copy filename="JavaScript"
const frase = "El color es rojo. El color es verde.";
const nuevaFrase = frase.replaceAll(/color/g, "tono");
console.log(nuevaFrase); // "El tono es rojo. El tono es verde."
```

Aqu√≠, se usa una expresi√≥n regular global (/color/g) para encontrar todas las apariciones de "color" y reemplazarlas por "tono". Las expresiones regulares globales son potentes para realizar reemplazos en todo el string.

<h4 className="font-medium mt-5">Ejemplo de reemplazo con funci√≥n</h4>

```js copy filename="JavaScript"
const frase = "Contar: 1, 2, 3, 4";
const nuevaFrase = frase.replaceAll(/\d/g, (match) => `(${match})`);
console.log(nuevaFrase); // "Contar: (1), (2), (3), (4)"
```

Aqu√≠, se utiliza una funci√≥n para envolver cada d√≠gito encontrado en par√©ntesis. La funci√≥n de reemplazo recibe el valor encontrado y devuelve el nuevo valor, permitiendo una transformaci√≥n compleja y din√°mica del string original.

### Modificar Cadenas de Texto

Modificar cadenas de texto es una operaci√≥n esencial en cualquier lenguaje de programaci√≥n. JavaScript proporciona varios m√©todos para transformar cadenas de texto. Vamos a detallar cada uno de estos m√©todos con ejemplos pr√°cticos para que puedas entender c√≥mo y cu√°ndo utilizarlos.

**M√©todo .toLowerCase()**

El m√©todo .toLowerCase() se utiliza para convertir todos los caracteres de una cadena a min√∫sculas. Esto puede ser particularmente √∫til cuando necesitamos normalizar el texto para comparaciones o b√∫squedas insensibles a may√∫sculas y min√∫sculas.

- **Funcionamiento**

.toLowerCase() recorre cada car√°cter de la cadena original y, si encuentra una letra may√∫scula, la convierte en min√∫scula. La cadena original no se modifica; en su lugar, se devuelve una nueva cadena con todos los caracteres en min√∫sculas.

- **Sintaxis**

```js copy filename="JavaScript"
string.toLowerCase();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Imagina que tienes un formulario donde el usuario puede ingresar su direcci√≥n de correo electr√≥nico, y quieres asegurarte de que la comparaci√≥n sea insensible a may√∫sculas y min√∫sculas.

```js copy filename="JavaScript"
const emailInput = "Usuario@Dominio.Com";
const normalizedEmail = emailInput.toLowerCase();
console.log(normalizedEmail); // "usuario@dominio.com"
```

**M√©todo `.toUpperCase()**

El m√©todo .toUpperCase() se utiliza para convertir todos los caracteres de una cadena a may√∫sculas. Este m√©todo es √∫til para enfatizar texto o para asegurar consistencia en la presentaci√≥n de datos.

- **Funcionamiento**

.toUpperCase() recorre cada car√°cter de la cadena original y, si encuentra una letra min√∫scula, la convierte en may√∫scula. La cadena original no se modifica; en su lugar, se devuelve una nueva cadena con todos los caracteres en may√∫sculas.

- **Sintaxis**

```js copy filename="JavaScript"
string.toUpperCase();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Imagina que tienes una cadena que quieres usar como t√≠tulo en una p√°gina web y quieres asegurarte de que se muestre en may√∫sculas.

```js copy filename="JavaScript"
const title = "bienvenidos a mi sitio web";
const upperTitle = title.toUpperCase();
console.log(upperTitle); // "BIENVENIDOS A MI SITIO WEB"
```

**M√©todo .padStart(size, text)**

El m√©todo .padStart() rellena la cadena actual con otra cadena hasta que la longitud resultante alcanza la longitud dada. Este m√©todo es √∫til para formatear datos, como n√∫meros o fechas, de manera uniforme.

-**Funcionamiento**

.padStart() a√±ade caracteres al inicio de la cadena original hasta que se alcanza la longitud especificada. Si la longitud especificada es menor o igual a la longitud de la cadena original, la cadena se devuelve sin cambios.

- **Sintaxis**

```js copy filename="JavaScript"
string.padStart(targetLength [, padString])
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Para mostrar n√∫meros siempre con al menos dos d√≠gitos, se puede utilizar .padStart().

```js copy filename="JavaScript"
const num = "5";
const paddedNum = num.padStart(2, "0");
console.log(paddedNum); // "05"
```

Si tienes identificadores que deben tener un formato fijo de longitud, .padStart() puede ser muy √∫til.

```js copy filename="JavaScript"
const id = "123";
const formattedId = id.padStart(6, "0");
console.log(formattedId); // "000123"
```

**M√©todo .padEnd(size, text)**

El m√©todo .padEnd() funciona de manera similar a .padStart(), pero a√±ade caracteres al final de la cadena. Este m√©todo es √∫til para alinear texto en una presentaci√≥n tabular o para crear strings con un formato espec√≠fico.

- **Funcionamiento**

.padEnd() a√±ade caracteres al final de la cadena original hasta que se alcanza la longitud especificada. Si la longitud especificada es menor o igual a la longitud de la cadena original, la cadena se devuelve sin cambios.

- **Sintaxis**

```js copy filename="JavaScript"
string.padEnd(targetLength [, padString])
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Para alinear nombres en una presentaci√≥n tabular, puedes utilizar .padEnd().

```js copy filename="JavaScript"
const name = "Ana";
const paddedName = name.padEnd(10, " ");
console.log(paddedName); // "Ana       "
```

Si necesitas que las descripciones de productos tengan una longitud fija para alineaci√≥n, .padEnd() es √∫til.

```js copy filename="JavaScript"
const description = "Laptop";
const paddedDescription = description.padEnd(15, ".");
console.log(paddedDescription); // "Laptop........"
```

**M√©todo .trimStart()**

El m√©todo .trimStart() elimina los espacios en blanco al inicio de un string. Este m√©todo no modifica el string original, sino que devuelve una nueva cadena sin los espacios iniciales.

- **Funcionamiento**

El m√©todo .trimStart() opera sobre una instancia de cadena y elimina cualquier espacio en blanco (incluidos espacios, tabs, etc.) desde el comienzo de la cadena hasta que encuentra el primer car√°cter no blanco. Este m√©todo es particularmente √∫til cuando se trata de entradas de usuario, donde los espacios en blanco adicionales pueden introducir errores o inconsistencias.

- **Sintaxis**

```js copy filename="JavaScript"
string.trimStart();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo";
let trimmedText = text.trimStart();
console.log(trimmedText); // "Hola Mundo"
```

En este ejemplo, trimmedText contiene "Hola Mundo" sin los espacios iniciales.

```js copy filename="JavaScript"
let text = "\t\tJavaScript";
let trimmedText = text.trimStart();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, los caracteres de tabulaci√≥n (\t) al inicio de la cadena text se eliminan.

**M√©todo .trimEnd()**

El m√©todo .trimEnd() elimina los espacios en blanco al final de un string. Similar a .trimStart(), este m√©todo devuelve una nueva cadena sin los espacios finales.

- **Funcionamiento**

El m√©todo .trimEnd() se encarga de eliminar los espacios en blanco desde el final de la cadena hasta encontrar el primer car√°cter no blanco. Esto es √∫til para limpiar datos que pueden tener espacios adicionales al final, asegurando que las comparaciones y manipulaciones de cadenas sean precisas.

- **Sintaxis**

```js copy filename="JavaScript"
string.trimEnd();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "Hola Mundo   ";
let trimmedText = text.trimEnd();
console.log(trimmedText); // "Hola Mundo"
```

En este caso, trimmedText resulta en "Hola Mundo" sin los espacios finales.

```js copy filename="JavaScript"
let text = "JavaScript\t\t";
let trimmedText = text.trimEnd();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, los caracteres de tabulaci√≥n (\t) al final de la cadena text se eliminan.

**M√©todo .trim()**

El m√©todo .trim() elimina los espacios en blanco tanto al inicio como al final de un string. Este m√©todo es una combinaci√≥n de .trimStart() y .trimEnd(), proporcionando una soluci√≥n completa para limpiar los espacios en blanco de los extremos de una cadena.

- **Sintaxis**

```js copy filename="JavaScript"
string.trim();
```

- **Funcionamiento**

El m√©todo .trim() es el m√°s completo de los tres, ya que se ocupa de eliminar todos los espacios en blanco tanto al principio como al final de una cadena. Esto es extremadamente √∫til en una variedad de situaciones, desde la limpieza de datos de entrada hasta la normalizaci√≥n de cadenas para comparaciones y almacenamiento.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo   ";
let trimmedText = text.trim();
console.log(trimmedText); // "Hola Mundo"
```

En este ejemplo, trimmedText contiene "Hola Mundo" sin los espacios en blanco al inicio y al final.

```js copy filename="JavaScript"
let text = "\t\tJavaScript\t\t";
let trimmedText = text.trim();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, tanto los caracteres de tabulaci√≥n (\t) al inicio como al final de la cadena text se eliminan.

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: " Hello World
  ".trimStart();
</h4>

<p className="my-2">a) "Hello World "</p>
<p>b) " Hello World"</p>
<p className="my-2">c) "Hello World"</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) "Hello World "</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© m√©todo utilizar√≠as para verificar si una cadena contiene la palabra
  "JavaScript"?
</h4>

<p className="my-2">a) .indexOf()</p>
<p>b) .includes()</p>
<p className="my-2">c) .search()</p>
<p className="mb-2">d) Todas las anteriores</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>d) Todas las anteriores</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "12345".slice(1, 3);
</h4>

<p className="my-2">a) 12</p>
<p>b) 234</p>
<p className="my-2">c) 23</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 23</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øQu√© m√©todo se utiliza para convertir una cadena a min√∫sculas?
</h4>

<p className="my-2">a) .toLowerCase()</p>
<p>b) .toUpperCase()</p>
<p className="my-2">c) .toLocaleLowerCase()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) .toLowerCase()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: " JavaScript
  ".trimEnd();
</h4>

<p className="my-2">a) " JavaScript"</p>
<p>b) "JavaScript "</p>
<p className="my-2">c) "JavaScript"</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) " JavaScript"</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øQu√© m√©todo devuelve el √≠ndice de la primera ocurrencia de una subcadena?
</h4>

<p className="my-2">a) .search()</p>
<p>b) .indexOf()</p>
<p className="my-2">c) .find()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) .indexOf()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "Learning JavaScript".includes("Java");

</h4>

<p className="my-2">a) true</p>
<p>b) false</p>
<p className="my-2">c) undefined</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) true</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "Hello".charAt(0);
</h4>

<p className="my-2">a) H</p>
<p>b) e</p>
<p className="my-2">c) o</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) H</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øQu√© m√©todo se utiliza para dividir una cadena en un array de subcadenas
  basadas en un separador?
</h4>

<p className="my-2">a) .join()</p>
<p>b) .split()</p>
<p className="my-2">c) .slice()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) .split()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "JavaScript".substring(4, 10);

</h4>

<p className="my-2">a) Java</p>
<p>b) Script</p>
<p className="my-2">c) Scrip</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Scrip</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco al inicio de una
  cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trimStart()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øCu√°l es la diferencia entre .includes() y .indexOf()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .includes() devuelve true o false si una cadena contiene una subcadena espec√≠fica, mientras que .indexOf() devuelve el √≠ndice de la primera ocurrencia de la subcadena o -1 si no se encuentra.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øC√≥mo se puede convertir una cadena a may√∫sculas?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .toUpperCase()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øQu√© m√©todo se utiliza para verificar si una cadena comienza con una
  subcadena espec√≠fica?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .startsWith()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l es el prop√≥sito del m√©todo .slice() en cadenas de texto?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Extraer una secci√≥n de una cadena y devolverla como una nueva cadena, sin modificar la original.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo puedes dividir una cadena en un array de subcadenas?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .split()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco tanto al inicio
  como al final de una cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trim()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øCu√°l es la diferencia entre .substring() y .substr()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .substring(start, end) devuelve una parte de la cadena entre start y end, mientras que .substr(start, length) devuelve una parte de la cadena desde start y con una longitud espec√≠fica length.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øC√≥mo se puede reemplazar una subcadena en una cadena por otra subcadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .replace()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco al final de una
  cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trimEnd()

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Eliminar espacios en blanco al inicio y al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo   ";
        let trimmedText = text.trim();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Verificar si una cadena contiene una subcadena espec√≠fica.
</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript es divertido";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript es divertido";
        let contains = text.includes("JavaScript");
        console.log(contains); // true
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">3. Convertir una cadena a may√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "hola mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "hola mundo";
        let upperText = text.toUpperCase();
        console.log(upperText); // "HOLA MUNDO"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Reemplazar una subcadena en una cadena por otra subcadena.
</h4>

```js copy filename="JavaScript"
let text = "Me gusta programar en Java";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Me gusta programar en Java";
        let newText = text.replace("Java", "JavaScript");
        console.log(newText); // "Me gusta programar en JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">5. Extraer una parte de una cadena.</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript";
        let part = text.slice(12, 22);
        console.log(part); // "JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  6. Eliminar espacios en blanco al inicio de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo";
        let trimmedText = text.trimStart();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  7. Eliminar espacios en blanco al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Hola Mundo   ";
        let trimmedText = text.trimEnd();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  8. Dividir una cadena en un array de subcadenas.
</h4>

```js copy filename="JavaScript"
let text = "rojo,azul,verde";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "rojo,azul,verde";
        let colors = text.split(",");
        console.log(colors); // ["rojo", "azul", "verde"]
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  9. Obtener el car√°cter en una posici√≥n espec√≠fica de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "JavaScript";
        let char = text.charAt(4);
        console.log(char); // "S"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">10. Convertir una cadena a min√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "HOLA MUNDO";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "HOLA MUNDO";
        let lowerText = text.toLowerCase();
        console.log(lowerText); // "hola mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## Boolean

En JavaScript, un Boolean es un tipo de dato primitivo que puede tener uno de dos valores posibles: true o false. Estos valores se utilizan principalmente para tomar decisiones en el flujo del programa, como en declaraciones condicionales y bucles. Veamos m√°s detalladamente c√≥mo funcionan y c√≥mo se utilizan los Booleanos en JavaScript.

### Creaci√≥n de Booleanos

Puedes crear valores Booleanos directamente utilizando las palabras clave true y false:

```js copy filename="JavaScript"
let isDataValid = true;
let isStringTooLong = false;
```

Tambi√©n puedes obtener valores Booleanos como resultado de evaluaciones l√≥gicas o comparaciones:

```js copy filename="JavaScript"
let isGreater = 10 > 5; // true
let isEqual = 10 === 10; // true
let isLesser = 5 < 3; // false
```

**Uso de Booleanos en Condicionales**

Los valores Booleanos son fundamentales en las estructuras de control, como las declaraciones if, que permiten ejecutar bloques de c√≥digo bas√°ndose en condiciones:

```js copy filename="JavaScript"
let isLoggedIn = true;

if (isLoggedIn) {
  console.log("User is logged in.");
} else {
  console.log("User is not logged in.");
}
```

En este ejemplo, si isLoggedIn es true, se ejecutar√° el primer bloque de c√≥digo. Si es false, se ejecutar√° el bloque en el else.

**Operadores L√≥gicos**

JavaScript proporciona varios operadores l√≥gicos que se pueden usar para manipular valores Booleanos:

- **NOT (!):** Invierte el valor de un Booleano.
- **AND (&&):** Devuelve true si ambos operandos son true.
- **OR (||):** Devuelve true si al menos uno de los operandos es true.

```js copy filename="JavaScript"
let isAdmin = false;
let isMember = true;

console.log(!isAdmin); // true
console.log(isAdmin && isMember); // false
console.log(isAdmin || isMember); // true
```

### Booleanos y Conversi√≥n Impl√≠cita

JavaScript convierte impl√≠citamente otros tipos de datos a Booleanos en contextos l√≥gicos. Los siguientes valores se consideran falsy (se convierten a false):

- false
- 0
- "" (cadena vac√≠a)
- null
- undefined
- NaN (Not-a-Number)

Cualquier otro valor se considera truthy (se convierte a true)

<h4 className="font-medium mt-5">Ejemplo de Conversi√≥n Impl√≠cita</h4>

```js copy filename="JavaScript"
if (0) {
  console.log("This won't be logged.");
}

if ("hello") {
  console.log("This will be logged.");
}
```

## Undefined

En JavaScript, undefined es un tipo de dato primitivo que indica que una variable no ha sido asignada a un valor. Es uno de los valores m√°s comunes que encontrar√°s y es fundamental comprender c√≥mo y cu√°ndo aparece para manejar correctamente los datos y evitar errores en el c√≥digo.

El tipo undefined tiene un √∫nico valor: undefined. Este es el valor por defecto que se asigna a una variable declarada pero no inicializada.

```js copy filename="JavaScript"
let miVariable;
console.log(typeof miVariable); // "undefined"
```

En este caso, miVariable es declarada pero no se le asigna ning√∫n valor, por lo que su tipo y su valor son undefined.

### Asignaci√≥n de undefined

Aunque es posible asignar expl√≠citamente undefined a una variable, generalmente se recomienda usar null para denotar la ausencia intencional de un valor. Usar undefined expl√≠citamente puede llevar a confusiones, ya que tambi√©n es el valor por defecto de variables no inicializadas.

```js copy filename="JavaScript"
console.log(typeof variableNoDeclarada); // "undefined"
console.log(variableNoDeclarada); // Uncaught ReferenceError: variableNoDeclarada is not defined
```

Este comportamiento puede ser √∫til para verificar la existencia de variables en el entorno global sin causar errores.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let miVariable = 10;
miVariable = undefined;
console.log(typeof miVariable); // "undefined"
```

## Null

En JavaScript, null es un tipo de dato primitivo que representa la ausencia intencional de cualquier valor de objeto. Este valor es utilizado para indicar que una variable que normalmente contendr√≠a un objeto est√° actualmente vac√≠a.

El valor null se asigna intencionalmente a una variable para denotar que no tiene valor. Es una forma expl√≠cita de decir que la variable est√° vac√≠a. A diferencia de undefined, que es el valor por defecto para las variables que han sido declaradas pero no inicializadas, null se utiliza para indicar deliberadamente la falta de un valor.

```js copy filename="JavaScript"
let emptyValue = null;
console.log(emptyValue); // null
```

En este ejemplo, emptyValue se inicializa expl√≠citamente con null para indicar que est√° vac√≠a.

**Diferencia entre null y undefined**

Aunque null y undefined pueden parecer similares, tienen significados distintos:

- **null:** Asignado intencionalmente para indicar ausencia de valor.
- **undefined:** Valor predeterminado para variables declaradas pero no inicializadas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let variableA = null;
let variableB;

console.log(variableA); // null
console.log(variableB); // undefined
```

En este caso, variableA ha sido asignada expl√≠citamente con null, mientras que variableB no ha sido inicializada, resultando en undefined.

### Propiedades y Comportamiento de null

- **Tipo de Dato:** Aunque null es un valor primitivo, el operador typeof devuelve "object" cuando se aplica a null, lo cual es un error hist√≥rico en JavaScript.

```js copy filename="JavaScript"
let variable = null;
console.log(typeof variable); // "object"
```

- **Comparaciones:** null es igual a s√≠ mismo y a undefined (con el operador ==), pero no es estrictamente igual a undefined (con el operador ===).

```js copy filename="JavaScript"
console.log(null == undefined); // true
console.log(null === undefined); // false
```

## Funciones

En JavaScript, una funci√≥n es un bloque de c√≥digo dise√±ado para realizar una tarea espec√≠fica. Este bloque de c√≥digo se define una vez y puede ser ejecutado o "llamado" en cualquier momento, a menudo varias veces, lo que permite la reutilizaci√≥n del c√≥digo y una mejor organizaci√≥n del programa. Las funciones son una parte fundamental de la programaci√≥n en JavaScript y se utilizan para modularizar el c√≥digo, mejorar la legibilidad, y permitir la reutilizaci√≥n.

**¬øPor qu√© usar funciones?**

Las funciones son esenciales en JavaScript por varias razones:

- **Reutilizaci√≥n del C√≥digo:** Permiten escribir un conjunto de instrucciones una vez y reutilizarlas varias veces. Esto reduce la cantidad de c√≥digo duplicado y facilita la implementaci√≥n de cambios.

- **Modularidad:** Ayudan a descomponer el c√≥digo en bloques l√≥gicos m√°s peque√±os y manejables. Cada funci√≥n puede representar una unidad de funcionalidad espec√≠fica, lo que facilita el mantenimiento y la comprensi√≥n del c√≥digo.

- **Abstracci√≥n:** Simplifican el c√≥digo al ocultar sus detalles internos y exponer solo lo necesario para su uso. Los usuarios de una funci√≥n no necesitan conocer su implementaci√≥n interna, solo necesitan saber c√≥mo llamarla y qu√© par√°metros requiere.

- **Mantenibilidad:** Facilitan el mantenimiento y actualizaci√≥n del c√≥digo. Al tener la l√≥gica encapsulada en funciones, los cambios se pueden realizar en un solo lugar y afectar a todas las llamadas a la funci√≥n.

### Partes de una Funci√≥n

Las funciones en JavaScript se componen de varias partes clave que determinan c√≥mo se definen y c√≥mo se comportan.

1. **Palabra clave function**

La palabra clave function se utiliza para declarar una funci√≥n. Indica a JavaScript que est√°s definiendo una funci√≥n.

```js copy filename="JavaScript"
function miFuncion() {
  // Cuerpo de la funci√≥n
}
```

2. **Nombre de la Funci√≥n**

El nombre de la funci√≥n sigue a la palabra clave function. Debe ser √∫nico dentro de su alcance y describir lo que hace la funci√≥n. Los nombres de funciones deben seguir las reglas de nombramiento de variables en JavaScript, como empezar con una letra, guion bajo (\_), o signo de d√≥lar ($).

```js copy filename="JavaScript"
function calcularArea() {
  // Cuerpo de la funci√≥n
}
```

3. **Par√°metros de la Funci√≥n**

Los par√°metros de funci√≥n en JavaScript son fundamentales para la flexibilidad y reutilizaci√≥n del c√≥digo. Permiten pasar informaci√≥n a las funciones para que puedan operar sobre datos espec√≠ficos sin depender de variables globales.

Los par√°metros son variables que se pasan a la funci√≥n y se definen dentro de los par√©ntesis despu√©s del nombre de la funci√≥n. Estos par√°metros act√∫an como variables locales dentro de la funci√≥n. La forma en que se definen y utilizan puede influir significativamente en c√≥mo se escribe y mantiene el c√≥digo.

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}
```

En este ejemplo, a y b son par√°metros de la funci√≥n sumar.

**Nombre de los Par√°metros**

Los par√°metros se definen en la lista de par√°metros de la funci√≥n, dentro de los par√©ntesis que siguen al nombre de la funci√≥n. Los nombres de los par√°metros deben seguir las mismas reglas de nomenclatura que las variables en JavaScript.

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}
```

**Tipos de Par√°metros**

- **Par√°metros Fijos:** Son los par√°metros b√°sicos y m√°s comunes. Se definen en la declaraci√≥n de la funci√≥n y se espera que se proporcionen durante la llamada a la funci√≥n. Cada par√°metro act√∫a como una variable local dentro de la funci√≥n. Los valores que se pasan a estos par√°metros durante la llamada a la funci√≥n se denominan argumentos.

Los par√°metros fijos son ideales cuando se sabe exactamente cu√°ntos argumentos necesitar√° la funci√≥n y esos argumentos son siempre necesarios para la ejecuci√≥n de la funci√≥n.

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}
```

- **Par√°metros por Defecto:** Permiten establecer valores predeterminados para los par√°metros. Si no se proporciona un argumento durante la llamada a la funci√≥n, se utiliza el valor por defecto especificado. Esta caracter√≠stica es √∫til para crear funciones m√°s flexibles que pueden ser llamadas con menos argumentos sin causar errores.

Los par√°metros por defecto son introducidos en ECMAScript 2015 (ES6) y permiten definir funciones que pueden manejar una variedad de situaciones sin requerir m√∫ltiples sobrecargas de funciones. Esto simplifica el c√≥digo y mejora la legibilidad.

```js copy filename="JavaScript"
function saludar(nombre = "Invitado") {
  console.log("Hola, " + nombre);
}
```

En este ejemplo, si no se proporciona un argumento para nombre, se utilizar√° "Invitado".

- **Par√°metros Rest (Rest Parameters):** Los par√°metros Rest permiten representar un n√∫mero indefinido de argumentos como un array. Se declaran con tres puntos seguidos (...) seguidos de un nombre de par√°metro. Esto es √∫til cuando no se sabe cu√°ntos argumentos ser√°n pasados a la funci√≥n o cuando se desea tratar un n√∫mero variable de argumentos como un array.

Los par√°metros Rest son especialmente √∫tiles en situaciones donde se necesita trabajar con una cantidad variable de datos. Por ejemplo, se pueden utilizar en funciones que realizan operaciones matem√°ticas en un n√∫mero indefinido de n√∫meros o en funciones que combinan m√∫ltiples entradas en una sola salida.

La sintaxis de los par√°metros Rest no solo simplifica el manejo de m√∫ltiples argumentos, sino que tambi√©n mejora la legibilidad del c√≥digo al dejar claro que la funci√≥n puede aceptar un n√∫mero variable de argumentos. Adem√°s, los par√°metros Rest siempre deben ser el √∫ltimo par√°metro en la lista de par√°metros de la funci√≥n, lo que garantiza que todos los argumentos adicionales se agrupar√°n en el array de Rest.

```js copy filename="JavaScript"
function sumar(...numeros) {
  return numeros.reduce((a, b) => a + b, 0);
}
```

En este ejemplo, numeros es un array que contiene todos los argumentos pasados a la funci√≥n, permitiendo realizar operaciones sobre un n√∫mero variable de argumentos. La funci√≥n reduce se utiliza para sumar todos los elementos del array numeros.

- **Argumentos Nombrados (Objetos como Par√°metros):** En lugar de una lista de par√°metros, se puede pasar un objeto con propiedades nombradas. Esto es √∫til cuando una funci√≥n tiene muchos par√°metros, mejorando la legibilidad y flexibilidad. Los argumentos nombrados permiten pasar par√°metros de manera m√°s clara y ordenada, especialmente cuando se trabaja con funciones que requieren muchos argumentos o cuando algunos de esos argumentos son opcionales.

Los argumentos nombrados tambi√©n permiten la desestructuraci√≥n de objetos, una caracter√≠stica introducida en ECMAScript 2015 (ES6), que facilita el acceso a las propiedades del objeto directamente dentro del cuerpo de la funci√≥n. Esto hace que el c√≥digo sea m√°s conciso y f√°cil de leer.

```js copy filename="JavaScript"
function configurar({ velocidad = 5, altura = 10 }) {
  console.log(`Velocidad: ${velocidad}, Altura: ${altura}`);
}
configurar({ altura: 20, velocidad: 3 });
```

En este ejemplo, el objeto pasado como argumento define de manera clara y flexible los par√°metros de la funci√≥n. Si no se proporcionan ciertos valores, se utilizan los valores predeterminados especificados en la declaraci√≥n de la funci√≥n.

4. **Cuerpo de la Funci√≥n**

El cuerpo de la funci√≥n est√° encerrado entre llaves {} y contiene las instrucciones que se ejecutar√°n cuando la funci√≥n sea llamada. El cuerpo puede contener declaraciones de variables, operaciones, llamadas a otras funciones y cualquier otra l√≥gica necesaria para realizar la tarea de la funci√≥n.

```js copy filename="JavaScript"
function saludar(nombre) {
  console.log("Hola " + nombre);
}
```

En este ejemplo, el cuerpo de la funci√≥n saludar contiene una llamada a console.log que imprime un mensaje de saludo.

5. **Declaraci√≥n return (Opcional)**

La sentencia return en JavaScript se utiliza dentro de una funci√≥n para finalizar su ejecuci√≥n y especificar un valor para ser devuelto al c√≥digo que llam√≥ a la funci√≥n. Esta sentencia es esencial para controlar el flujo de una funci√≥n y facilitar la comunicaci√≥n entre la funci√≥n y el resto del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b; // Devolvemos la suma de a y b al exterior
  console.log("Suma realizada."); // Este c√≥digo nunca se ejecutar√°
}

// Ejecuci√≥n
const resultado = sumar(5, 5); // Se guarda 10 en la variable resultado
console.log("Resultado =", resultado); // Mostramos el resultado por consola
```

En este ejemplo, la funci√≥n sumar devuelve la suma de los dos par√°metros y finaliza su ejecuci√≥n en la l√≠nea del return. La l√≠nea console.log("Suma realizada."); no se ejecutar√° porque return termina la funci√≥n inmediatamente.

**Caracter√≠sticas de la Sentencia return**

- **Finalizaci√≥n de la Funci√≥n:** Cuando se ejecuta return, la funci√≥n termina inmediatamente. Cualquier c√≥digo que se encuentre despu√©s de return dentro de la funci√≥n no se ejecutar√°.

- **Devolver un Valor:** return puede ser seguido por un valor o una expresi√≥n. Este valor se devuelve al c√≥digo que invoc√≥ la funci√≥n. Si no se especifica un valor despu√©s de return, o si la funci√≥n no tiene una sentencia return, la funci√≥n devuelve undefined.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function obtenerMaximo(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}
let maximo = obtenerMaximo(5, 10); // maximo es 10
console.log("M√°ximo =", maximo);
```

En este ejemplo, la funci√≥n obtenerMaximo devuelve el valor mayor entre a y b.

**Uso en la L√≥gica de la Funci√≥n**

return no solo devuelve un valor, sino que tambi√©n puede ser usado para controlar el flujo de la funci√≥n basado en ciertas condiciones. Esto permite tener m√∫ltiples sentencias return en diferentes partes de una funci√≥n, cada una bajo una condici√≥n diferente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function clasificarEdad(edad) {
  if (edad < 18) {
    return "Menor";
  }
  return "Adulto";
}
let clasificacion = clasificarEdad(16); // clasificacion es "Menor"
console.log("Clasificaci√≥n =", clasificacion);
```

Aqu√≠, la funci√≥n clasificarEdad devuelve "Menor" si la edad es menor a 18, y "Adulto" en caso contrario.

**La Declaraci√≥n return en Funciones**

Las funciones que han sido llamadas ejecutan una secuencia de instrucciones contenidas en su cuerpo. La palabra clave return permite que la funci√≥n finalice exactamente donde aparece y devuelva un valor espec√≠fico al lugar donde fue llamada.

```js copy filename="JavaScript"
function showMsg() {
  console.log("message 1");
  return;
  console.log("message 2"); // Esta l√≠nea nunca se ejecutar√°
}
showMsg(); // -> "message 1"
```

En este ejemplo, showMsg muestra solo "message 1" y luego termina debido al return.

### Creaci√≥n de Funciones en JavaScript

En JavaScript, hay varias formas de crear funciones:

1. **Declaraci√≥n de Funci√≥n**

La declaraci√≥n de funci√≥n es la forma m√°s com√∫n y tradicional de definir una funci√≥n en JavaScript. Esta t√©cnica utiliza la palabra clave function, seguida del nombre de la funci√≥n, una lista de par√°metros encerrados entre par√©ntesis y el cuerpo de la funci√≥n delimitado por llaves {}.

- **Sintaxis:**

```js copy filename="JavaScript"
function nombreDeLaFuncion(par√°metros) {
  // Cuerpo de la funci√≥n
}
```

- **Caracter√≠sticas:**

Hoisting: Las declaraciones de funci√≥n son elevadas al comienzo de su contexto de ejecuci√≥n, permitiendo que las funciones sean llamadas antes de ser declaradas en el c√≥digo. Esto es debido al comportamiento del motor de JavaScript, que primero registra todas las declaraciones de funciones y luego ejecuta el resto del c√≥digo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
saludar(); // 'Hola'

function saludar() {
  return "Hola";
}
```

2. **Expresi√≥n de Funci√≥n**

Una expresi√≥n de funci√≥n define una funci√≥n dentro de una expresi√≥n. Las funciones definidas de esta manera pueden ser an√≥nimas o tener un nombre. Las expresiones de funci√≥n no son elevadas, por lo que solo est√°n disponibles despu√©s de que se ha evaluado la expresi√≥n.

- **Sintaxis:**

```js copy filename="JavaScript"
const nombreDeLaFuncion = function (par√°metros) {
  // Cuerpo de la funci√≥n
};
```

- **Caracter√≠sticas:**

  - **Funciones An√≥nimas:** Las expresiones de funci√≥n pueden ser an√≥nimas, es decir, no tienen nombre, lo que es √∫til para funciones que se utilizan una sola vez.
  - **Asignaci√≥n a Variables:** Se pueden asignar a variables, lo que permite almacenarlas y ejecutarlas posteriormente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludo = function () {
  return "Hola";
};

saludo(); // 'Hola'
```

3. **Constructor de Funci√≥n**

El constructor Function crea un nuevo objeto Function. Los par√°metros del constructor se proporcionan como cadenas, seguidas por el cuerpo de la funci√≥n tambi√©n como una cadena.

- **Sintaxis:**

```js copy filename="JavaScript"
const nombreDeLaFuncion = new Function("par√°metros", "cuerpo de la funci√≥n");
```

- **Caracter√≠sticas:**

Uso Raro: Este m√©todo es raro y generalmente no se recomienda debido a problemas de rendimiento y seguridad.
Cadenas como C√≥digo: El cuerpo de la funci√≥n y los par√°metros se pasan como cadenas, lo cual puede ser menos eficiente y seguro.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludar = new Function("return 'Hola';");

saludar(); // 'Hola'
```

### Llamada o Ejecuci√≥n de la Funci√≥n

Una vez que una funci√≥n ha sido definida, se puede ejecutar (o "llamar") en cualquier momento. La llamada de una funci√≥n ejecuta el c√≥digo definido en su cuerpo.

1. **Llamar una Funci√≥n Simple**

Para llamar a una funci√≥n, se utiliza su nombre seguido de par√©ntesis.

- **Sintaxis:**

```js copy filename="JavaScript"
nombreDeLaFuncion();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function saludar() {
  console.log("Hola, Mundo!");
}

saludar(); // Ejecuta la funci√≥n 'saludar' y muestra "Hola, Mundo!"
```

2. **Llamar una Funci√≥n con Par√°metros**

Si una funci√≥n tiene par√°metros, se pueden pasar argumentos cuando se llama a la funci√≥n. Los argumentos son los valores reales que se pasan a la funci√≥n.

- **Sintaxis:**

```js copy filename="JavaScript"
nombreDeLaFuncion(argumento1, argumento2, ...);
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function saludar(nombre) {
  console.log("Hola, " + nombre);
}

saludar("Jhoswe"); // Muestra "Hola, Jhoswe"
```

3. **Almacenar y Usar el Valor Devuelto**

Cuando una funci√≥n devuelve un valor usando la declaraci√≥n return, ese valor puede ser almacenado en una variable para su uso posterior.

- **Sintaxis:**

```js copy filename="JavaScript"
const resultado = nombreDeLaFuncion(argumentos);
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function sumar(a, b) {
  return a + b;
}

const resultado = sumar(3, 4); // Almacena el valor devuelto (7) en la variable 'resultado'
```

- **Caracter√≠sticas de la declaraci√≥n return:**

Terminaci√≥n de la Funci√≥n: La declaraci√≥n return termina la ejecuci√≥n de la funci√≥n y especifica un valor para ser devuelto al llamador.
Valor Devuelto: Si se omite return, la funci√≥n devuelve undefined de manera predeterminada.

### Variables Locales

Las variables locales en JavaScript son aquellas que se declaran dentro del cuerpo de una funci√≥n. Estas variables solo existen y son accesibles dentro de la funci√≥n en la que se declaran. Al finalizar la ejecuci√≥n de la funci√≥n, estas variables se destruyen y su valor se pierde.

**Caracter√≠sticas de las Variables Locales:**

- **Alcance Limitado:** Las variables locales solo son accesibles dentro de la funci√≥n en la que se declaran.
- **Declaraci√≥n con let y var:**

  - Las variables declaradas con let son locales dentro del bloque de c√≥digo delimitado por llaves {}.
  - Las variables declaradas con var son locales dentro del bloque de la funci√≥n en la que se declaran.

- **Evita Conflictos de Nombres:** Al usar variables locales, se evita que el nombre de la variable interfiera con otras variables en diferentes partes del programa.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function calcularPromedio(notas) {
  let suma = 0; // Variable local
  for (let i = 0; i < notas.length; i++) {
    suma += notas[i];
  }
  let promedio = suma / notas.length; // Otra variable local
  return promedio;
}

const notas = [10, 8, 9, 7, 10];
console.log(calcularPromedio(notas)); // 8.8
```

En este ejemplo, suma y promedio son variables locales a la funci√≥n calcularPromedio y no pueden ser accedidas desde fuera de esta funci√≥n.

### Shadowing (Sombreado de Variables)

El shadowing ocurre cuando una variable local dentro de una funci√≥n tiene el mismo nombre que una variable en un √°mbito superior (global o de funci√≥n externa). La variable local "sombrea" a la variable del √°mbito superior, haciendo que dentro de la funci√≥n, solo sea accesible la variable local.

**Caracter√≠sticas del Shadowing:**

- **Par√°metros de Funci√≥n:** Los par√°metros de la funci√≥n se tratan como variables locales y pueden sombrear variables globales o variables en un √°mbito externo con el mismo nombre.
- **Variables Locales:** Las variables locales pueden sombrear variables globales o variables en un √°mbito externo con el mismo nombre.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let a = 100,
  b = 200,
  c = 300;

function ejemploShadowing(a) {
  let b = 10;
  console.log(a); // Par√°metro a (sombreado)
  console.log(b); // Variable local b (sombreado)
  console.log(c); // Variable global c (no sombreada)
}

ejemploShadowing(1);
// 1 (valor del par√°metro a)
// 10 (valor de la variable local b)
// 300 (valor de la variable global c)

console.log(a); // 100 (valor global)
console.log(b); // 200 (valor global)
console.log(c); // 300 (valor global)
```

En este ejemplo, la variable a pasada como par√°metro y la variable b declarada dentro de la funci√≥n sombrean a las variables globales con los mismos nombres.

### Recursion

La recursi√≥n es una t√©cnica de programaci√≥n donde una funci√≥n se llama a s√≠ misma directa o indirectamente para resolver un problema. Esta t√©cnica es especialmente √∫til para problemas que pueden dividirse en subproblemas m√°s peque√±os del mismo tipo.

**Definici√≥n de la Recursi√≥n**

La recursi√≥n es un m√©todo de resoluci√≥n de problemas en el cual la soluci√≥n a un problema depende de soluciones a instancias m√°s peque√±as del mismo problema. Los problemas que se resuelven mediante la recursi√≥n suelen tener dos componentes clave:

- **Caso Base:** Una condici√≥n que termina la recursi√≥n.
- **Llamada Recursiva:** Una llamada a la misma funci√≥n con un subproblema m√°s peque√±o.

<h4 className="font-medium mt-5">Ejemplo</h4>

**El factorial de un n√∫mero**

El factorial de un n√∫mero
ùëõ (denotado como ùëõ!) se define como el producto de todos los enteros positivos desde 1 hasta ùëõ. Formalmente:

ùëõ!=ùëõ√ó(ùëõ‚àí1)√ó(ùëõ‚àí2)√ó...√ó2√ó1

En la definici√≥n recursiva, esto puede ser escrito como:

ùëõ!=ùëõ√ó(ùëõ‚àí1)!

Con la condici√≥n base:

0!=1

```js copy filename="JavaScript"
function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

En esta implementaci√≥n, la funci√≥n factorial se llama a s√≠ misma con
ùëõ‚àí1 hasta que ùëõ es igual a 0. Cuando ùëõ es 0, la funci√≥n devuelve 1, lo que finaliza la cadena de llamadas recursivas.

<div className="flex justify-center my-5">
  <Image
    src="/assets/img/factorial.png"
    alt="Elemento en HTML"
    width={750}
    height={750}
  />
</div>

**Secuencia de Fibonacci**

La secuencia de Fibonacci es otra serie que puede ser definida recursivamente. Cada n√∫mero en la secuencia es la suma de los dos anteriores. Formalmente:

ùêπ(0)=0
ùêπ(1)=1
ùêπ(ùëõ)=ùêπ(ùëõ‚àí1)+ùêπ(ùëõ‚àí2)

Implementaci√≥n en JavaScript:

```js copy filename="JavaScript"
function fibonacci(n) {
  if (n <= 1) {
    return n;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

En este caso, la funci√≥n fibonacci se llama a s√≠ misma dos veces para calcular los dos n√∫meros anteriores en la secuencia, hasta que alcanza las condiciones base

**Consideraciones sobre Recursi√≥n**

- **Eficiencia:** La recursi√≥n puede ser menos eficiente que la iteraci√≥n en t√©rminos de tiempo y uso de memoria debido a la sobrecarga de las llamadas a funciones.
- **Llamadas anidadas:** En la recursi√≥n, cada llamada a la funci√≥n se apila hasta que se alcanza el caso base. Esto puede llevar a problemas de desbordamiento de pila si la recursi√≥n es demasiado profunda.
- **Problemas adecuados:** La recursi√≥n es ideal para problemas que tienen una estructura repetitiva o que se pueden dividir f√°cilmente en subproblemas m√°s peque√±os.

### Funciones como Primeras Clases

En JavaScript, las funciones son miembros de primera clase, lo que significa que pueden ser tratadas como cualquier otro dato. Esto incluye ser asignadas a variables, pasadas como argumentos a otras funciones, y retornadas desde funciones.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function operacion(func, primero, segundo) {
  return func(primero, segundo);
}

const sumar = function (a, b) {
  return a + b;
};

const resultado = operacion(sumar, 10, 20);
```

En este ejemplo, operacion toma una funci√≥n func y dos argumentos primero y segundo. Luego llama a func con estos argumentos. La funci√≥n sumar se pasa como argumento a operacion.

### Funciones An√≥nimas

Las funciones an√≥nimas, tambi√©n conocidas como funciones lambda, son un tipo de funciones que se declaran sin un nombre y se asignan a una variable. Estas funciones son comunes en JavaScript, especialmente cuando se pasan como argumentos a otras funciones, permitiendo un c√≥digo m√°s conciso y legible.

**¬øQu√© Son las Funciones An√≥nimas?**

Una funci√≥n an√≥nima se declara sin un nombre de funci√≥n y se asigna a una variable. Estas funciones se pueden utilizar haciendo referencia a la variable en la que se almacenan.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Funci√≥n an√≥nima "saludo"
const saludo = function () {
  return "Hola";
};

console.log(saludo); // ∆í () { return 'Hola'; }
console.log(saludo()); // 'Hola'
```

En este ejemplo, la funci√≥n an√≥nima que devuelve "Hola" se asigna a la variable saludo. La funci√≥n puede ser invocada utilizando saludo().

**Expresiones de Funci√≥n Nombradas y An√≥nimas**

Las expresiones de funci√≥n pueden ser nombradas o an√≥nimas. Una expresi√≥n de funci√≥n nombrada incluye un nombre, lo que puede ser √∫til para la depuraci√≥n y la recursi√≥n. En contraste, las funciones an√≥nimas no tienen un nombre expl√≠cito.

<h4 className="font-medium mt-5">Ejemplo de Expresi√≥n de Funci√≥n Nombrada</h4>

```js copy filename="JavaScript"
const factorial = function fact(n) {
  return n <= 1 ? 1 : n * fact(n - 1);
};
console.log(factorial(5)); // 120
```

En este ejemplo, fact es el nombre de la funci√≥n utilizado dentro de la funci√≥n para llamarse a s√≠ misma recursivamente. La funci√≥n se asigna a la variable factorial.

### Callbacks

En JavaScript, un callback es una funci√≥n que se pasa como argumento a otra funci√≥n y se ejecuta dentro de esa funci√≥n externa. Los callbacks permiten que una funci√≥n tome decisiones o ejecute tareas adicionales que no se conocen hasta que se llama a la funci√≥n externa. Este concepto es fundamental para la programaci√≥n as√≠ncrona, aunque tambi√©n se usa en contextos s√≠ncronos.

Imagina que una funci√≥n es como un chef que cocina un plato. Un callback ser√≠a como una receta espec√≠fica que el chef puede seguir en alg√∫n momento durante la preparaci√≥n del plato. La receta puede cambiar dependiendo de qu√© plato el chef quiera cocinar.

**¬øPor Qu√© Usar Callbacks?**

Los callbacks son esenciales porque:

- **Promueven la reutilizaci√≥n del c√≥digo:** Podemos crear funciones gen√©ricas que pueden ser configuradas o extendidas con callbacks.
- **Facilitan la programaci√≥n as√≠ncrona:** Permiten que el c√≥digo responda a eventos sin bloquear el flujo principal del programa.
- **Aumentan la flexibilidad:** Las funciones pueden aceptar diferentes comportamientos a trav√©s de callbacks.

**Callbacks S√≠ncronos**

Un callback s√≠ncrono es un callback que se ejecuta inmediatamente dentro de la funci√≥n que lo recibe, respetando el flujo natural del c√≥digo. Esto significa que el callback se ejecuta tan pronto como se llega a su punto de invocaci√≥n en la secuencia del c√≥digo.

<h4 className="font-medium mt-5">Ejemplo</h4>

Imaginemos que tenemos una funci√≥n que simplemente imprime un mensaje, y otra funci√≥n que toma una funci√≥n como argumento y la ejecuta. Aqu√≠ hay un ejemplo b√°sico:

```js copy filename="JavaScript"
// Definici√≥n de una funci√≥n callback
const imprimirMensaje = function () {
  console.log("Callback ejecutado.");
};

// Definici√≥n de una funci√≥n que recibe un callback
const ejecutarCallback = function (callback) {
  console.log("Inicio de la funci√≥n principal.");
  callback(); // Aqu√≠ se ejecuta el callback
  console.log("Fin de la funci√≥n principal.");
};

// Llamada a la funci√≥n principal pasando el callback como argumento
ejecutarCallback(imprimirMensaje);
```

En este caso, ejecutarCallback toma imprimirMensaje como argumento y lo ejecuta. La salida ser√°:

```js copy filename="JavaScript"
Inicio de la funci√≥n principal.
Callback ejecutado.
Fin de la funci√≥n principal.
```

Esto muestra que el callback se ejecuta en el lugar donde fue invocado, siguiendo el flujo del c√≥digo.

**Uso de Funciones An√≥nimas como Callbacks**

A veces, los callbacks son funciones an√≥nimas, lo que significa que se definen en el momento de pasarlas como argumentos y no tienen un nombre espec√≠fico. Esto es √∫til para tareas r√°pidas y espec√≠ficas:

```js copy filename="JavaScript"
const ejecutarCallback = function (callback) {
  console.log("Inicio de la funci√≥n principal.");
  callback(); // Se ejecuta el callback
  console.log("Fin de la funci√≥n principal.");
};

// Uso de una funci√≥n an√≥nima como callback
ejecutarCallback(function () {
  console.log("Callback an√≥nimo ejecutado.");
});
```

Aqu√≠, la funci√≥n an√≥nima que imprime "Callback an√≥nimo ejecutado." se pasa directamente como argumento a ejecutarCallback.

- **Aplicaciones y Beneficios de los Callbacks S√≠ncronos**

1. **Modularidad:** Los callbacks permiten dividir el c√≥digo en m√≥dulos m√°s peque√±os y manejables. Cada funci√≥n puede enfocarse en una sola tarea, haciendo el c√≥digo m√°s claro y f√°cil de mantener.

```js copy filename="JavaScript"
const validarUsuario = function (usuario, callback) {
  if (usuario.edad >= 18) {
    callback(true);
  } else {
    callback(false);
  }
};

const mostrarResultado = function (esValido) {
  if (esValido) {
    console.log("El usuario es v√°lido.");
  } else {
    console.log("El usuario no es v√°lido.");
  }
};

const usuario = { nombre: "Carlos", edad: 20 };
validarUsuario(usuario, mostrarResultado);
```

En este ejemplo, validarUsuario toma un objeto usuario y una funci√≥n callback (mostrarResultado). Dependiendo de la edad del usuario, la funci√≥n callback se invoca con true o false.

2. **Flexibilidad:** Las funciones pueden comportarse de manera diferente seg√∫n el callback que se les pase. Esto permite que una sola funci√≥n realice m√∫ltiples tareas basadas en las necesidades del momento.

3. **Reutilizaci√≥n del C√≥digo:** Los callbacks permiten reutilizar funciones en diferentes contextos sin necesidad de duplicar el c√≥digo.

**Callbacks As√≠ncronos**

Los callbacks as√≠ncronos son una herramienta fundamental en JavaScript, especialmente cuando se trata de manejar operaciones que no se completan instant√°neamente. Estas operaciones pueden incluir solicitudes de red, temporizadores, o cualquier otra tarea que deba realizarse fuera del flujo normal de ejecuci√≥n. A continuaci√≥n, se presenta una definici√≥n completa de los callbacks as√≠ncronos, detallando su funcionamiento, importancia y c√≥mo se utilizan en el contexto de JavaScript.

Un callback as√≠ncrono es una funci√≥n que se pasa como argumento a otra funci√≥n y que se ejecuta despu√©s de que se haya completado una operaci√≥n as√≠ncrona. A diferencia de los callbacks s√≠ncronos, los callbacks as√≠ncronos no se ejecutan inmediatamente despu√©s de ser llamados. En su lugar, se programan para ejecutarse en el futuro, una vez que la operaci√≥n as√≠ncrona haya finalizado.

- **Importancia de los Callbacks As√≠ncronos**

1. **Manejo de Tareas As√≠ncronas:** Permiten que las tareas que toman tiempo, como las solicitudes HTTP, las operaciones de E/S (entrada/salida) y los temporizadores, no bloqueen el hilo principal de ejecuci√≥n.
2. **Interactividad del Usuario:** Mejoran la experiencia del usuario al permitir que la interfaz siga respondiendo mientras se realizan operaciones de fondo.
3. **Eficiencia:** Ayudan a aprovechar mejor los recursos del sistema al permitir que m√∫ltiples operaciones se realicen en paralelo.

- **Funcionamiento de los Callbacks As√≠ncronos**

Cuando se invoca una operaci√≥n as√≠ncrona, se pasa un callback que se ejecutar√° una vez que la operaci√≥n haya terminado. Durante el tiempo en que la operaci√≥n as√≠ncrona est√° en progreso, el motor de JavaScript puede continuar ejecutando otras instrucciones. Una vez que la operaci√≥n finaliza, el callback se coloca en la cola de tareas (event loop) y se ejecuta cuando el hilo principal est√° libre.

**Funciones setTimeout y setInterval**

Las funciones setTimeout y setInterval son ejemplos comunes de c√≥mo se manejan los callbacks as√≠ncronos en JavaScript. Ambas funciones permiten ejecutar c√≥digo despu√©s de un cierto per√≠odo de tiempo, pero difieren en su comportamiento:

- **setTimeout**

La funci√≥n setTimeout se usa cuando se desea realizar una acci√≥n despu√©s de un retraso espec√≠fico. Toma dos argumentos: una funci√≥n de callback y el tiempo en milisegundos despu√©s del cual se debe ejecutar el callback.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function mostrarMensaje() {
  console.log("Este mensaje aparece despu√©s de 2 segundos");
}

setTimeout(mostrarMensaje, 2000);
console.log("Este mensaje aparece inmediatamente");
```

<h4 className="font-medium mt-5">Salida</h4>

```js copy filename="JavaScript"
Este mensaje aparece inmediatamente
Este mensaje aparece despu√©s de 2 segundos
```

En este ejemplo, mostrarMensaje se ejecuta despu√©s de un retraso de 2000 milisegundos (2 segundos). Mientras tanto, el mensaje "Este mensaje aparece inmediatamente" se imprime sin esperar.

- **setInterval**

La funci√≥n setInterval ejecuta una funci√≥n repetidamente a intervalos regulares. Toma dos argumentos: una funci√≥n de callback y el intervalo de tiempo en milisegundos entre cada ejecuci√≥n del callback.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function mostrarHora() {
  console.log(new Date().toLocaleTimeString());
}

setInterval(mostrarHora, 1000);
```

En este ejemplo, mostrarHora se ejecutar√° cada 1000 milisegundos (1 segundo), mostrando la hora actual en la consola.

**La Evoluci√≥n de los Callbacks en JavaScript**

En los primeros d√≠as de JavaScript, los callbacks eran la principal forma de manejar operaciones as√≠ncronas. Sin embargo, a medida que el lenguaje y las aplicaciones han evolucionado, se han desarrollado nuevas herramientas y t√©cnicas para mejorar la gesti√≥n de la asincron√≠a, reducir la complejidad y mejorar la legibilidad del c√≥digo. Vamos a explorar por qu√© los callbacks han ca√≠do en desuso en favor de estas nuevas herramientas y profundizar en el tema del "callback hell".

- **¬øPor Qu√© Ya No Son Recomendables los Callbacks?**

1. **Complejidad y Legibilidad:** El uso intensivo de callbacks puede llevar a un c√≥digo que es dif√≠cil de leer y mantener. A medida que las funciones se anidan unas dentro de otras, el c√≥digo se desplaza hacia la derecha, creando una estructura piramidal conocida como "callback hell".

El "callback hell" es un t√©rmino que se refiere a la situaci√≥n en la que se anidan m√∫ltiples callbacks unos dentro de otros, creando un c√≥digo dif√≠cil de leer y mantener. Veamos un ejemplo t√≠pico de callback hell:

```js copy filename="JavaScript"
doSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doAnotherThing(newResult, function (finalResult) {
      console.log(finalResult);
    });
  });
});
```

A medida que se anidan m√°s y m√°s callbacks, el c√≥digo se vuelve m√°s profundo y dif√≠cil de seguir. Esto no solo afecta la legibilidad, sino que tambi√©n complica el manejo de errores y la l√≥gica de flujo.

2. **Manejo de Errores:** Los callbacks pueden complicar el manejo de errores. Cada callback debe incluir su propia l√≥gica de manejo de errores, lo que puede resultar en duplicaci√≥n de c√≥digo y potenciales omisiones.

3. **Encadenamiento y Composici√≥n:** Los callbacks no se prestan bien a la composici√≥n y el encadenamiento de operaciones as√≠ncronas. Cada nueva operaci√≥n as√≠ncrona requiere un nuevo nivel de anidamiento, lo que aumenta la complejidad del c√≥digo.

4. **Promesas y Async/Await:** Las promesas y la sintaxis async/await han sido introducidas en JavaScript para resolver estos problemas. Ofrecen una forma m√°s clara y manejable de manejar la asincron√≠a, con mejor soporte para el manejo de errores y una estructura de c√≥digo m√°s lineal y legible.

### Funciones Autoejecutables (IIFE)

Las funciones autoejecutables, conocidas como IIFE (Immediately Invoked Function Expressions), son funciones que se ejecutan inmediatamente despu√©s de ser definidas. Estas funciones son √∫tiles para crear un √°mbito l√©xico independiente, evitando la contaminaci√≥n del √°mbito global y proporcionando un encapsulamiento de variables y l√≥gica.

\*\*Sintaxis B√°sica:

```js copy filename="JavaScript"
(function () {
  console.log("Esta es una funci√≥n autoejecutable");
})();
```

En este ejemplo, la funci√≥n an√≥nima est√° encerrada entre par√©ntesis y seguida por (), lo que hace que se ejecute inmediatamente despu√©s de ser creada. Esto permite que todo el c√≥digo dentro de la funci√≥n permanezca en un √°mbito separado del √°mbito global.

**IIFE con Par√°metros:**

Las IIFE tambi√©n pueden aceptar par√°metros, permitiendo pasar valores a la funci√≥n en el momento de su ejecuci√≥n.

```js copy filename="JavaScript"
(function (nombre) {
  console.log(`¬°Hola, ${nombre}!`);
})("Pepue");
```

En este ejemplo, la funci√≥n autoejecutable recibe un par√°metro nombre y lo utiliza para mostrar un saludo personalizado.

**Devoluci√≥n de Valores desde una IIFE**

Si una IIFE devuelve un valor, este valor puede ser almacenado en una variable para su uso posterior.

```js copy filename="JavaScript"
const mensaje = (function (nombre) {
  return `¬°Hola, ${nombre}!`;
})("Pepue");

console.log(mensaje); // ¬°Hola, Pepue!
```

Aqu√≠, la variable mensaje almacena el valor devuelto por la funci√≥n autoejecutable, que en este caso es un saludo personalizado.

### Clausuras (Closures)

En JavaScript, una clausura se define como una funci√≥n que "encierra" variables en su propio √°mbito y que pueden continuar existiendo incluso despu√©s de que la funci√≥n haya terminado de ejecutarse. Esto significa que una clausura retiene una referencia al √°mbito en el que fue creada, lo que le permite acceder a esas variables incluso despu√©s de que el contexto en el que se cre√≥ haya finalizado.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos el siguiente ejemplo para entender c√≥mo funcionan las clausuras:

```js copy filename="JavaScript"
function crearContador() {
  let contador = 0;
  return function incrementar() {
    contador++;
    return contador;
  };
}

const contador1 = crearContador();
console.log(contador1()); // 1
console.log(contador1()); // 2

const contador2 = crearContador();
console.log(contador2()); // 1
console.log(contador2()); // 2
```

En este ejemplo:

- \*\*La funci√≥n crearContador define una variable local contador y devuelve una funci√≥n incrementar que incrementa y devuelve el valor de contador.
- La funci√≥n crearContador se ejecuta dos veces, creando dos instancias diferentes de la clausura incrementar.
- Cada instancia de incrementar tiene su propio √°mbito cerrado sobre la variable contador.

**√Åmbitos y Clausuras**

Una clausura en JavaScript retiene referencias al √°mbito en el que fue creada, no solo a las variables que estaban en ese √°mbito en ese momento. Esto significa que si las variables en el √°mbito cerrado cambian, las clausuras que retienen referencias a ese √°mbito ver√°n esos cambios.

```js copy filename="JavaScript"
function crearSaludador(saludo) {
  return function (nombre) {
    console.log(`${saludo}, ${nombre}`);
  };
}

const saludarHola = crearSaludador("Hola");
const saludarAdios = crearSaludador("Adi√≥s");

saludarHola("Pepue"); // Hola, Pepue
saludarAdios("Pepue"); // Adi√≥s, Pepue
```

En este ejemplo:

- La funci√≥n crearSaludador toma un argumento saludo y devuelve una nueva funci√≥n que toma un argumento nombre.
- Las funciones saludarHola y saludarAdios son clausuras que retienen una referencia a sus respectivos saludos.

**Clausuras y Variables Privadas**

Las clausuras tambi√©n son √∫tiles para crear variables privadas. Dado que las variables definidas dentro de una funci√≥n no son accesibles desde fuera de esa funci√≥n, las clausuras pueden utilizarse para encapsular datos.

```js copy filename="JavaScript"
function crearContador() {
  let contador = 0;
  return {
    incrementar: function () {
      contador++;
      return contador;
    },
    decrementar: function () {
      contador--;
      return contador;
    },
    obtenerValor: function () {
      return contador;
    },
  };
}

const contador = crearContador();
console.log(contador.incrementar()); // 1
console.log(contador.incrementar()); // 2
console.log(contador.decrementar()); // 1
console.log(contador.obtenerValor()); // 1
```

En este ejemplo:

- La funci√≥n crearContador devuelve un objeto con m√©todos que manipulan la variable contador.
- La variable contador no es accesible directamente desde fuera de la funci√≥n, proporcionando una forma de encapsulaci√≥n.

**Beneficios y Usos de las Clausuras**

- Encapsulaci√≥n de Datos: Permiten crear variables privadas.
- Mantenimiento del Estado: Son √∫tiles para funciones que necesitan recordar el estado entre ejecuciones.
- Callbacks y Eventos: Se utilizan ampliamente en programaci√≥n asincr√≥nica y manejo de eventos.

**Consideraciones sobre el Uso de Clausuras**

- **Consumo de Memoria:** Las clausuras pueden consumir m√°s memoria que las funciones normales porque retienen referencias a su √°mbito.
- **Posibles Problemas de Rendimiento:** En aplicaciones de alto rendimiento, es importante gestionar correctamente las clausuras para evitar problemas de rendimiento y fugas de memoria.

### Funciones Flecha (Arrow Functions)

Las Arrow functions, tambi√©n conocidas como funciones flecha o "fat arrow functions", son una sintaxis m√°s concisa para escribir funciones en JavaScript introducida en ECMAScript 6 (ES6). Estas funciones aportan varias ventajas que facilitan la escritura de c√≥digo m√°s limpio y comprensible.

**Definici√≥n B√°sica**

Una funci√≥n flecha se define utilizando la sintaxis =>, eliminando la necesidad de la palabra clave function. Aqu√≠ tienes un ejemplo b√°sico comparando una funci√≥n tradicional con una funci√≥n flecha:

```js copy filename="JavaScript"
// Funci√≥n tradicional
const suma = function (a, b) {
  return a + b;
};

// Funci√≥n flecha
const sumaFlecha = (a, b) => {
  return a + b;
};
```

**Sintaxis Simplificada**

Las funciones flecha permiten simplificar a√∫n m√°s la sintaxis cuando el cuerpo de la funci√≥n contiene una sola expresi√≥n. En este caso, se pueden omitir las llaves ({}) y la palabra clave return. La expresi√≥n se eval√∫a y su resultado se devuelve autom√°ticamente.

```js copy filename="JavaScript"
const sumaFlechaSimple = (a, b) => a + b;
```

Esto hace que las funciones flecha sean especialmente √∫tiles para operaciones simples y r√°pidas.

**Par√°metros en Funciones Flecha**

Dependiendo del n√∫mero de par√°metros, la sintaxis de las funciones flecha puede variar:

1. **Sin Par√°metros**

Cuando una funci√≥n flecha no tiene par√°metros, se utilizan par√©ntesis vac√≠os:

```js copy filename="JavaScript"
const saludar = () => "Hola";
```

2. **Un Solo Par√°metro**

Si la funci√≥n flecha tiene un solo par√°metro, se pueden omitir los par√©ntesis:

```js copy filename="JavaScript"
const cuadrado = (n) => n * n;
```

3. **M√∫ltiples Par√°metros**

Para funciones con m√∫ltiples par√°metros, los par√©ntesis son necesarios:

```js copy filename="JavaScript"
const multiplicar = (a, b) => a * b;
```

**Retorno de Valores**

- **Funciones de Una Sola L√≠nea**

En funciones flecha con una sola l√≠nea de c√≥digo, el return se a√±ade impl√≠citamente. Es decir, no es necesario escribir return porque el resultado de esa √∫nica expresi√≥n se devuelve autom√°ticamente.

```js copy filename="JavaScript"
const sumaFlechaSimple = (a, b) => a + b; // Devuelve a + b autom√°ticamente
```

- **Funciones con M√∫ltiples L√≠neas**

En funciones flecha con m√∫ltiples l√≠neas de c√≥digo, es necesario usar llaves {} y la palabra clave return para devolver un valor.

```js copy filename="JavaScript"
const sumaCompleja = (a, b) => {
  const resultado = a + b;
  return resultado; // Necesitamos return aqu√≠
};
```

**Limitaciones de las Funciones Flecha**

- **Sin Binding de arguments**

Las funciones flecha no tienen la palabra clave arguments, lo que significa que no puedes acceder a los argumentos de la funci√≥n como lo har√≠as en una funci√≥n tradicional. Si necesitas acceder a arguments, puedes usar el operador rest (...).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const sumarTodo = (...args) => args.reduce((acc, curr) => acc + curr, 0);
```

### this en JavaScript

En JavaScript, la palabra clave this puede ser un concepto complicado debido a su comportamiento dependiente del contexto. Para entender completamente c√≥mo funciona this, es importante conocer el √°mbito l√©xico y las diferentes maneras en que puede ser vinculado (binding) a trav√©s de varias t√©cnicas, como el uso de funciones flecha (arrow functions) y la instancia de objetos con new.

**this en JavaScript**

La palabra clave this se refiere a un contexto de ejecuci√≥n particular. El valor de this depende de c√≥mo se invoque la funci√≥n en la que se usa. Este contexto cambiante de this puede ser tanto una ventaja como una fuente de confusi√≥n.

**Vinculaci√≥n (Binding)**

La vinculaci√≥n de this ayuda a asociar los identificadores (variables, nombres de funciones) con el contexto de ejecuci√≥n actual. Existen varios tipos de vinculaciones:

1. **Vinculaci√≥n L√©xica (Lexical Binding) con Arrow Functions**

Las arrow functions, introducidas en ECMAScript 6 (ES6), no tienen su propio this. En cambio, heredan this del contexto en el que fueron definidas. Este comportamiento se llama vinculaci√≥n l√©xica.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
class Persona {
  constructor(nombre) {
    this.nombre = nombre;
  }

  saludar() {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  }

  retrasarSaludo() {
    setTimeout(() => {
      console.log(`Hola, mi nombre es ${this.nombre}`);
    }, 1000);
  }
}

const persona = new Persona("Juan");
persona.saludar(); // Hola, mi nombre es Juan
persona.retrasarSaludo(); // Hola, mi nombre es Juan (despu√©s de 1 segundo)
```

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">1. ¬øQu√© es una funci√≥n an√≥nima?</h4>

<p className="my-2">a) Una funci√≥n sin par√°metros.</p>
<p>b) Una funci√≥n sin cuerpo.</p>
<p className="my-2">c) Una funci√≥n sin nombre.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Una funci√≥n sin nombre.</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© hace la palabra clave return en una funci√≥n?
</h4>

<p className="my-2">a) Finaliza la funci√≥n y devuelve un valor.</p>
<p>b) Declara una variable local.</p>
<p className="my-2">c) Llama a otra funci√≥n.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      a) Finaliza la funci√≥n y devuelve un valor.
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øCu√°l es la sintaxis correcta para una arrow function que suma dos n√∫meros?
</h4>

<p className="my-2">a) `const sumar = (a, b) => { return a + b; }`</p>
<p>b) `const sumar = (a, b) => a + b;`</p>
<p className="my-2">c) `const sumar => (a, b) { return a + b; }`</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) `const sumar = (a, b) => a + b;`</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">4. ¬øQu√© es una closure en JavaScript?</h4>

<p className="my-2">a) Una funci√≥n autoejecutable.</p>
<p>b) Una funci√≥n que encapsula variables en su propio √°mbito.</p>
<p className="my-2">c) Una funci√≥n que devuelve otra funci√≥n.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Una funci√≥n que encapsula variables en su propio √°mbito.
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l es el valor de this en una arrow function?
</h4>

<p className="my-2">a) El objeto global.</p>
<p>b) El objeto que invoca la funci√≥n.</p>
<p className="my-2">c) El contexto l√©xico donde se defini√≥.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) El contexto l√©xico donde se defini√≥.</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">6. ¬øQu√© es una funci√≥n autoejecutable?</h4>

<p className="my-2">a) Una funci√≥n que se llama a s√≠ misma.</p>
<p>b) Una funci√≥n que se ejecuta tan pronto como se define.</p>
<p className="my-2">c) Una funci√≥n que se define dentro de otra funci√≥n.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      b) Una funci√≥n que se ejecuta tan pronto como se define.
    </AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øCu√°l de las siguientes opciones es una funci√≥n flecha v√°lida con un solo
  par√°metro?
</h4>

<p className="my-2">a) `(param) => { return param * 2; }`</p>
<p>b) `param => param * 2`</p>
<p className="mt-2">c) `(param) => param * 2`</p>
<p className="my-2">d) Todas las anteriores.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>d) Todas las anteriores.</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">8. ¬øQu√© hace el m√©todo call en JavaScript?</h4>

<p className="my-2">a) Llama a una funci√≥n con un valor espec√≠fico de this.</p>
<p>b) Declara una variable local.</p>
<p className="my-2">c) Crea una nueva funci√≥n.</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      a) Llama a una funci√≥n con un valor espec√≠fico de this.
    </AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øCu√°l es la diferencia entre una funci√≥n declarada y una funci√≥n por
  expresi√≥n?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una funci√≥n declarada utiliza la palabra clave function seguida por el nombre de la funci√≥n y se eleva (hoisted) al comienzo de su contexto de ejecuci√≥n. Una funci√≥n por expresi√≥n es una funci√≥n asignada a una variable y no se eleva.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© es una funci√≥n flecha y c√≥mo se diferencia de una funci√≥n tradicional?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una funci√≥n flecha es una sintaxis m√°s corta para definir funciones utilizando =>. Las funciones flecha no tienen su propio this, arguments, super ni new.target, y su this se define l√©xicamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øQu√© es una closure en JavaScript y para qu√© se usa?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una closure es una funci√≥n que recuerda el √°mbito en el que fue creada, permiti√©ndole acceder a variables de ese √°mbito incluso despu√©s de que la funci√≥n externa haya terminado de ejecutarse. Se usa para encapsular datos y crear funciones con estado.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øC√≥mo se declara y se llama a una funci√≥n autoejecutable?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Una funci√≥n autoejecutable se declara encerrando la funci√≥n en par√©ntesis y a√±adiendo otro par de par√©ntesis al final para ejecutarla inmediatamente. Ejemplo:

      ```js copy filename="JavaScript"
      (function() {
        console.log("Hola, mundo");
      })();
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l es el prop√≥sito del m√©todo .slice() en cadenas de texto?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Extraer una secci√≥n de una cadena y devolverla como una nueva cadena, sin modificar la original.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo puedes dividir una cadena en un array de subcadenas?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .split()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco tanto al inicio
  como al final de una cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trim()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øCu√°l es la diferencia entre .substring() y .substr()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .substring(start, end) devuelve una parte de la cadena entre start y end, mientras que .substr(start, length) devuelve una parte de la cadena desde start y con una longitud espec√≠fica length.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øC√≥mo se puede reemplazar una subcadena en una cadena por otra subcadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .replace()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco al final de una
  cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trimEnd()

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Eliminar espacios en blanco al inicio y al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo   ";
        let trimmedText = text.trim();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Verificar si una cadena contiene una subcadena espec√≠fica.
</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript es divertido";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript es divertido";
        let contains = text.includes("JavaScript");
        console.log(contains); // true
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">3. Convertir una cadena a may√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "hola mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "hola mundo";
        let upperText = text.toUpperCase();
        console.log(upperText); // "HOLA MUNDO"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Reemplazar una subcadena en una cadena por otra subcadena.
</h4>

```js copy filename="JavaScript"
let text = "Me gusta programar en Java";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Me gusta programar en Java";
        let newText = text.replace("Java", "JavaScript");
        console.log(newText); // "Me gusta programar en JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">5. Extraer una parte de una cadena.</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript";
        let part = text.slice(12, 22);
        console.log(part); // "JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  6. Eliminar espacios en blanco al inicio de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo";
        let trimmedText = text.trimStart();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  7. Eliminar espacios en blanco al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Hola Mundo   ";
        let trimmedText = text.trimEnd();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  8. Dividir una cadena en un array de subcadenas.
</h4>

```js copy filename="JavaScript"
let text = "rojo,azul,verde";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "rojo,azul,verde";
        let colors = text.split(",");
        console.log(colors); // ["rojo", "azul", "verde"]
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  9. Obtener el car√°cter en una posici√≥n espec√≠fica de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "JavaScript";
        let char = text.charAt(4);
        console.log(char); // "S"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">10. Convertir una cadena a min√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "HOLA MUNDO";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "HOLA MUNDO";
        let lowerText = text.toLowerCase();
        console.log(lowerText); // "hola mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## Objetos

En JavaScript, un objeto es una colecci√≥n de propiedades, y una propiedad es una asociaci√≥n entre un nombre (o clave) y un valor. Los valores de las propiedades pueden ser de cualquier tipo de datos, incluyendo otros objetos. Los objetos permiten organizar y estructurar datos complejos de manera eficiente y son fundamentales para el desarrollo de aplicaciones en JavaScript.

Los objetos en JavaScript son similares a los registros en otros lenguajes de programaci√≥n, ya que agrupan m√∫ltiples valores (llamados propiedades) bajo un √∫nico nombre. Esta capacidad de agrupar datos relacionados hace que los objetos sean extremadamente √∫tiles para modelar entidades del mundo real y para organizar informaci√≥n de manera estructurada.

Cada objeto puede tener una cantidad arbitraria de propiedades, y estas propiedades pueden ser din√°micamente a√±adidas o eliminadas en cualquier momento. Esta flexibilidad es una de las caracter√≠sticas m√°s poderosas de los objetos en JavaScript.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const coche = {
  marca: "Toyota",
  modelo: "Corolla",
  a√±o: 2021,
};
```

En este ejemplo, el objeto coche tiene tres propiedades: marca, modelo y a√±o, cada una con su correspondiente valor. Este objeto podr√≠a representar un coche en un sistema de gesti√≥n de inventario.

### Declaraci√≥n de un objeto

Existen varias formas de declarar un objeto en JavaScript. Aqu√≠ se presentan las m√°s comunes:

- **Notaci√≥n de objeto literal**

La forma m√°s sencilla y com√∫n de crear un objeto es utilizando la notaci√≥n de objeto literal, que se define mediante llaves {}. La notaci√≥n literal es preferida por su simplicidad y legibilidad.

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  edad: 30,
  ciudad: "Lima",
};
```

En este ejemplo, el objeto persona tiene tres propiedades: nombre, edad y ciudad, cada una con su correspondiente valor. Este objeto podr√≠a representar una persona en una aplicaci√≥n de gesti√≥n de contactos.

- **Utilizando el constructor Object:**

Otra forma de crear un objeto es utilizando el constructor Object. Esta forma es menos com√∫n y generalmente no se recomienda a menos que haya una raz√≥n espec√≠fica para utilizarla.

```js copy filename="JavaScript"
const persona = new Object();
persona.nombre = "Juan";
persona.edad = 30;
persona.ciudad = "Lima";
```

En este ejemplo, se crea un objeto vac√≠o utilizando new Object() y luego se a√±aden las propiedades nombre, edad y ciudad.

- **Creaci√≥n con Object.create()**

Object.create permite crear un nuevo objeto con un objeto prototipo espec√≠fico. Este m√©todo es √∫til cuando se desea crear un objeto que herede propiedades y m√©todos de otro objeto.

```js copy filename="JavaScript"
const prototipoPersona = {
  saludar: function () {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  },
};

const persona = Object.create(prototipoPersona);
persona.nombre = "Juan";
persona.edad = 30;
persona.ciudad = "Lima";
```

En este ejemplo, persona hereda el m√©todo saludar del prototipoPersona. Esto permite utilizar el m√©todo saludar en el objeto persona.

- **Usando funciones constructoras**

Otra forma com√∫n de crear objetos en JavaScript es utilizando funciones constructoras. Estas funciones act√∫an como plantillas para crear objetos con propiedades y m√©todos definidos.

```js copy filename="JavaScript"
function Persona(nombre, edad, ciudad) {
  this.nombre = nombre;
  this.edad = edad;
  this.ciudad = ciudad;
}

const persona1 = new Persona("Juan", 30, "Lima");
const persona2 = new Persona("Ana", 25, "Cusco");
```

En este ejemplo, Persona es una funci√≥n constructora que define las propiedades nombre, edad y ciudad. Se crean dos instancias del objeto Persona, persona1 y persona2, cada una con sus propios valores para las propiedades.

### Propiedades de un objeto

Las propiedades de un objeto son pares clave-valor. La clave es una cadena de texto que identifica la propiedad, y el valor puede ser cualquier tipo de datos, incluyendo n√∫meros, cadenas, funciones, otros objetos, etc. Esta flexibilidad permite almacenar datos complejos y relacionados de manera organizada.

1. **Acceder a las propiedades**

Se puede acceder a las propiedades de un objeto utilizando la notaci√≥n de punto (.) o la notaci√≥n de corchetes ([]).

- **Notaci√≥n de punto:**

```js copy filename="JavaScript"
console.log(persona.nombre); // Acceso con notaci√≥n de punto
```

- **Notaci√≥n de corchetes:**

```js copy filename="JavaScript"
console.log(persona["edad"]); // Acceso con notaci√≥n de corchetes
```

La notaci√≥n de punto es m√°s com√∫n y preferida por su simplicidad y legibilidad. Sin embargo, la notaci√≥n de corchetes es √∫til en situaciones donde la clave de la propiedad es din√°mica o contiene caracteres que no son v√°lidos en un identificador de JavaScript, como espacios o caracteres especiales.

<h4 className="font-medium mt-5">
  Ejemplo de acceso a propiedades con notaci√≥n de corchetes
</h4>

```js copy filename="JavaScript"
const libro = {
  titulo: "El Quijote",
  autor: "Miguel de Cervantes",
  "a√±o de publicaci√≥n": 1605,
};

console.log(libro["titulo"]); // El Quijote
console.log(libro["a√±o de publicaci√≥n"]); // 1605
```

En este ejemplo, se utiliza la notaci√≥n de corchetes para acceder a las propiedades titulo y a√±o de publicaci√≥n, ya que a√±o de publicaci√≥n contiene espacios, y con la notaci√≥n de punto no podr√≠amos acceder a este, de hecho si lo hici√©ramos, este nos arrojar√≠a un error.

2. **Modificar propiedades**

Las propiedades de un objeto se pueden modificar simplemente asignando un nuevo valor a la propiedad existente.

```js copy filename="JavaScript"
persona.nombre = "Carlos";
persona["edad"] = 35;
```

Modificar las propiedades de un objeto es una operaci√≥n fundamental en JavaScript. Permite actualizar los datos almacenados en el objeto sin necesidad de crear un nuevo objeto. Esta operaci√≥n es com√∫n en aplicaciones din√°micas donde los datos cambian frecuentemente.

3. **Eliminar propiedades**

Para eliminar una propiedad de un objeto, se utiliza el operador delete.

```js copy filename="JavaScript"
delete persona.ciudad;
```

Eliminar una propiedad de un objeto es √∫til para liberar memoria o para remover datos que ya no son necesarios. Esta operaci√≥n es importante para mantener el objeto limpio y evitar almacenar informaci√≥n obsoleta o innecesaria.

4. **A√±adir propiedades**

Se pueden a√±adir nuevas propiedades a un objeto en cualquier momento despu√©s de su creaci√≥n, utilizando la notaci√≥n de punto o de corchetes.

- **A√±adir propiedades con notaci√≥n de punto:**

```js copy filename="JavaScript"
persona.profesion = "Ingeniero";
```

- **A√±adir propiedades con notaci√≥n de corchetes:**

```js copy filename="JavaScript"
persona["nacionalidad"] = "Peruana";
```

A√±adir propiedades a un objeto permite extender su funcionalidad y almacenar nueva informaci√≥n sin modificar la estructura original del objeto. Esta operaci√≥n es muy √∫til en aplicaciones donde los datos pueden evolucionar con el tiempo.

5. **Acceso din√°mico a propiedades**

En algunos casos, es posible que necesitemos acceder a las propiedades de un objeto de manera din√°mica, es decir, utilizando una variable para especificar el nombre de la propiedad.

```js copy filename="JavaScript"
let propiedad = "nombre";
console.log(persona[propiedad]); // Muestra "Carlos"
```

Este enfoque es √∫til cuando los nombres de las propiedades no son conocidos hasta el tiempo de ejecuci√≥n. Permite crear programas m√°s flexibles y adaptables, ya que el acceso a las propiedades se puede determinar en funci√≥n de condiciones o entradas del usuario.

6. **Propiedades calculadas**

JavaScript permite definir propiedades de objeto con nombres calculados en tiempo de ejecuci√≥n utilizando la sintaxis de corchetes en la definici√≥n del objeto.

```js copy filename="JavaScript"
let propiedad = "edad";
const persona = {
  nombre: "Carlos",
  [propiedad]: 35,
};

console.log(persona.edad); // Muestra 35
```

Esta caracter√≠stica permite una mayor flexibilidad en la creaci√≥n de objetos, especialmente cuando se trabaja con nombres de propiedades din√°micos. Las propiedades calculadas facilitan la generaci√≥n de nombres de propiedades basados en variables u otras expresiones.

7. **Verificaci√≥n de existencia de propiedades**

Antes de acceder a una propiedad, es a menudo √∫til verificar si la propiedad existe en el objeto. Esto se puede hacer utilizando el operador in o el m√©todo hasOwnProperty.

- **Operador in:**

```js copy filename="JavaScript"
if ("profesion" in persona) {
  console.log(persona.profesion);
} else {
  console.log("La propiedad 'profesion' no existe en el objeto.");
}
```

- **M√©todo hasOwnProperty:**

```js copy filename="JavaScript"
if (persona.hasOwnProperty("profesion")) {
  console.log(persona.profesion);
} else {
  console.log("La propiedad 'profesion' no existe en el objeto.");
}
```

Estas t√©cnicas ayudan a evitar errores al intentar acceder a propiedades que pueden no existir en el objeto. Verificar la existencia de propiedades es una buena pr√°ctica para asegurar que el c√≥digo sea robusto y maneje correctamente las situaciones en las que una propiedad no est√© presente.

8. **Enumeraci√≥n de propiedades**

En JavaScript, es posible enumerar todas las propiedades de un objeto utilizando un bucle for...in. Este bucle itera sobre todas las propiedades enumerables del objeto.

```js copy filename="JavaScript"
for (let clave in persona) {
  console.log(`${clave}: ${persona[clave]}`);
}
```

El bucle for...in recorre todas las propiedades enumerables, incluyendo las heredadas. Para enumerar solo las propiedades propias del objeto, se puede combinar con hasOwnProperty.

```js copy filename="JavaScript"
for (let clave in persona) {
  if (persona.hasOwnProperty(clave)) {
    console.log(`${clave}: ${persona[clave]}`);
  }
}
```

Enumerar las propiedades de un objeto es √∫til para inspeccionar y trabajar con todas las propiedades de un objeto de manera din√°mica. Permite iterar sobre las propiedades y realizar operaciones en cada una de ellas, como mostrar sus valores, modificarlas o eliminarlas.

### M√©todos de un objeto

En JavaScript, los m√©todos son funciones que se asocian a los objetos como propiedades. Un m√©todo es una propiedad de un objeto cuyo valor es una funci√≥n. Los m√©todos permiten que los objetos no solo almacenen datos, sino que tambi√©n realicen acciones relacionadas con esos datos.

1. **Definici√≥n de un m√©todo**

Los m√©todos se pueden definir al crear el objeto utilizando la notaci√≥n de objeto literal, o se pueden a√±adir despu√©s de que el objeto haya sido creado.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  saludar: function () {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  },
};

persona.saludar(); // Salida: Hola, mi nombre es Juan
```

En este ejemplo, persona es un objeto que tiene una propiedad saludar, que es una funci√≥n. Esta funci√≥n puede acceder a otras propiedades del objeto utilizando la palabra clave this.

- **A√±adir un m√©todo a un objeto existente**

```js copy filename="JavaScript"
const coche = {
  marca: "Toyota",
  modelo: "Corolla",
};

coche.mostrarDetalles = function () {
  return `${this.marca} ${this.modelo}`;
};

console.log(coche.mostrarDetalles()); // Salida: Toyota Corolla
```

En este ejemplo, se a√±ade el m√©todo mostrarDetalles al objeto coche despu√©s de su creaci√≥n. Este m√©todo devuelve una cadena que incluye la marca y el modelo del coche.

2. **El m√©todo toString()**

El m√©todo toString() es un m√©todo predeterminado de todos los objetos en JavaScript. Este m√©todo devuelve una cadena de texto que representa el objeto. La representaci√≥n predeterminada de toString() para un objeto gen√©rico es [object Object], pero se puede sobrescribir para proporcionar una representaci√≥n m√°s √∫til y espec√≠fica del objeto.

- **Uso del m√©todo toString() por defecto**

```js copy filename="JavaScript"
const objeto = {};
console.log(objeto.toString()); // Salida: [object Object]
```

En este ejemplo, la salida de objeto.toString() es la representaci√≥n gen√©rica [object Object].

- **Sobrescribir el m√©todo toString()**

Para proporcionar una representaci√≥n m√°s √∫til del objeto, se puede sobrescribir el m√©todo toString() dentro del objeto:

```js copy filename="JavaScript"
const coche = {
  marca: "Toyota",
  modelo: "Corolla",
  a√±o: 2021,
  toString: function () {
    return `${this.marca} ${this.modelo} (${this.a√±o})`;
  },
};

console.log(coche.toString()); // Salida: Toyota Corolla (2021)
```

En este ejemplo, el m√©todo toString() se ha sobrescrito para devolver una cadena de texto que incluye la marca, el modelo y el a√±o del coche.

- **Creando nuestro propio toString**

Crear un m√©todo toString() personalizado permite definir c√≥mo se debe representar un objeto en formato de cadena. Esta pr√°ctica es √∫til para la depuraci√≥n y la presentaci√≥n de objetos en interfaces de usuario.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que queremos crear un objeto persona que incluya un m√©todo toString() personalizado:

```js copy filename="JavaScript"
const persona = {
  nombre: "Ana",
  apellido: "G√≥mez",
  edad: 28,
  ciudad: "Lima",
  toString: function () {
    return `${this.nombre} ${this.apellido}, ${this.edad} a√±os, vive en ${this.ciudad}`;
  },
};

console.log(persona.toString()); // Salida: Ana G√≥mez, 28 a√±os, vive en Lima
```

En este ejemplo, el m√©todo toString() devuelve una cadena de texto que incluye el nombre, apellido, edad y ciudad de la persona, proporcionando una representaci√≥n clara y concisa del objeto.

<h4 className="font-medium mt-5">Otro ejemplo</h4>

Supongamos que tenemos un objeto curso que representa un curso acad√©mico:

```js copy filename="JavaScript"
const curso = {
  titulo: "Introducci√≥n a la Programaci√≥n",
  profesor: "Carlos P√©rez",
  duracion: "10 semanas",
  estudiantes: ["Juan", "Ana", "Luis", "Mar√≠a"],
  toString: function () {
    return `Curso: ${this.titulo}\nProfesor: ${this.profesor}\nDuraci√≥n: ${this.duracion}\nEstudiantes: ${this.estudiantes.join(", ")}`;
  },
};

console.log(curso.toString());
/*
Curso: Introducci√≥n a la Programaci√≥n
Profesor: Carlos P√©rez
Duraci√≥n: 10 semanas
Estudiantes: Juan, Ana, Luis, Mar√≠a
*/
```

En este ejemplo, el m√©todo toString() del objeto curso devuelve una cadena de texto que incluye el t√≠tulo del curso, el nombre del profesor, la duraci√≥n y la lista de estudiantes, proporcionando una visi√≥n detallada del curso.

- **Consideraciones adicionales sobre toString()**

El m√©todo toString() es invocado autom√°ticamente en ciertos contextos, como cuando se concatena un objeto con una cadena de texto, o cuando se pasa un objeto a funciones que esperan una cadena de texto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const producto = {
  nombre: "Laptop",
  precio: 1500,
  toString: function () {
    return `${this.nombre} cuesta $${this.precio}`;
  },
};

console.log("Detalles del producto: " + producto); // Salida: Detalles del producto: Laptop cuesta $1500
```

En este ejemplo, el m√©todo toString() del objeto producto se invoca autom√°ticamente cuando el objeto se concatena con una cadena de texto, proporcionando una representaci√≥n legible del objeto.

El m√©todo toString() es una herramienta poderosa para controlar c√≥mo se representa un objeto en formato de cadena. Sobrescribir toString() permite crear representaciones personalizadas que pueden ser √∫tiles para la depuraci√≥n, la presentaci√≥n de datos y la interacci√≥n con usuarios.

### ¬øQu√© es JSON?

JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos que es f√°cil de leer y escribir para los humanos y f√°cil de analizar y generar para las m√°quinas. JSON se basa en una colecci√≥n de pares clave-valor, similar a la sintaxis de los objetos en JavaScript, lo que lo hace especialmente conveniente para los desarrolladores web.

JSON es ampliamente utilizado en aplicaciones web para transmitir datos entre el cliente y el servidor. Su estructura sencilla y su compatibilidad nativa con JavaScript lo convierten en el formato de elecci√≥n para el intercambio de datos en aplicaciones modernas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
{
  "nombre": "Juan",
  "edad": 30,
  "ciudad": "Lima",
  "habilidades": ["JavaScript", "HTML", "CSS"]
}
```

En este ejemplo, tenemos un objeto JSON que representa a una persona con propiedades nombre, edad, ciudad y habilidades. Cada propiedad tiene un valor asociado, que puede ser un n√∫mero, una cadena de texto, un booleano, un objeto o un array.

**Caracter√≠sticas de JSON**

- **Propiedades entrecomilladas:** En JSON, todas las claves de las propiedades deben estar entre comillas dobles.
- **Tipos de datos soportados:** JSON soporta tipos de datos como cadenas de texto, n√∫meros, booleanos, objetos, arrays y null.
- **Compatibilidad:** JSON es independiente del lenguaje, lo que significa que puede ser utilizado en cualquier lenguaje de programaci√≥n que soporte el formato JSON.
- **No admite funciones:** A diferencia de los objetos en JavaScript, JSON no admite funciones como valores de propiedades.

**¬øC√≥mo utilizar JSON?**

JSON se utiliza principalmente para el intercambio de datos entre un cliente y un servidor. En JavaScript, hay dos m√©todos principales para trabajar con JSON:

1. **JSON.stringify():** Convierte un objeto de JavaScript en una cadena JSON.
2. **JSON.parse():** Convierte una cadena JSON en un objeto de JavaScript.

Estos m√©todos permiten convertir datos entre los formatos JSON y JavaScript, lo que facilita la transmisi√≥n y manipulaci√≥n de datos en aplicaciones web.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que tenemos un objeto JavaScript que representa a una persona:

```js copy filename="JavaScript"
const persona = {
  nombre: "Ana",
  edad: 25,
  ciudad: "Cusco",
  habilidades: ["Python", "Django", "JavaScript"],
};
```

Para enviar este objeto a un servidor, necesitamos convertirlo a una cadena JSON utilizando JSON.stringify():

```js copy filename="JavaScript"
const jsonString = JSON.stringify(persona);
console.log(jsonString);
// Salida: {"nombre":"Ana","edad":25,"ciudad":"Cusco","habilidades":["Python","Django","JavaScript"]}
```

Luego, podemos enviar jsonString al servidor como parte de una solicitud HTTP.

1. **Convertir un objeto a JSON**

Para convertir un objeto de JavaScript a una cadena JSON, se utiliza el m√©todo JSON.stringify(). Este m√©todo toma un objeto como argumento y devuelve una cadena JSON.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const persona = {
  nombre: "Ana",
  edad: 25,
  ciudad: "Cusco",
  habilidades: ["Python", "Django", "JavaScript"],
};

const jsonString = JSON.stringify(persona);
console.log(jsonString);
// Salida: {"nombre":"Ana","edad":25,"ciudad":"Cusco","habilidades":["Python","Django","JavaScript"]}
```

En este ejemplo, el objeto persona se convierte en una cadena JSON utilizando JSON.stringify(). La cadena resultante puede ser enviada a un servidor o almacenada para su uso posterior.

- **Filtrado de propiedades al convertir a JSON**

JSON.stringify() tambi√©n permite especificar un array de propiedades que se deben incluir en la cadena JSON resultante. Esto es √∫til para filtrar propiedades innecesarias.

```js copy filename="JavaScript"
const persona = {
  nombre: "Ana",
  edad: 25,
  ciudad: "Cusco",
  habilidades: ["Python", "Django", "JavaScript"],
};

const jsonString = JSON.stringify(persona, ["nombre", "ciudad"]);
console.log(jsonString);
// Salida: {"nombre":"Ana","ciudad":"Cusco"}
```

En este ejemplo, solo las propiedades nombre y ciudad se incluyen en la cadena JSON resultante.

- **Formateo de la salida JSON**

JSON.stringify() tambi√©n permite especificar un n√∫mero de espacios para la indentaci√≥n, lo que facilita la lectura de la salida JSON.

```js copy filename="JavaScript"
const persona = {
  nombre: "Ana",
  edad: 25,
  ciudad: "Cusco",
  habilidades: ["Python", "Django", "JavaScript"],
};

const jsonString = JSON.stringify(persona, null, 2);
console.log(jsonString);
/*
Salida:
{
  "nombre": "Ana",
  "edad": 25,
  "ciudad": "Cusco",
  "habilidades": [
    "Python",
    "Django",
    "JavaScript"
  ]
}
*/
```

En este ejemplo, la salida JSON est√° formateada con una indentaci√≥n de 2 espacios, lo que la hace m√°s legible.

2. **Convertir JSON a objeto**

Para convertir una cadena JSON a un objeto de JavaScript, se utiliza el m√©todo JSON.parse(). Este m√©todo toma una cadena JSON como argumento y devuelve un objeto de JavaScript.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const jsonString =
  '{"nombre":"Ana","edad":25,"ciudad":"Cusco","habilidades":["Python","Django","JavaScript"]}';

const persona = JSON.parse(jsonString);
console.log(persona);
// Salida: {nombre: "Ana", edad: 25, ciudad: "Cusco", habilidades: Array(3)}
```

En este ejemplo, la cadena JSON jsonString se convierte en un objeto de JavaScript utilizando JSON.parse(). El objeto resultante puede ser manipulado como cualquier otro objeto de JavaScript.

- **Manejo de errores al convertir JSON a objeto**

Es importante manejar posibles errores al analizar JSON, ya que una cadena JSON malformada provocar√° un error. Se recomienda envolver JSON.parse() en un bloque try-catch para manejar estos errores de manera adecuada.

```js copy filename="JavaScript"
const jsonString =
  '{"nombre":"Ana","edad":25,"ciudad":"Cusco","habilidades":["Python","Django","JavaScript"]}';

try {
  const persona = JSON.parse(jsonString);
  console.log(persona);
} catch (error) {
  console.error("Error al analizar JSON:", error);
}
```

En este ejemplo, se utiliza un bloque try-catch para manejar posibles errores durante el an√°lisis del JSON.

3. **Leyendo JSON externo**

En aplicaciones web, es com√∫n obtener datos en formato JSON desde un servidor. Para leer JSON externo, se puede utilizar la API Fetch de JavaScript, que proporciona una forma sencilla de hacer solicitudes HTTP.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que tenemos un servidor que devuelve la siguiente respuesta JSON en la URL https://api.example.com/datos:

```js copy filename="JavaScript"
{
  "usuarios": [
    {"nombre": "Juan", "edad": 30},
    {"nombre": "Ana", "edad": 25},
    {"nombre": "Luis", "edad": 28}
  ]
}
```

Podemos leer estos datos en JavaScript utilizando Fetch:

```js copy filename="JavaScript"
fetch("https://api.example.com/datos")
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
    // Salida: {usuarios: Array(3)}
    data.usuarios.forEach((usuario) => {
      console.log(`Nombre: ${usuario.nombre}, Edad: ${usuario.edad}`);
    });
  })
  .catch((error) => console.error("Error:", error));
```

En este ejemplo, se hace una solicitud HTTP GET a https://api.example.com/datos utilizando fetch(). La respuesta se convierte en un objeto JavaScript utilizando response.json(). Luego, se itera sobre la lista de usuarios y se imprime su nombre y edad.

### Desestructuraci√≥n de Objetos

La desestructuraci√≥n de objetos es una caracter√≠stica introducida en ES6 (ECMAScript 2015) que permite extraer valores de un objeto y asignarlos a variables de manera concisa y legible. Esta t√©cnica es especialmente √∫til cuando se trabaja con objetos complejos y se necesita acceder a varias propiedades a la vez.

- **Sintaxis b√°sica de desestructuraci√≥n**

La sintaxis b√°sica para desestructurar un objeto consiste en rodear los nombres de las propiedades con llaves {} y asignarlas a las variables correspondientes.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que tenemos el siguiente objeto:

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  edad: 30,
  ciudad: "Lima",
};

const { nombre, edad, ciudad } = persona;
console.log(nombre); // Juan
console.log(edad); // 30
console.log(ciudad); // Lima
```

En este ejemplo, las propiedades nombre, edad y ciudad del objeto persona se extraen y se asignan a variables con el mismo nombre.

- **Asignar a variables con nombres diferentes**

Si deseas asignar las propiedades del objeto a variables con nombres diferentes, puedes hacerlo utilizando la sintaxis propiedad: nuevoNombre.

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  edad: 30,
  ciudad: "Lima",
};

const { nombre: firstName, edad: age, ciudad: city } = persona;
console.log(firstName); // Juan
console.log(age); // 30
console.log(city); // Lima
```

En este ejemplo, nombre se asigna a la variable firstName, edad a age, y ciudad a city.

- **Valores predeterminados**

Es posible establecer valores predeterminados para las variables en caso de que las propiedades no existan en el objeto. Esto es √∫til para evitar undefined.

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  ciudad: "Lima",
};

const { nombre, edad = 25, ciudad } = persona;
console.log(nombre); // Juan
console.log(edad); // 25 (valor predeterminado)
console.log(ciudad); // Lima
```

En este ejemplo, la variable edad toma el valor predeterminado de 25 porque la propiedad edad no existe en el objeto persona.

### Estructuras Anidadas

Las estructuras anidadas en JavaScript permiten que los objetos y arreglos contengan otros objetos y arreglos en su interior. Esta capacidad es crucial para representar datos complejos y jer√°rquicos de manera organizada.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const empresa = {
  nombre: "TechCorp",
  direccion: {
    calle: "Av. Principal",
    numero: 100,
    ciudad: "Lima",
  },
  empleados: [
    { nombre: "Juan", edad: 30, puesto: "Desarrollador" },
    { nombre: "Ana", edad: 25, puesto: "Dise√±adora" },
    { nombre: "Luis", edad: 28, puesto: "Project Manager" },
  ],
};

console.log(empresa.nombre); // TechCorp
console.log(empresa.direccion.ciudad); // Lima
console.log(empresa.empleados[0].nombre); // Juan
```

En este ejemplo, el objeto empresa contiene un objeto direccion y un arreglo empleados, que a su vez contiene objetos con informaci√≥n sobre los empleados.

- **Accediendo a Estructuras Anidadas**

Para acceder a propiedades de objetos anidados, se utiliza la notaci√≥n de punto.

```js copy filename="JavaScript"
const { direccion } = empresa;
console.log(direccion.calle); // Av. Principal

const {
  direccion: { ciudad },
} = empresa;
console.log(ciudad); // Lima
```

- **Desestructuraci√≥n de propiedades anidadas**

La desestructuraci√≥n de propiedades anidadas facilita el acceso directo a propiedades en niveles m√°s profundos de la estructura del objeto.

```js copy filename="JavaScript"
const {
  empleados: [primerEmpleado, , tercerEmpleado],
} = empresa;
console.log(primerEmpleado.nombre); // Juan
console.log(tercerEmpleado.nombre); // Luis

const {
  empleados: [{ nombre: primerNombre }, { nombre: segundoNombre }],
} = empresa;
console.log(primerNombre); // Juan
console.log(segundoNombre); // Ana
```

En este ejemplo, se extraen directamente los nombres de los empleados del arreglo empleados dentro del objeto empresa.

### Desestructuraci√≥n (rest)

La desestructuraci√≥n con el operador de reposo (rest) permite extraer y agrupar el resto de las propiedades de un objeto o los elementos de un arreglo que no se desestructuran expl√≠citamente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const usuario = {
  nombre: "Carlos",
  edad: 27,
  ciudad: "Arequipa",
  profesion: "Ingeniero",
};

const { nombre, ...resto } = usuario;
console.log(nombre); // Carlos
console.log(resto); // { edad: 27, ciudad: "Arequipa", profesion: "Ingeniero" }
```

Aqu√≠, nombre se extrae del objeto usuario y el resto de las propiedades se agrupan en el objeto resto.

- **Desestructuraci√≥n de arreglos con rest**

```js copy filename="JavaScript"
const numeros = [1, 2, 3, 4, 5];

const [primero, segundo, ...resto] = numeros;
console.log(primero); // 1
console.log(segundo); // 2
console.log(resto); // [3, 4, 5]
```

En este ejemplo, los dos primeros elementos del arreglo numeros se extraen en las variables primero y segundo, y el resto de los elementos se almacenan en el arreglo resto.

- **Par√°metros Desestructurados**

En JavaScript, la desestructuraci√≥n de par√°metros es una t√©cnica que permite extraer propiedades de un objeto directamente en la lista de par√°metros de una funci√≥n. Esta t√©cnica hace que el c√≥digo sea m√°s claro y f√°cil de mantener, ya que puedes trabajar directamente con las propiedades que necesitas en lugar de acceder a ellas a trav√©s del objeto completo.

<h4 className="font-medium mt-5">
  Ejemplo sin Desestructuraci√≥n de Par√°metros
</h4>

Vamos a comenzar con un ejemplo sin usar la desestructuraci√≥n de par√°metros:

```js copy filename="JavaScript"
const user = {
  name: "Sara",
  role: "developer",
  points: 120,
};

function displayInfo(data) {
  const badges = "üèÖ".repeat(data.points / 30);
  return `Name: ${data.name} (${data.role}) ${badges}`;
}

console.log(displayInfo(user)); // "Name: Sara (developer) üèÖüèÖüèÖüèÖ"
```

En este ejemplo, la funci√≥n displayInfo recibe un objeto data y accede a sus propiedades name, role y points utilizando la notaci√≥n de puntos (data.name, data.role, data.points). Si bien esto funciona, puede ser m√°s verboso y menos claro, especialmente cuando se tienen muchas propiedades.

<h4 className="font-medium mt-5">
  Ejemplo con Desestructuraci√≥n de Par√°metros
</h4>

**Par√°metros desestructurados con valores predeterminados**

Ahora vamos a reescribir la funci√≥n displayInfo utilizando la desestructuraci√≥n de par√°metros:

```js copy filename="JavaScript"
const user = {
  name: "Sara",
  role: "developer",
  points: 120,
};

function displayInfo({ name, role, points }) {
  const badges = "üèÖ".repeat(points / 30);
  return `Name: ${name} (${role}) ${badges}`;
}

console.log(displayInfo(user)); // "Name: Sara (developer) üèÖüèÖüèÖüèÖ"
```

En este ejemplo, la funci√≥n displayInfo desestructura directamente las propiedades name, role y points del objeto user en la lista de par√°metros. Esto hace que el c√≥digo dentro de la funci√≥n sea m√°s claro y conciso, ya que puedes trabajar directamente con las variables name, role y points sin tener que referenciar data repetidamente.

- **Par√°metros desestructurados con valores predeterminados**

Puedes proporcionar valores predeterminados para los par√°metros desestructurados en una funci√≥n, lo que asegura que siempre haya un valor disponible, incluso si algunas propiedades est√°n ausentes o el objeto est√° vac√≠o.

```js copy filename="JavaScript"
function crearUsuario({ nombre = "An√≥nimo", edad = 18 } = {}) {
  return `Usuario: ${nombre}, Edad: ${edad}`;
}

console.log(crearUsuario({ nombre: "Pedro" })); // Usuario: Pedro, Edad: 18
console.log(crearUsuario()); // Usuario: An√≥nimo, Edad: 18
```

En este ejemplo, la funci√≥n crearUsuario usa valores predeterminados para nombre y edad, asegurando que siempre haya un valor disponible, incluso si algunas propiedades est√°n ausentes o el objeto est√° vac√≠o.

- **Desestructuraci√≥n de par√°metros anidados**

Puedes desestructurar objetos anidados directamente en la lista de par√°metros de una funci√≥n, lo que simplifica el acceso a propiedades profundas.

```js copy filename="JavaScript"
function mostrarDireccion({ direccion: { calle, numero, ciudad } }) {
  console.log(`Calle: ${calle}`);
  console.log(`N√∫mero: ${numero}`);
  console.log(`Ciudad: ${ciudad}`);
}

const persona = {
  nombre: "Elena",
  direccion: {
    calle: "Av. Central",
    numero: 456,
    ciudad: "Trujillo",
  },
};

mostrarDireccion(persona);
/* Salida:
Calle: Av. Central
N√∫mero: 456
Ciudad: Trujillo
*/
```

En este ejemplo, mostrarDireccion desestructura el objeto direccion anidado dentro del objeto persona directamente en sus par√°metros, extrayendo las propiedades calle, numero y ciudad.

- **Desestructuraci√≥n en funciones con rest**

Puedes combinar la desestructuraci√≥n con el operador rest en funciones para capturar las propiedades restantes del objeto pasado como argumento.

```js copy filename="JavaScript"
function mostrarUsuario({ nombre, edad, ...resto }) {
  console.log(`Nombre: ${nombre}`);
  console.log(`Edad: ${edad}`);
  console.log(`Otros datos:`, resto);
}

const usuario = {
  nombre: "Miguel",
  edad: 35,
  profesion: "Doctor",
  ciudad: "Cusco",
};

mostrarUsuario(usuario);
/* Salida:
Nombre: Miguel
Edad: 35
Otros datos: { profesion: 'Doctor', ciudad: 'Cusco' }
*/
```

En este ejemplo, la funci√≥n mostrarUsuario extrae las propiedades nombre y edad del objeto usuario y agrupa el resto de las propiedades en el objeto resto.

### Clonaci√≥n y Reestructuraci√≥n de Objetos o Elementos

En JavaScript, es com√∫n tener que clonar y reestructurar objetos para evitar la mutaci√≥n de datos originales cuando realizamos cambios en sus copias. Existen varias t√©cnicas para copiar y reestructurar datos, cada una con sus propias ventajas y limitaciones. A continuaci√≥n, se detallan estos conceptos y t√©cnicas para clonaci√≥n y reestructuraci√≥n de objetos en JavaScript.

**Copia por Valor**

La copia por valor se realiza con tipos de datos primitivos como n√∫meros (number), cadenas de texto (string), booleanos (boolean), null, undefined, symbol y bigint. Cuando se copia un valor primitivo, se crea una nueva variable que contiene el mismo valor que la variable original, pero en una ubicaci√≥n de memoria diferente. Cambiar el valor de la nueva variable no afecta al valor de la original.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let originalValue = 42;
let copy = originalValue;

copy = 55;

console.log(originalValue); // 42
console.log(copy); // 55
```

En el ejemplo anterior, copy contiene una copia independiente del valor de originalValue. Modificar copy no cambia originalValue.

**Copia por Referencia**

La copia por referencia se utiliza para los tipos de datos no primitivos, como objetos (object) y arreglos (array). En lugar de crear una copia independiente del objeto, la copia por referencia crea un nuevo enlace que apunta al mismo objeto en memoria. Esto significa que si se modifica la copia, tambi√©n se modifica el original.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let originalObject = { name: "Alice" };
let copy = originalObject;

copy.name = "Bob";

console.log(originalObject.name); // Bob
console.log(copy.name); // Bob
```

En este ejemplo, originalObject y copy apuntan al mismo objeto en memoria. Modificar copy tambi√©n modifica originalObject.

- **Clonaci√≥n Superficial y Profunda**

Clonaci√≥n Superficial (Shallow Clone): Copia solo el primer nivel del objeto. Las propiedades que son objetos o arreglos siguen siendo referencias al objeto original.

Clonaci√≥n Profunda (Deep Clone): Copia todos los niveles del objeto, creando nuevas instancias de todos los objetos y arreglos dentro del objeto original.

**T√©cnicas de Clonaci√≥n**

- **Operador Spread (...)**

El operador spread realiza una clonaci√≥n superficial de un objeto. Esto significa que solo se copia el primer nivel de propiedades del objeto. Si el objeto contiene propiedades que son a su vez objetos o arreglos, estas propiedades seguir√°n apuntando al objeto o arreglo original.

```js copy filename="JavaScript"
let original = {
  name: "Carlos",
  age: 35,
  address: {
    city: "Lima",
    street: "Av. Siempre Viva",
  },
};

let shallowCopy = { ...original };

shallowCopy.name = "Luis";
shallowCopy.address.street = "Av. Los Pinos";

console.log(original.name); // Carlos
console.log(original.address.street); // Av. Los Pinos
console.log(shallowCopy.name); // Luis
console.log(shallowCopy.address.street); // Av. Los Pinos        // Bob
```

- **Object.assign()**

El m√©todo Object.assign() tambi√©n realiza una clonaci√≥n superficial. Este m√©todo copia las propiedades de uno o m√°s objetos a un objeto destino.

```js copy filename="JavaScript"
let original = {
  name: "Carlos",
  age: 35,
  address: { city: "Lima", street: "Av. Siempre Viva" },
};
let shallowCopy = Object.assign({}, original);

shallowCopy.name = "Luis";
shallowCopy.address.street = "Av. Los Pinos";

console.log(original.name); // Carlos
console.log(original.address.street); // Av. Los Pinos
console.log(shallowCopy.name); // Luis
console.log(shallowCopy.address.street); // Av. Los Pinos
```

- **JSON.parse() y JSON.stringify()**

Para realizar una clonaci√≥n profunda, se pueden usar JSON.parse() y JSON.stringify(). Esta t√©cnica convierte el objeto a una cadena JSON y luego lo parsea de nuevo a un nuevo objeto. Sin embargo, esta t√©cnica tiene limitaciones: no copia m√©todos, no copia elementos del DOM, y no puede manejar funciones u objetos no serializables.

```js copy filename="JavaScript"
let original = {
  name: "Carlos",
  age: 35,
  address: {
    city: "Lima",
    street: "Av. Siempre Viva",
  },
  greet: function () {
    console.log("Hello!");
  },
};

let deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.name = "Luis";
deepCopy.address.street = "Av. Los Pinos";

console.log(original.name); // Carlos
console.log(original.address.street); // Av. Siempre Viva
console.log(deepCopy.name); // Luis
console.log(deepCopy.address.street); // Av. Los Pinos
```

- **Librer√≠as como Lodash**

Para clonaciones profundas m√°s complejas, se pueden usar librer√≠as como lodash que proporcionan funciones avanzadas para clonar objetos.

```js copy filename="JavaScript"
const _ = require("lodash");

let original = {
  name: "Carlos",
  age: 35,
  address: {
    city: "Lima",
    street: "Av. Siempre Viva",
  },
  hobbies: ["reading", "travelling"],
};

let deepCopy = _.cloneDeep(original);

deepCopy.name = "Luis";
deepCopy.address.street = "Av. Los Pinos";
deepCopy.hobbies.push("cooking");

console.log(original.name); // Carlos
console.log(original.address.street); // Av. Siempre Viva
console.log(original.hobbies); // ["reading", "travelling"]
console.log(deepCopy.name); // Luis
console.log(deepCopy.address.street); // Av. Los Pinos
console.log(deepCopy.hobbies); // ["reading", "travelling", "cooking"]
```

- **structuredClone()**

JavaScript tambi√©n ofrece el m√©todo structuredClone() para crear copias profundas de objetos y arreglos sin necesidad de usar librer√≠as externas. Este m√©todo es nativo del lenguaje y maneja una gran variedad de tipos de datos, aunque tiene limitaciones similares a JSON.parse() y JSON.stringify() respecto a funciones y elementos del DOM.

```js copy filename="JavaScript"
let original = {
  name: "Carlos",
  age: 35,
  address: {
    city: "Lima",
    street: "Av. Siempre Viva",
  },
  hobbies: ["reading", "travelling"],
};

let deepCopy = structuredClone(original);

deepCopy.name = "Luis";
deepCopy.address.street = "Av. Los Pinos";
deepCopy.hobbies.push("cooking");

console.log(original.name); // Carlos
console.log(original.address.street); // Av. Siempre Viva
console.log(original.hobbies); // ["reading", "travelling"]
console.log(deepCopy.name); // Luis
console.log(deepCopy.address.street); // Av. Los Pinos
console.log(deepCopy.hobbies); // ["reading", "travelling", "cooking"]
```

**Reestructurando Nuevos Objetos**

La reestructuraci√≥n de objetos implica crear nuevos objetos a partir de otros existentes, combinando propiedades y valores de diferentes maneras. Esto se puede hacer f√°cilmente utilizando el operador spread (...), introducido en ES6.

- **Creando un Nuevo Objeto a partir de Otro**

El operador spread permite copiar todas las propiedades de un objeto a otro de manera concisa.

```js copy filename="JavaScript"
const persona = {
  nombre: "Juan",
  edad: 30,
  ciudad: "Lima",
};

const nuevaPersona = { ...persona, profesion: "Ingeniero" };
console.log(nuevaPersona);
// Salida: { nombre: 'Juan', edad: 30, ciudad: 'Lima', profesion: 'Ingeniero' }
```

En este ejemplo, se crea un nuevo objeto nuevaPersona copiando todas las propiedades de persona y a√±adiendo una nueva propiedad profesion.

- **Combinando M√∫ltiples Objetos**

El operador spread tambi√©n se puede utilizar para combinar m√∫ltiples objetos en uno solo.

```js copy filename="JavaScript"
const datosPersonales = {
  nombre: "Ana",
  edad: 28,
};

const direccion = {
  ciudad: "Cusco",
  calle: "Av. Los Incas",
};

const personaCompleta = { ...datosPersonales, ...direccion };
console.log(personaCompleta);
// Salida: { nombre: 'Ana', edad: 28, ciudad: 'Cusco', calle: 'Av. Los Incas' }
```

En este ejemplo, se combinan los objetos datosPersonales y direccion en un nuevo objeto personaCompleta que contiene todas las propiedades de ambos objetos.

- **Reestructuraci√≥n Selectiva**

Tambi√©n es posible seleccionar y combinar propiedades espec√≠ficas de varios objetos para crear un nuevo objeto.

```js copy filename="JavaScript"
const usuario = {
  id: 1,
  nombre: "Carlos",
  edad: 34,
};

const detalles = {
  email: "carlos@example.com",
  ciudad: "Lima",
};

const usuarioDetallado = {
  id: usuario.id,
  nombre: usuario.nombre,
  ...detalles,
};

console.log(usuarioDetallado);
// Salida: { id: 1, nombre: 'Carlos', email: 'carlos@example.com', ciudad: 'Lima' }
```

En este ejemplo, el objeto usuarioDetallado combina propiedades seleccionadas del objeto usuario con todas las propiedades del objeto detalles.

### Iteradores de Objetos

En JavaScript, un iterador es una herramienta que permite recorrer una estructura de datos, elemento por elemento. Los iteradores son fundamentales para manipular y acceder a los datos en objetos de manera eficiente. En JavaScript, los objetos no son iterables por naturaleza como los arrays, pero existen m√©todos que facilitan su iteraci√≥n: Object.keys(), Object.values(), y Object.entries().

**Object.keys(obj)**

Devuelve un array con las claves (propiedades) enumerables de un objeto obj.

- **Uso de Object.keys()**

El m√©todo Object.keys() se utiliza para obtener un array de las claves de un objeto. Este array puede ser iterado utilizando cualquier m√©todo de iteraci√≥n de arrays, como forEach, map, o un bucle for...of.

```js copy filename="JavaScript"
const usuario = {
  nombre: "Carlos",
  edad: 30,
  ciudad: "Lima",
};

const keys = Object.keys(usuario);
console.log(keys); // ["nombre", "edad", "ciudad"]

keys.forEach((key) => {
  console.log(key); // "nombre", "edad", "ciudad"
});
```

**Object.values(obj)**

Devuelve un array con los valores de las propiedades enumerables de un objeto obj.

- **Uso de Object.values()**

El m√©todo Object.values() devuelve un array con los valores de las propiedades de un objeto. Este m√©todo es √∫til para acceder y manipular los valores directamente.

```js copy filename="JavaScript"
const usuario = {
  nombre: "Carlos",
  edad: 30,
  ciudad: "Lima",
};

const values = Object.values(usuario);
console.log(values); // ["Carlos", 30, "Lima"]

values.forEach((value) => {
  console.log(value); // "Carlos", 30, "Lima"
});
```

**Object.entries(obj)**

Devuelve un array de arrays, donde cada sub-array contiene un par [key, value] de las propiedades enumerables de un objeto obj.

- **Uso de Object.entries()**

El m√©todo Object.entries() devuelve un array de pares [clave, valor] del objeto. Cada elemento del array es un array con dos elementos: la clave y el valor correspondientes.

```js copy filename="JavaScript"
const usuario = {
  nombre: "Carlos",
  edad: 30,
  ciudad: "Lima",
};

const entries = Object.entries(usuario);
console.log(entries); // [["nombre", "Carlos"], ["edad", 30], ["ciudad", "Lima"]]

entries.forEach(([key, value]) => {
  console.log(`${key}: ${value}`); // "nombre: Carlos", "edad: 30", "ciudad: Lima"
});
```

**Convertir un Objeto a Array**

Como vimos anteriormente cuando usamos los m√©todos Object.keys(obj), Object.values(obj), y Object.entries(obj), estos autom√°ticamente nos devuelven un array en donde podemos encontrar lo que necesitamos de nuestros objetos, es decir:

- Con el m√©todo Object.keys() obtenemos un de las claves (propiedades, √≠ndices, keys) del objeto.
- Con el m√©todo Object.values() obtenemos un de los valores de las claves anteriores, en el mismo orden.
- Con el m√©todo Object.entries() obtenemos un de entradas. Cada entrada es un del par clave-valor, es decir, la propiedad del objeto original y su valor correspondiente.

**Convertir un Array a Objeto**

Convertir un array a un objeto implica crear un objeto a partir de los elementos del array. Esto es especialmente √∫til cuando se trabaja con datos que se presentan inicialmente como arrays pero se necesita manipularlos como objetos.

- **Convertir un Array de Pares Clave-Valor a un Objeto**

Usando Object.fromEntries(), se puede convertir un array de pares [key, value] en un objeto.

```js copy filename="JavaScript"
const entriesArray = [
  ["nombre", "Carlos"],
  ["edad", 30],
  ["ciudad", "Lima"],
];

const usuario = Object.fromEntries(entriesArray);
console.log(usuario); // { nombre: "Carlos", edad: 30, ciudad: "Lima" }
```

- **Convertir un Array de Valores a un Objeto con Claves Num√©ricas**

```js copy filename="JavaScript"
const values = ["Carlos", 30, "Lima"];

const objeto = {};
values.forEach((value, index) => {
  objeto[index] = value;
});

console.log(objeto); // { 0: "Carlos", 1: 30, 2: "Lima" }
```

- **Convertir un Array de Claves y un Array de Valores a un Objeto**

```js copy filename="JavaScript"
const keys = ["nombre", "edad", "ciudad"];
const values = ["Carlos", 30, "Lima"];

const usuario = {};
keys.forEach((key, index) => {
  usuario[key] = values[index];
});

console.log(usuario); // { nombre: "Carlos", edad: 30, ciudad: "Lima" }
```

### Agrupar Datos por Criterio

En JavaScript, agrupar datos por un criterio espec√≠fico es una tarea com√∫n, especialmente cuando se trabaja con colecciones de objetos. Agrupar permite reorganizar los datos para facilitar su an√°lisis o procesamiento posterior. JavaScript ofrece m√©todos modernos para hacer esto de manera eficiente, como Object.groupBy() y Map.groupBy(), adem√°s de t√©cnicas m√°s tradicionales.

**El M√©todo Object.groupBy()**

El m√©todo Object.groupBy() agrupa los elementos de un array basado en un criterio definido por una funci√≥n de callback. Devuelve un objeto cuyas propiedades son los diferentes grupos creados a partir del criterio.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const users = [
  { name: "Alice", type: "admin", color: "blue" },
  { name: "Bob", type: "user", color: "green" },
  { name: "Charlie", type: "admin", color: "blue" },
  { name: "Dave", type: "user", color: "green" },
];

const usersByType = Object.groupBy(users, (user) => user.type);
console.log(usersByType);
/*
{
  admin: [
    { name: "Alice", type: "admin", color: "blue" },
    { name: "Charlie", type: "admin", color: "blue" }
  ],
  user: [
    { name: "Bob", type: "user", color: "green" },
    { name: "Dave", type: "user", color: "green" }
  ]
}
*/
```

**El M√©todo Map.groupBy()**

El m√©todo Map.groupBy() funciona de manera similar a Object.groupBy(), pero devuelve un Map en lugar de un objeto. Esto puede ser √∫til cuando se necesita la funcionalidad adicional que ofrece Map, como la preservaci√≥n del orden de inserci√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const usersByColor = Map.groupBy(users, (user) => user.color);
console.log(usersByColor);
/*
Map {
  "blue" => [
    { name: "Alice", type: "admin", color: "blue" },
    { name: "Charlie", type: "admin", color: "blue" }
  ],
  "green" => [
    { name: "Bob", type: "user", color: "green" },
    { name: "Dave", type: "user", color: "green" }
  ]
}
*/
```

Para convertir el Map en un objeto, se puede utilizar Object.fromEntries():

```js copy filename="JavaScript"
const usersByColorObj = Object.fromEntries(usersByColor);
console.log(usersByColorObj);
/*
{
  blue: [
    { name: "Alice", type: "admin", color: "blue" },
    { name: "Charlie", type: "admin", color: "blue" }
  ],
  green: [
    { name: "Bob", type: "user", color: "green" },
    { name: "Dave", type: "user", color: "green" }
  ]
}
*/
```

**Agrupar por Criterio (Legacy)**

Antes de la introducci√≥n de estos m√©todos modernos, era com√∫n usar t√©cnicas m√°s manuales para agrupar datos. Una forma tradicional es usar Array.prototype.reduce() para construir el objeto agrupado.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const groupByTypeLegacy = users.reduce((result, user) => {
  const key = user.type;
  if (!result[key]) {
    result[key] = [];
  }
  result[key].push(user);
  return result;
}, {});

console.log(groupByTypeLegacy);
/*
{
  admin: [
    { name: "Alice", type: "admin", color: "blue" },
    { name: "Charlie", type: "admin", color: "blue" }
  ],
  user: [
    { name: "Bob", type: "user", color: "green" },
    { name: "Dave", type: "user", color: "green" }
  ]
}
*/
```

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øQu√© m√©todo de JavaScript devuelve un array con las claves de un objeto?
</h4>

<p className="my-2">a) Object.keys()</p>
<p>b) Object.values()</p>
<p className="my-2">c) Object.entries()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Object.keys()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øCu√°l de los siguientes m√©todos convierte un objeto en un array de pares
  clave-valor?
</h4>

<p className="my-2">a) A. Object.keys()</p>
<p>b) Object.values()</p>
<p className="my-2">c) Object.entries()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Object.entries()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øQu√© m√©todo se utiliza para convertir un array de pares clave-valor en un
  objeto?
</h4>

<p className="my-2">a) Object.fromEntries()</p>
<p>b) Object.entries()</p>
<p className="my-2">c) Object.values()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Object.fromEntries()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øC√≥mo se llama la t√©cnica que crea una nueva variable con el mismo valor
  que otra variable primitiva en una ubicaci√≥n diferente en memoria?
</h4>

<p className="my-2">a) Copia por referencia</p>
<p>b) Copia por valor</p>
<p className="my-2">c) Clonaci√≥n superficial</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Copia por valor</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øQu√© m√©todo moderno de JavaScript permite realizar una clonaci√≥n profunda
  de objetos complejos, incluyendo arrays anidados?
</h4>

<p className="my-2">a) Object.assign()</p>
<p>b) JSON.stringify()</p>
<p className="my-2">c) structuredClone()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) structuredClone()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øCu√°l de los siguientes m√©todos se utiliza para agrupar elementos de un
  array en un objeto basado en un criterio espec√≠fico?
</h4>

<p className="my-2">a) Array.prototype.map()</p>
<p>b) Object.groupBy()</p>
<p className="my-2">c) Object.fromEntries()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Object.groupBy()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øCu√°l es la t√©cnica recomendada para realizar una clonaci√≥n superficial de
  un objeto en JavaScript?
</h4>

<p className="my-2">a) Object.assign()</p>
<p>b) JSON.stringify()</p>
<p className="mt-2">c) structuredClone()</p>
<p className="my-2">d) Array.prototype.map()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Object.assign()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øQu√© m√©todo convierte los valores de un objeto en un array?
</h4>

<p className="my-2">a) Object.keys()</p>
<p>b) Object.values()</p>
<p className="my-2">c) Object.entries()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Object.values()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øQu√© m√©todo devuelve un nuevo objeto creado a partir de un array de pares
  clave-valor?
</h4>

<p className="my-2">a) Object.keys()</p>
<p>b) Object.entries()</p>
<p className="my-2">c) Object.fromEntries()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Object.fromEntries()</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© diferencias existen entre la copia por valor y la copia por referencia
  en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Copia por valor: Se aplica a tipos de datos primitivos (number, string, boolean, null, undefined, symbol, bigint). Se crea una nueva variable con el mismo valor que la original en una ubicaci√≥n diferente en memoria.
      Copia por referencia: Se aplica a tipos de datos complejos (objects, arrays). La nueva variable no tiene su propia copia del valor sino una referencia al mismo objeto en memoria, por lo que cambios en la copia afectan al original y viceversa.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øC√≥mo puedes convertir un objeto en un array de sus claves y valores?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      - Para convertir un objeto en un array de sus claves, se utiliza Object.keys(obj).
      - Para convertir un objeto en un array de sus valores, se utiliza Object.values(obj).
      - Para convertir un objeto en un array de pares clave-valor, se utiliza Object.entries(obj).

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øQu√© es una clonaci√≥n profunda y cu√°ndo se utiliza en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      La clonaci√≥n profunda crea una copia de un objeto y todos sus niveles anidados, de modo que las modificaciones en la copia no afectan al original. Se utiliza cuando se trabaja con objetos complejos y se necesita asegurarse de que no haya referencias compartidas entre la copia y el original.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. Explica c√≥mo Object.fromEntries() se utiliza para convertir un array de
  pares clave-valor en un objeto.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Object.fromEntries() toma un array de pares clave-valor y devuelve un nuevo objeto. Cada sub-array debe contener exactamente dos elementos: la clave y el valor. Este m√©todo es √∫til para reconstruir objetos a partir de datos transformados o manipulados.


    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l es la diferencia principal entre Object.groupBy() y Map.groupBy()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Object.groupBy() devuelve un objeto con los elementos agrupados, mientras que Map.groupBy() devuelve un Map. Map permite usar claves de cualquier tipo y preserva el orden de inserci√≥n, lo cual es √∫til para ciertos tipos de operaciones y accesos m√°s flexibles.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo puedes usar Object.assign() para crear una copia superficial de un
  objeto?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Object.assign() se puede usar para crear una copia superficial de un objeto combinando el objeto original con un nuevo objeto vac√≠o: const copia = Object.assign({}, original). Este m√©todo copia solo el primer nivel de propiedades del objeto.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© hace el m√©todo Object.entries() y cu√°ndo es √∫til?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Object.entries() devuelve un array de pares clave-valor del objeto, √∫til para iterar sobre las propiedades y valores del objeto utilizando m√©todos de array como forEach, map, etc.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. Describe un caso de uso para structuredClone().
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      structuredClone() se usa para realizar una clonaci√≥n profunda de un objeto complejo, como un objeto que contiene otros objetos o arrays anidados. Es √∫til cuando se necesita una copia completamente independiente del original para evitar efectos colaterales no deseados.

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">1. Clonar un Objeto Superficialmente:</h4>

Crea una funci√≥n que tome un objeto y devuelva una copia superficial de ese objeto.

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function clonSuperficial(obj) {
          return Object.assign({}, obj);
        }

        const original = { a: 1, b: 2 };
        const copia = clonSuperficial(original);
        console.log(copia); // { a: 1, b: 2 }
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">2. Clonar un Objeto Profundamente</h4>

Crea una funci√≥n que tome un objeto y devuelva una copia profunda de ese objeto.

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function clonProfundo(obj) {
          return JSON.parse(JSON.stringify(obj));
        }

        const original = { a: 1, b: { c: 2 } };
        const copia = clonProfundo(original);
        copia.b.c = 3;
        console.log(original.b.c); // 2
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  3. Convertir un Objeto a un Array de Pares Clave-Valor
</h4>

Crea una funci√≥n que tome un objeto y devuelva un array de pares clave-valor.

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function objetoAArray(obj) {
          return Object.entries(obj);
        }

        const usuario = { nombre: "Ana", edad: 25 };
        console.log(objetoAArray(usuario)); // [["nombre", "Ana"], ["edad", 25]]
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Convertir un Array de Pares Clave-Valor a un Objeto
</h4>

Crea una funci√≥n que tome un array de pares clave-valor y devuelva un objeto.

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function arrayAObjeto(entries) {
          return Object.fromEntries(entries);
        }

        const entries = [["nombre", "Ana"], ["edad", 25]];
        console.log(arrayAObjeto(entries)); // { nombre: "Ana", edad: 25 }
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  5. Clonaci√≥n Superficial y Profunda en una Funci√≥n
</h4>

Crea una funci√≥n que permita elegir entre una clonaci√≥n superficial y una profunda.

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        function clonar(obj, tipo) {
          if (tipo === 'superficial') {
            return Object.assign({}, obj);
          } else if (tipo === 'profunda') {
            return JSON.parse(JSON.stringify(obj));
          }
        }

        const original = { a: 1, b: { c: 2 } };
        const copiaSuperficial = clonar(original, 'superficial');
        const copiaProfunda = clonar(original, 'profunda');

        copiaSuperficial.b.c = 3;
        copiaProfunda.b.c = 4;

        console.log(original.b.c); // 3
        console.log(copiaSuperficial.b.c); // 3
        console.log(copiaProfunda.b.c); // 4
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## Arrays

Un array en JavaScript es una estructura de datos fundamental que te permite almacenar m√∫ltiples valores en una sola variable. Piensa en un array como una lista ordenada de elementos, donde cada elemento tiene una posici√≥n espec√≠fica conocida como √≠ndice. Estos √≠ndices comienzan en 0, lo que significa que el primer elemento est√° en la posici√≥n 0, el segundo en la posici√≥n 1, y as√≠ sucesivamente. Los arrays son incre√≠blemente vers√°tiles, ya que pueden contener cualquier tipo de dato: n√∫meros, cadenas de texto, booleanos, objetos, funciones e incluso otros arrays.

### Creaci√≥n de Arrays

Existen varias formas de crear arrays en JavaScript, y cada una tiene sus propias ventajas y usos.

1. **Usando el constructor Array:**

- **new Array(size):** Crea un array con el tama√±o especificado. Todos los elementos del array estar√°n inicializados como undefined. Este m√©todo puede ser √∫til cuando sabes de antemano el n√∫mero de elementos que el array tendr√°, pero no sus valores.

```js copy filename="JavaScript"
const arr1 = new Array(3); // [undefined, undefined, undefined]
```

- **new Array(elemento1, elemento2, ...):** Crea un array con los elementos proporcionados.

```js copy filename="JavaScript"
const arr2 = new Array("a", "b", "c"); // ['a', 'b', 'c']
```

<Callout emoji="üëÄ" type="default">
  Es importante notar que new Array(size) y new Array(3) no son lo mismo. El
  primero crea un array con tres elementos undefined, mientras que el segundo
  crea un array con un √∫nico elemento 3.
</Callout>

2. **Usando la notaci√≥n de corchetes (literal de array)**

Esta es la forma m√°s com√∫n y recomendada para crear arrays debido a su simplicidad y claridad.

```js copy filename="JavaScript"
const arr1 = []; // Array vac√≠o
const arr2 = ["a", "b", "c"]; // ['a', 'b', 'c']
const arr3 = ["a", 5, true]; // Array mixto ['a', 5, true]
```

Esta forma de crear arrays es preferida por su claridad y facilidad de uso, especialmente cuando trabajas con datos iniciales conocidos.

**Arrays Mixtos**

Esta forma de crear arrays es preferida por su claridad y facilidad de uso, especialmente cuando trabajas con datos iniciales conocidos.

```js copy filename="JavaScript"
const mixedArray = ["texto", 42, true, { key: "value" }, [1, 2, 3]];
```

En este ejemplo, el array contiene una cadena de texto, un n√∫mero, un booleano, un objeto y otro array. Esta flexibilidad te permite estructurar datos complejos de una manera muy manejable.

### Acceso a Elementos del Array

Una vez que tienes un array, necesitas poder acceder y manipular sus elementos. JavaScript proporciona varias maneras de hacerlo, incluyendo la propiedad .length, el operador [], el m√©todo .with(), y el m√©todo .at().

**Propiedad length**

La propiedad length de un array en JavaScript devuelve el n√∫mero de elementos que contiene el array. Es una propiedad que se actualiza autom√°ticamente a medida que se a√±aden o eliminan elementos del array.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let frutas = ["manzana", "banana", "cereza"];
console.log(frutas.length); // 3
```

**El Operador []**

El operador de corchetes [] es la manera m√°s b√°sica y com√∫n de acceder a los elementos de un array. Puedes usar este operador tanto para leer como para modificar los elementos de un array.

<h4 className="font-medium mt-5">Acceder a elementos</h4>

```js copy filename="JavaScript"
const letters = ["a", "b", "c"];
console.log(letters[0]); // 'a'
console.log(letters[2]); // 'c'
console.log(letters[5]); // undefined
```

Aqu√≠, letters[0] accede al primer elemento del array, que es 'a'. Si intentas acceder a un √≠ndice que no existe, como letters[5], JavaScript devolver√° undefined.

<h4 className="font-medium mt-5">Modificar elementos</h4>

```js copy filename="JavaScript"
letters[1] = "z";
console.log(letters); // ['a', 'z', 'c']
```

Puedes usar el operador [] para asignar un nuevo valor a un elemento existente en el array. En este caso, letters[1] se cambia de 'b' a 'z'.

<h4 className="font-medium mt-5">
  A√±adir elementos en una posici√≥n espec√≠fica
</h4>

```js copy filename="JavaScript"
letters[3] = "d";
console.log(letters); // ['a', 'z', 'c', 'd']
```

Puedes agregar un nuevo elemento a una posici√≥n espec√≠fica en el array, incluso si esa posici√≥n es mayor que la longitud actual del array. JavaScript autom√°ticamente llenar√° cualquier espacio intermedio con undefined.

**El M√©todo .with()**

El m√©todo .with() es una adici√≥n moderna a JavaScript (ES2023) que te permite crear una nueva copia de un array con un elemento modificado en una posici√≥n espec√≠fica, sin modificar el array original. Esto es √∫til cuando necesitas trabajar con versiones inmutables de datos.

<h4 className="font-medium mt-5">Modificar elementos</h4>

```js copy filename="JavaScript"
const letters = ["a", "b", "c"];
const newLetters = letters.with(1, "y");
console.log(newLetters); // ['a', 'y', 'c']
console.log(letters); // ['a', 'b', 'c'] (sin cambios)
```

El m√©todo .with() devuelve un nuevo array donde el elemento en la posici√≥n especificada ha sido cambiado. El array original permanece sin cambios.

<h4 className="font-medium mt-5">
  Agregar elementos en posiciones no existentes
</h4>

El m√©todo .with() no permite agregar elementos en posiciones que no existen en el array original. Intentar hacerlo resultar√° en un error.

```js copy filename="JavaScript"
try {
  const invalid = letters.with(10, "z");
} catch (error) {
  console.error(error); // Error: Index 10 out of range [0, 4)
}
```

**El M√©todo .at()**

El m√©todo .at() es otra caracter√≠stica moderna (ES2022) que te permite acceder a los elementos del array usando √≠ndices positivos o negativos. Esto es particularmente √∫til para acceder a elementos desde el final del array sin tener que calcular manualmente la posici√≥n.

<h4 className="font-medium mt-5">√çndices positivos</h4>

```js copy filename="JavaScript"
console.log(letters.at(0)); // 'a'
console.log(letters.at(1)); // 'b'
```

Funciona de manera similar al operador [].

<h4 className="font-medium mt-5">√çndices negativos</h4>

```js copy filename="JavaScript"
console.log(letters.at(-1)); // 'c' (√∫ltimo elemento)
console.log(letters.at(-2)); // 'b'
```

Los √≠ndices negativos te permiten contar desde el final del array, lo cual puede ser m√°s intuitivo en algunos casos.

### A√±adir o eliminar elementos en Arrays

La capacidad de a√±adir o eliminar elementos de un array es crucial para manipular datos de manera efectiva. Aqu√≠ nos centraremos en los m√©todos m√°s comunes para a√±adir y eliminar elementos del principio y del final de un array, profundizando en su funcionamiento y proporcionando ejemplos detallados para una comprensi√≥n completa.

**A√±adir Elementos a un Array**

- **M√©todo push()**

El m√©todo push() es utilizado para a√±adir uno o m√°s elementos al final de un array. Este m√©todo modifica el array original y devuelve la nueva longitud del array.

<h4 className="font-medium mt-5">ejemplo</h4>

```js copy filename="JavaScript"
let frutas = ["manzana", "banana"];
let nuevaLongitud = frutas.push("naranja", "kiwi");
console.log(frutas); // ["manzana", "banana", "naranja", "kiwi"]
console.log(nuevaLongitud); // 4
```

**Explicaci√≥n**

-- Estado Inicial: frutas contiene ["manzana", "banana"].
-- Operaci√≥n: Se a√±aden "naranja" y "kiwi" al final del array utilizando push().
-- Resultado: frutas ahora contiene ["manzana", "banana", "naranja", "kiwi"] y la longitud del array es 4.

El m√©todo push() es especialmente √∫til cuando deseas agregar elementos a una lista de manera din√°mica, como al registrar entradas de usuario o al a√±adir datos recibidos de una API a una lista existente.

- **M√©todo unshift()**

El m√©todo unshift() a√±ade uno o m√°s elementos al principio de un array y devuelve la nueva longitud del array. Este m√©todo es √∫til cuando necesitas que ciertos elementos tengan prioridad y sean procesados primero.

<h4 className="font-medium mt-5">ejemplo</h4>

```js copy filename="JavaScript"
let verduras = ["zanahoria", "pepino"];
let nuevaLongitud = verduras.unshift("lechuga", "espinaca");
console.log(verduras); // ["lechuga", "espinaca", "zanahoria", "pepino"]
console.log(nuevaLongitud); // 4
```

**Explicaci√≥n**

-- Estado Inicial: verduras contiene ["zanahoria", "pepino"].
-- Operaci√≥n: Se a√±aden "lechuga" y "espinaca" al principio del array utilizando unshift().
-- Resultado: verduras ahora contiene ["lechuga", "espinaca", "zanahoria", "pepino"] y la longitud del array es 4.

Este m√©todo es ideal para escenarios donde los elementos nuevos deben ser procesados primero, como una lista de tareas donde las tareas m√°s recientes deben tener prioridad.

**Eliminar Elementos de un Array**

- **M√©todo pop()**

El m√©todo pop() elimina el √∫ltimo elemento de un array y devuelve ese elemento. Este m√©todo es √∫til cuando trabajas con estructuras de datos tipo pila (LIFO - Last In, First Out).

<h4 className="font-medium mt-5">ejemplo</h4>

```js copy filename="JavaScript"
let numeros = [1, 2, 3, 4, 5];
let ultimoNumero = numeros.pop();
console.log(numeros); // [1, 2, 3, 4]
console.log(ultimoNumero); // 5
```

**Explicaci√≥n**

-- Estado Inicial: numeros contiene [1, 2, 3, 4, 5].
-- Operaci√≥n: Se elimina el √∫ltimo elemento del array utilizando pop().
-- Resultado: numeros ahora contiene [1, 2, 3, 4] y el valor devuelto por pop() es 5.

pop() es √∫til en situaciones donde necesitas procesar o manejar el √∫ltimo elemento a√±adido a una lista, como deshacer la √∫ltima acci√≥n en una aplicaci√≥n.

- **M√©todo shift()**

El m√©todo shift() elimina el primer elemento de un array y devuelve ese elemento. Este m√©todo es √∫til cuando trabajas con estructuras de datos tipo cola (FIFO - First In, First Out).

<h4 className="font-medium mt-5">ejemplo</h4>

```js copy filename="JavaScript"
let tareas = ["desayunar", "trabajar", "cenar"];
let primeraTarea = tareas.shift();
console.log(tareas); // ["trabajar", "cenar"]
console.log(primeraTarea); // "desayunar"
```

**Explicaci√≥n**

-- Estado Inicial: tareas contiene ["desayunar", "trabajar", "cenar"].
-- Operaci√≥n: Se elimina el primer elemento del array utilizando shift().
-- Resultado: tareas ahora contiene ["trabajar", "cenar"] y el valor devuelto por shift() es "desayunar".

shift() es ideal para escenarios donde los elementos deben ser procesados en el orden en que fueron a√±adidos, como en una cola de solicitudes o tareas.
