import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Tipos de Datos

En el mundo de la programaci√≥n, y espec√≠ficamente en JavaScript, entender los tipos de datos es fundamental para el manejo adecuado de la informaci√≥n dentro de nuestras aplicaciones. Los tipos de datos nos permiten categorizar la informaci√≥n y definir las operaciones que se pueden realizar con dichos datos.

## Clasificaci√≥n de los Tipos de Datos en JavaScript

JavaScript es conocido por ser un lenguaje de programaci√≥n con tipado din√°mico, lo que significa que las variables no requieren una declaraci√≥n de tipo de dato expl√≠cita y pueden cambiar de tipo. A pesar de esto, JavaScript define dos categor√≠as principales de tipos de datos: primitivos y compuestos.

### Tipos Primitivos

<table className="table-fixed my-5 w-full text-start">
  <thead className="bg-sky-900 text-white text-sm">
    <tr>
      <th>Tipo de Dato</th>
      <th>Descripci√≥n</th>
      <th>Ejemplo</th>
    </tr>
  </thead>
  <tbody>
    {[
      {
        tipoDeDato: "Number",
        descripci√≥n: "Incluye tanto enteros como n√∫meros decimales.",
        ejemplo: "let age = 30;",
      },
      {
        tipoDeDato: "String",
        descripci√≥n: "Cadena de caracteres utilizada para representar texto.",
        ejemplo: 'let name = "Alice";',
      },
      {
        tipoDeDato: "Boolean",
        descripci√≥n:
          "Representa dos valores, verdadero (true) o falso (false).",
        ejemplo: "let isActive = true;",
      },
      {
        tipoDeDato: "Undefined",
        descripci√≥n:
          "Indica que una variable ha sido declarada pero a√∫n no se le ha asignado un valor.",
        ejemplo: "let result;",
      },
      {
        tipoDeDato: "Null",
        descripci√≥n:
          "Representa la ausencia intencional de un valor de objeto.",
        ejemplo: "let data = null;",
      },
      {
        tipoDeDato: "Symbol",
        descripci√≥n: "Proporciona claves √∫nicas para propiedades de objetos.",
        ejemplo: "let id = Symbol('id');",
      },
      {
        tipoDeDato: "BigInt",
        descripci√≥n:
          "Utilizado para almacenar n√∫meros m√°s grandes que el l√≠mite para un tipo Number.",
        ejemplo: "let bigNumber = 9007199254740991n;",
      },
    ].map((item) => (
      <tr key={item.tipoDeDato}>
        <td>{item.tipoDeDato}</td>
        <td>{item.descripci√≥n}</td>
        <td>{item.ejemplo}</td>
      </tr>
    ))}
  </tbody>
</table>

### Tipos Compuestos o Referencia

<table className="table-fixed my-5 w-full text-start">
  <thead className="bg-sky-900 text-white text-sm">
    <tr>
      <th>Tipo de Dato</th>
      <th>Descripci√≥n</th>
      <th>Ejemplo</th>
    </tr>
  </thead>
  <tbody>
    {[
      {
        tipoDeDato: "Object",
        descripci√≥n: "Incluye objetos, arrays, funciones, y m√°s.",
        ejemplo: 'let user = {name: "Alice", age: 25};',
      },
      {
        tipoDeDato: "Array",
        descripci√≥n: "Lista ordenada de valores.",
        ejemplo: "let numbers = [1, 2, 3, 4, 5];",
      },
      {
        tipoDeDato: "Function",
        descripci√≥n: "Bloques de c√≥digo reutilizables.",
        ejemplo: 'function greet() { console.log("Hello World!"); }',
      },
    ].map((item) => (
      <tr key={item.tipoDeDato}>
        <td>{item.tipoDeDato}</td>
        <td>{item.descripci√≥n}</td>
        <td>{item.ejemplo}</td>
      </tr>
    ))}
  </tbody>
</table>

## Importancia de los Tipos de Datos

Los diferentes tipos de datos en JavaScript permiten a los programadores realizar diversas operaciones y manipular datos de manera eficiente. Por ejemplo:

- **Operaciones matem√°ticas** son principalmente realizadas con el tipo Number.
- **Manipulaci√≥n de textos** se realiza con el tipo String, utilizando m√©todos como .toUpperCase(), .substring(), entre otros.
- **Control de flujo** se maneja a menudo con valores Boolean, permitiendo ejecutar diferentes secciones de c√≥digo basadas en condiciones verdaderas o falsas.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo simple para ilustrar c√≥mo se utilizan los tipos de datos en JavaScript:

```js copy filename="JavaScript"
// Declaraci√≥n de diferentes tipos de datos
let year = 2021; // Number
let welcomeMessage = "Hello, welcome to 2021!"; // String
let isLeapYear = false; // Boolean
let user = { name: "John Doe", age: 28 }; // Object

// Uso de tipos de datos
console.log(welcomeMessage); // Muestra el mensaje de bienvenida
if (!isLeapYear) {
  console.log(year, "is not a leap year."); // Eval√∫a la condici√≥n y muestra el mensaje
}

// Acceso a propiedad de objeto
console.log("User:", user.name, "Age:", user.age); // Muestra informaci√≥n del usuario
```

<Callout emoji="üëÄ" type="default">
  Entender y utilizar correctamente los tipos de datos en JavaScript es crucial
  para el desarrollo de aplicaciones robustas y mantenibles. Cada tipo de datos
  ofrece caracter√≠sticas y m√©todos espec√≠ficos que facilitan la implementaci√≥n
  de funcionalidades complejas en programas de cualquier escala. La selecci√≥n
  adecuada del tipo de datos no solo impacta en la claridad del c√≥digo sino
  tambi√©n en el rendimiento y la gesti√≥n de recursos dentro de la aplicaci√≥n.
</Callout>

## ¬øQu√© Tipo de Dato Tiene?

En JavaScript, es com√∫n necesitar identificar el tipo de dato de una variable, especialmente porque es un lenguaje de tipado din√°mico donde el tipo de una variable puede cambiar. Para realizar esta tarea, JavaScript proporciona dos herramientas principales: el operador typeof y la propiedad constructor.name. Estas herramientas ayudan a los desarrolladores a comprender y manejar los datos con los que trabajan de manera m√°s efectiva.

### Operador typeof

El operador typeof es una herramienta r√°pida y f√°cil para identificar el tipo b√°sico de una variable. Es un operador unario, lo que significa que toma un solo operando y devuelve una cadena que describe el tipo de dato del valor. Aqu√≠ est√°n los posibles valores que typeof puede retornar:

- **"undefined"** ‚Äî para variables no definidas o no inicializadas.
- **"boolean"** ‚Äî para valores booleanos (true o false).
- **"number"** ‚Äî para n√∫meros, ya sean enteros o flotantes.
- **"bigint"** ‚Äî para n√∫meros enteros muy grandes que no pueden ser representados por el tipo number.
- **"string"** ‚Äî para cadenas de caracteres.
- **"symbol"** ‚Äî para valores del tipo Symbol.
- **"function"** ‚Äî para funciones.
- **"object"** ‚Äî para objetos, que incluyen objetos de tipo Array y null (debido a un error hist√≥rico en JavaScript, null se considera un objeto).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let name = "Alice";
console.log(typeof name); // "string"

let age = 30;
console.log(typeof age); // "number"

let isActive = true;
console.log(typeof isActive); // "boolean"

let user = null;
console.log(typeof user); // "object" ‚Äì Caso especial para null

let calculateAge = function () {
  return age;
};
console.log(typeof calculateAge); // "function"
```

### constructor.name

Aunque typeof es √∫til para identificar tipos primitivos y distinguir entre funciones y objetos gen√©ricos, no proporciona detalles sobre el tipo espec√≠fico de objetos como instancias de clases personalizadas, arrays, o fechas. Para obtener el nombre del constructor que cre√≥ la instancia del objeto, podemos utilizar constructor.name.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let numbers = [1, 2, 3];
console.log(numbers.constructor.name); // "Array"

let today = new Date();
console.log(today.constructor.name); // "Date"

class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
let user = new User("Bob", 25);
console.log(user.constructor.name); // "User"
```

Es importante tener en cuenta que constructor.name puede no ser completamente fiable en entornos de producci√≥n donde el c√≥digo puede ser minificado o ofuscado, ya que los nombres de los constructores pueden ser alterados.

<Callout emoji="üëÄ" type="error">
  **OJO:** S√≥lo funciona en variables definidas (no undefined) y s√≥lo en o
  superiores.
</Callout>

## Referencia de una Variable a un Valor Primitivo y a un Valor Complejo

En JavaScript, la comprensi√≥n de c√≥mo las variables se asocian a valores primitivos y complejos es fundamental para entender c√≥mo se manejan los datos dentro del lenguaje. Este concepto es crucial para operar con eficiencia y precisi√≥n en el desarrollo de aplicaciones web.

### Valores Primitivos

Los valores primitivos en JavaScript son datos que no poseen propiedades ni m√©todos. Estos incluyen tipos como number, string, boolean, undefined, null, symbol, y bigint. Una caracter√≠stica clave de los valores primitivos es que cuando asignas un valor primitivo a una variable, la variable accede directamente a ese valor. No hay una referencia o un objeto involucrado en este proceso. Esto se conoce como **asignaci√≥n por valor**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let x = 10;
let y = x;

// Modificar 'y' no afectar√° 'x'
y = 20;

console.log(x); // Muestra 10
console.log(y); // Muestra 20
```

En este ejemplo, x y y son completamente independientes entre s√≠ a pesar de que y fue inicialmente creada como una copia de x.

**Gr√°fico**

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    }
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso person esta apilado en nuestra lista, pero a su vez sus datos se almacenan en otra pila, a la cual acceder√° a esta, por su referencia.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },
    let newName = name;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName = Jhoswe",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso ahora tenemos una nueva variable llamada newName el cual tendr√° el valor que la variable name que en este caso es Jhoswe; Ojo que name sigue teniendo el valor de Jhoswe.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName=Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora nosotros cambiamos el valor de newName a Sau, pero el valor de name seguir√° siendo la misma de la original, es decir Jhoswe

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'

    let newPerson = person
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "newPerson",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "newName = Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora newPerson apunta a la misma referencia de person, por lo que si hay alg√∫n cambio dentro del objeto de person o newPerson, este cambio lo tendr√°n ambos.

### Valores Complejos

Los valores complejos (tambi√©n conocidos como objetos) incluyen object, array, function, entre otros. A diferencia de los valores primitivos, cuando asignas un objeto a una variable, lo que se guarda en la variable es una referencia al objeto, no el objeto en s√≠. Esto significa que si tienes varias variables apuntando al mismo objeto y modificas el objeto a trav√©s de una de ellas, el cambio es visible a trav√©s de todas las variables que referencian ese objeto. Esto se conoce como **asignaci√≥n por referencia**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let obj1 = { value: 10 };
let obj2 = obj1;

// Modificar 'obj2' afecta 'obj1'
obj2.value = 20;

console.log(obj1.value); // Muestra 20
console.log(obj2.value); // Muestra 20
```

En este ejemplo, tanto obj1 como obj2 apuntan al mismo objeto en memoria. Cambiar una propiedad a trav√©s de obj2 altera el objeto al que tambi√©n apunta obj1.

### Importancia de Comprender Estas Diferencias

Comprender la diferencia entre c√≥mo se manejan los valores primitivos y los complejos es esencial por varias razones:

- **Mutabilidad:**

En JavaScript, los tipos primitivos como number, string, boolean, null, undefined, symbol, y bigint son inmutables. Esto significa que los valores contenidos en estas variables no pueden ser alterados despu√©s de su creaci√≥n. Si necesitas modificar un valor primitivo, lo que realmente sucede es que se crea un nuevo valor primitivo y se asigna a la variable, mientras que el valor original permanece sin cambios.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let str = "Hello";
str = str + " World"; // Aqu√≠, "Hello World" es un nuevo string, no una modificaci√≥n del original.
```

**Objetos Mutables**

A diferencia de los primitivos, los objetos como Array, Object, y Function son mutables. Esto significa que sus contenidos o propiedades pueden ser cambiados despu√©s de ser creados. Si una variable almacena una referencia a un objeto, las modificaciones al contenido del objeto afectar√°n a todas las referencias a ese objeto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let array = [1, 2, 3];
array.push(4); // Modifica el array original a√±adiendo un elemento al final.
```

- **Gesti√≥n de Memoria:**

Cuando se declara una variable en JavaScript y se le asigna un valor, el lenguaje gestiona autom√°ticamente la memoria necesaria para almacenar ese valor. Para valores primitivos, la cantidad de memoria necesaria es fija y relativamente peque√±a, mientras que para objetos, la memoria requerida puede variar considerablemente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let num1 = 42; // Almacena 42 directamente en la memoria asignada a num1.
let obj1 = { value: 42 }; // Crea un objeto en la memoria, y obj1 almacena una referencia a √©l.
let obj2 = obj1; // obj2 no almacena otro objeto, sino una referencia al mismo objeto que obj1.
```

- **Rendimiento:**

El manejo de objetos y sus referencias puede tener implicaciones significativas en el rendimiento, especialmente en aplicaciones grandes y complejas.

- Asignaci√≥n y Copia: La asignaci√≥n de objetos y la copia de referencias son operaciones r√°pidas porque no implican duplicar el objeto subyacente. Sin embargo, la creaci√≥n de objetos nuevos puede ser costosa en t√©rminos de tiempo y memoria.
- Modificaci√≥n de Objetos: Modificar objetos es eficiente en cuanto a que no requiere la creaci√≥n de un nuevo objeto, pero si muchas referencias apuntan al mismo objeto, los cambios pueden tener efectos secundarios en partes no previstas del programa, lo que puede llevar a bugs o comportamientos inesperados.
- Garbage Collection: JavaScript utiliza un recolector de basura para liberar memoria que ya no es accesible. La gesti√≥n de muchos objetos y referencias puede complicar el proceso de recolecci√≥n de basura, potencialmente llevando a pausas o retrasos en la ejecuci√≥n del programa.

## Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

### Quizes

<h4 className="font-medium mt-5">
  ¬øQu√© tipo de dato devuelve typeof null en JavaScript?
</h4>

<p className="my-2">a) null</p>
<p>b) undefined</p>
<p className="my-2">c) object</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) "object"</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øCu√°l es un tipo de dato primitivo en JavaScript?
</h4>

<p className="my-2">a) object</p>
<p>b) number</p>
<p className="my-2">b) array</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) number</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øCu√°l operador se utiliza para determinar el tipo de una variable o valor en
  JavaScript?
</h4>

<p className="my-2">a) typeof</p>
<p>b) instanceof</p>
<p className="my-2">c) type()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) typeof</AccordionContent>
  </AccordionItem>
</Accordion>

    <h4 className="font-medium mt-5">
      ¬øQu√© indica el valor undefined en JavaScript?
    </h4>

    <p className="my-2">a)  Que una variable ha sido declarada pero no tiene asignado ning√∫n valor.</p>
    <p>b) Que una variable no existe.</p>
    <p className="my-2">c) Que una variable es nula.</p>

    <Accordion type="single" collapsible>
      <AccordionItem value="item-1">
        <AccordionTrigger>Respuesta</AccordionTrigger>
        <AccordionContent>a) Que una variable ha sido declarada pero no tiene asignado ning√∫n valor.</AccordionContent>
      </AccordionItem>
    </Accordion>

<h4 className="font-medium mt-5">
  ¬øQu√© tipo de datos se considera BigInt en JavaScript?
</h4>

<p className="my-2">a) Primitivo</p>
<p>b) Compuesto</p>
<p className="my-2">c) Objeto</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Primitivo</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øCu√°l de los siguientes es un tipo de dato compuesto en JavaScript?
</h4>

<p className="my-2">a) Symbol</p>
<p>b) Array</p>
<p className="my-2">c) Boolean</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Array</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øQu√© devuelve constructor.name cuando se aplica a una instancia de una clase
  personalizada en JavaScript?
</h4>

<p className="my-2">a) El nombre de la variable</p>
<p>b) El nombre de la clase</p>
<p className="my-2">c) El tipo de objeto</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) El nombre de la clase</AccordionContent>
  </AccordionItem>
</Accordion>

    <h4 className="font-medium mt-5">¬øCu√°l es la diferencia principal entre los tipos primitivos y los compuestos en JavaScript?</h4>

    <p className="my-2">a) Los primitivos son siempre n√∫meros, y los compuestos son estructuras como arrays y objetos.</p>
    <p>b) Los primitivos son inmutables y no pueden contener otros valores, mientras que los compuestos pueden incluir otros objetos y tipos primitivos.</p>
    <p className="my-2">c) Los compuestos son siempre est√°ticos, mientras que los primitivos pueden cambiar.</p>

    <Accordion type="single" collapsible>
      <AccordionItem value="item-1">
        <AccordionTrigger>Respuesta</AccordionTrigger>
        <AccordionContent>b) Los primitivos son inmutables y no pueden contener otros valores, mientras que los compuestos pueden incluir otros objetos y tipos primitivos.</AccordionContent>
      </AccordionItem>
    </Accordion>

### Preguntas

<h4 className="font-medium mt-5">
  ¬øPor qu√© es importante entender la diferencia entre tipos primitivos y
  compuestos en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Entender la diferencia es crucial porque afecta c√≥mo se manejan la asignaci√≥n y la manipulaci√≥n de datos. Los tipos primitivos son inmutables y operan por valor, lo que significa que cuando asignas o pasas un tipo primitivo, se crea una copia del valor. Por otro lado, los tipos compuestos (objetos, arrays, etc.) operan por referencia, lo que significa que si pasas o asignas un objeto a otra variable, ambos referenciar√°n el mismo objeto en memoria. Esto afecta directamente a la gesti√≥n de la memoria, el comportamiento del programa y los bugs potenciales al modificar los datos involuntariamente a trav√©s de diferentes referencias.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Explica c√≥mo puedes utilizar el operador typeof para mejorar la validaci√≥n de
  datos en una funci√≥n.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El operador typeof es √∫til para asegurar que los datos pasados a una funci√≥n cumplen con el tipo esperado, lo cual es esencial para prevenir errores de l√≥gica y ejecuci√≥n. Por ejemplo, si una funci√≥n espera un n√∫mero para realizar c√°lculos, puedes usar typeof para verificar que el argumento es un 'number' antes de proceder. Esto es especialmente √∫til en funciones que son expuestas p√∫blicamente o que manejan datos provenientes de fuentes externas.

      ```js copy filename="JavaScript"
      function calculateSquare(area) {
        if (typeof area !== 'number') {
          throw new TypeError('Expected a number');
        }
        return area * area;
      }
      ```

        </AccordionContent>

      </AccordionItem>
    </Accordion>

<h4 className="font-medium mt-5">
  Describe una situaci√≥n donde podr√≠as preferir usar BigInt en lugar de Number.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      BigInt es preferible cuando necesitas manejar n√∫meros extremadamente grandes que superan el l√≠mite seguro para el tipo Number (Number.MAX_SAFE_INTEGER, es decir, 2^53 - 1). Un ejemplo pr√°ctico ser√≠a en aplicaciones financieras donde se manejan grandes sumas de dinero o c√°lculos que requieren alta precisi√≥n con grandes n√∫meros enteros, como en criptograf√≠a o al trabajar con identificadores √∫nicos de gran tama√±o.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øC√≥mo afecta el tipo de dato undefined al flujo de control en tus scripts?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      El tipo de dato undefined generalmente indica que una variable ha sido declarada pero no inicializada. Esto puede llevar a errores si intentas realizar operaciones en variables que esperas que est√©n definidas. Adem√°s, en comparaciones, undefined es un valor falsy, lo que significa que puede causar que ciertas ramas de l√≥gica condicional no se ejecuten como esperado si no se maneja correctamente.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øCu√°l es el impacto de usar constructor.name en la depuraci√≥n de aplicaciones
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usar constructor.name puede ser extremadamente √∫til en la depuraci√≥n para identificar r√°pidamente el tipo de objeto con el que est√°s trabajando, especialmente en situaciones donde m√∫ltiples clases o constructores est√°n involucrados. Esto puede ayudar a verificar que los objetos sean de la clase esperada, lo que es importante para la integridad del tipo en tiempo de ejecuci√≥n. Sin embargo, su utilidad puede reducirse en producci√≥n si el c√≥digo es minificado, ya que los nombres de los constructores pueden cambiar.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Explica la importancia de la inmutabilidad de los tipos primitivos.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      La inmutabilidad de los tipos primitivos ayuda a prevenir efectos secundarios no deseados en funciones y m√©todos. Cuando pasas un tipo primitivo a una funci√≥n, puedes estar seguro de que cualquier modificaci√≥n a ese dato no afectar√° el valor original fuera de la funci√≥n. Esto hace que el c√≥digo sea m√°s predecible y seguro, facilitando el razonamiento sobre el estado del programa y la depuraci√≥n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øC√≥mo verificar√≠as si una variable es un array en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Para verificar si una variable es un array, puedes utilizar el m√©todo Array.isArray() proporcionado por JavaScript, que devuelve true si la variable es un array y false en caso contrario.

      ```js copy filename="JavaScript"
      let fruits = ['apple', 'banana', 'cherry'];
      console.log(Array.isArray(fruits)); // true
      ```

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  Discute c√≥mo el manejo adecuado de los tipos de datos puede afectar el
  rendimiento de una aplicaci√≥n.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Un manejo adecuado de los tipos de datos puede optimizar la utilizaci√≥n de la memoria y mejorar el tiempo de ejecuci√≥n de las operaciones. Por ejemplo, usar tipos primitivos donde sea posible puede minimizar el uso de memoria en comparaci√≥n con objetos m√°s complejos. Adem√°s, evitar conversiones innecesarias de tipos (como de string a number repetidamente en un bucle) puede reducir la carga de procesamiento y mejorar la velocidad de ejecuci√≥n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  ¬øCu√°les son las consecuencias de no entender correctamente el tipo de dato
  null en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      No entender null puede llevar a errores de tipo "Cannot read property of null", especialmente si intentas acceder a propiedades o m√©todos de algo que esperabas que fuera un objeto pero que en realidad es null. Esto ocurre a menudo cuando los datos esperados no est√°n disponibles o cuando las funciones fallan silenciosamente y retornan null en lugar de un objeto. Tratar correctamente null es esencial para prevenir fallos en tiempo de ejecuci√≥n y para implementar comprobaciones de seguridad adecuadas en el c√≥digo.


    </AccordionContent>

  </AccordionItem>
</Accordion>

### Ejercicios

<h4 className="font-medium my-5">
  Define un objeto que describa un ticket de tren con las propiedades de
  estaci√≥n inicial, estaci√≥n final y precio.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let ticket = {
          from: "Madrid",
          to: "Barcelona",
          price: 40
        };
        console.log(`Ticket from ${ticket.from} to ${ticket.to} costs ${ticket.price} euros.`);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  Crea un array que contenga objetos de libros con propiedades de t√≠tulo, autor
  y n√∫mero de p√°ginas.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let books = [
        { title: "Speaking JavaScript", author: "Axel Rauschmayer", pages: 460 },
        { title: "Programming JavaScript Applications", author: "Eric Elliott", pages: 254 },
        { title: "Understanding ECMAScript 6", author: "Nicholas C. Zakas", pages: 352 }
      ];
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>
