import Image from "next/image";
import Link from "next/link";
import { Steps } from "nextra/components";
import { Callout } from "nextra-theme-docs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import Editor, { DiffEditor, useMonaco, loader } from "@monaco-editor/react";

# Tipos de Datos

En JavaScript, los tipos de datos son fundamentales para el manejo y la manipulaci√≥n de la informaci√≥n. Entender los tipos de datos y c√≥mo clasificarlos es esencial para escribir programas efectivos y eficientes.

## Definici√≥n de Tipos de Datos

Un tipo de dato en JavaScript define la naturaleza del valor que puede almacenar una variable. Los tipos de datos determinan qu√© operaciones se pueden realizar sobre los valores y c√≥mo se almacenan en la memoria. JavaScript es un lenguaje de tipado d√©bil y din√°mico, lo que significa que el tipo de una variable puede cambiar durante la ejecuci√≥n del programa y no necesita ser declarado expl√≠citamente.

### Clasificaci√≥n de los Tipos de Datos

En Javascript disponemos de los siguientes tipos de datos principales:

<table className="table-fixed my-5 w-full text-start">
  <thead className="bg-sky-900 text-white text-sm">
    <tr>
      <th>Tipo de Dato</th>
      <th>Descripci√≥n</th>
      <th>Ejemplo</th>
    </tr>
  </thead>
  <tbody>
    {[
      {
        tipoDeDato: "Number",
        descripci√≥n:
          "Representa valores num√©ricos, incluidos enteros y de punto flotante.",
        ejemplo: "let age = 30;",
      },
      {
        tipoDeDato: "BigInt",
        descripci√≥n:
          "Utilizado para almacenar n√∫meros m√°s grandes que el l√≠mite para un tipo Number.",
        ejemplo: "let bigNumber = 9007199254740991n;",
      },
      {
        tipoDeDato: "String",
        descripci√≥n: "Representa secuencias de caracteres.",
        ejemplo: 'let name = "Alice";',
      },
      {
        tipoDeDato: "Boolean",
        descripci√≥n: "Representa valores l√≥gicos true o false.",
        ejemplo: "let isActive = true;",
      },
      {
        tipoDeDato: "Undefined",
        descripci√≥n:
          "Indica que una variable ha sido declarada pero no inicializada.",
        ejemplo: "let result;",
      },
      {
        tipoDeDato: "Null",
        descripci√≥n: "Representa la ausencia intencional de un valor.",
        ejemplo: "let data = null;",
      },
      {
        tipoDeDato: "Symbol",
        descripci√≥n:
          "Representa un valor √∫nico e inmutable, a menudo usado como identificador √∫nico.",
        ejemplo: "let id = Symbol('id');",
      },
      {
        tipoDeDato: "Function",
        descripci√≥n:
          "Un tipo especial de objeto que se puede invocar para realizar una tarea.",
        ejemplo: 'function greet() { console.log("Hello World!"); }',
      },
      {
        tipoDeDato: "Object",
        descripci√≥n:
          "Representa una colecci√≥n de propiedades, donde cada propiedad tiene un nombre y un valor.",
        ejemplo: 'let user = {name: "Alice", age: 25};',
      },
      {
        tipoDeDato: "Array",
        descripci√≥n:
          "Un tipo especial de objeto que representa una lista ordenada de valores.",
        ejemplo: "let numbers = [1, 2, 3, 4, 5];",
      },
    ].map((item) => (
      <tr key={item.tipoDeDato}>
        <td>{item.tipoDeDato}</td>
        <td>{item.descripci√≥n}</td>
        <td>{item.ejemplo}</td>
      </tr>
    ))}
  </tbody>
</table>

### Importancia de los Tipos de Datos

Los diferentes tipos de datos en JavaScript permiten a los programadores realizar diversas operaciones y manipular datos de manera eficiente. Por ejemplo:

- **Operaciones matem√°ticas** son principalmente realizadas con el tipo Number.
- **Manipulaci√≥n de textos** se realiza con el tipo String, utilizando m√©todos como .toUpperCase(), .substring(), entre otros.
- **Control de flujo** se maneja a menudo con valores Boolean, permitiendo ejecutar diferentes secciones de c√≥digo basadas en condiciones verdaderas o falsas.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos un ejemplo simple para ilustrar c√≥mo se utilizan los tipos de datos en JavaScript:

```js copy filename="JavaScript"
// Declaraci√≥n de diferentes tipos de datos
let year = 2021; // Number
let welcomeMessage = "Hello, welcome to 2021!"; // String
let isLeapYear = false; // Boolean
let user = { name: "John Doe", age: 28 }; // Object

// Uso de tipos de datos
console.log(welcomeMessage); // Muestra el mensaje de bienvenida
if (!isLeapYear) {
  console.log(year, "is not a leap year."); // Eval√∫a la condici√≥n y muestra el mensaje
}

// Acceso a propiedad de objeto
console.log("User:", user.name, "Age:", user.age); // Muestra informaci√≥n del usuario
```

<Callout emoji="üëÄ" type="default">
  Entender y utilizar correctamente los tipos de datos en JavaScript es crucial
  para el desarrollo de aplicaciones robustas y mantenibles. Cada tipo de datos
  ofrece caracter√≠sticas y m√©todos espec√≠ficos que facilitan la implementaci√≥n
  de funcionalidades complejas en programas de cualquier escala. La selecci√≥n
  adecuada del tipo de datos no solo impacta en la claridad del c√≥digo sino
  tambi√©n en el rendimiento y la gesti√≥n de recursos dentro de la aplicaci√≥n.
</Callout>

### ¬øQu√© Tipo de Dato Tiene?

En JavaScript, es com√∫n necesitar identificar el tipo de dato de una variable, especialmente porque es un lenguaje de tipado din√°mico donde el tipo de una variable puede cambiar. Para realizar esta tarea, JavaScript proporciona dos herramientas principales: el operador typeof y la propiedad constructor.name. Estas herramientas ayudan a los desarrolladores a comprender y manejar los datos con los que trabajan de manera m√°s efectiva.

1. **Operador typeof**

El operador typeof es una herramienta r√°pida y f√°cil para identificar el tipo b√°sico de una variable. Es un operador unario, lo que significa que toma un solo operando y devuelve una cadena que describe el tipo de dato del valor. Aqu√≠ est√°n los posibles valores que typeof puede retornar:

- **"undefined"** ‚Äî para variables no definidas o no inicializadas.
- **"boolean"** ‚Äî para valores booleanos (true o false).
- **"number"** ‚Äî para n√∫meros, ya sean enteros o flotantes.
- **"bigint"** ‚Äî para n√∫meros enteros muy grandes que no pueden ser representados por el tipo number.
- **"string"** ‚Äî para cadenas de caracteres.
- **"symbol"** ‚Äî para valores del tipo Symbol.
- **"function"** ‚Äî para funciones.
- **"object"** ‚Äî para objetos, que incluyen objetos de tipo Array y null (debido a un error hist√≥rico en JavaScript, null se considera un objeto).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let name = "Alice";
console.log(typeof name); // "string"

let age = 30;
console.log(typeof age); // "number"

let isActive = true;
console.log(typeof isActive); // "boolean"

let user = null;
console.log(typeof user); // "object" ‚Äì Caso especial para null

let calculateAge = function () {
  return age;
};
console.log(typeof calculateAge); // "function"
```

2. **constructor.name**

Aunque typeof es √∫til para identificar tipos primitivos y distinguir entre funciones y objetos gen√©ricos, no proporciona detalles sobre el tipo espec√≠fico de objetos como instancias de clases personalizadas, arrays, o fechas. Para obtener el nombre del constructor que cre√≥ la instancia del objeto, podemos utilizar constructor.name.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let numbers = [1, 2, 3];
console.log(numbers.constructor.name); // "Array"

let today = new Date();
console.log(today.constructor.name); // "Date"

class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
let user = new User("Bob", 25);
console.log(user.constructor.name); // "User"
```

Es importante tener en cuenta que constructor.name puede no ser completamente fiable en entornos de producci√≥n donde el c√≥digo puede ser minificado o ofuscado, ya que los nombres de los constructores pueden ser alterados.

<Callout emoji="üëÄ" type="error">
  **OJO:** S√≥lo funciona en variables definidas (no undefined) y s√≥lo en o
  superiores.
</Callout>

### Referencia de una Variable

En JavaScript, la comprensi√≥n de c√≥mo las variables se asocian a valores primitivos y complejos es fundamental para entender c√≥mo se manejan los datos dentro del lenguaje. Este concepto es crucial para operar con eficiencia y precisi√≥n en el desarrollo de aplicaciones web.

1. **Valores Primitivos**

Los valores primitivos en JavaScript son datos que no poseen propiedades ni m√©todos. Estos incluyen tipos como number, string, boolean, undefined, null, symbol, y bigint. Una caracter√≠stica clave de los valores primitivos es que cuando asignas un valor primitivo a una variable, la variable accede directamente a ese valor. No hay una referencia o un objeto involucrado en este proceso. Esto se conoce como **asignaci√≥n por valor**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let x = 10;
let y = x;

// Modificar 'y' no afectar√° 'x'
y = 20;

console.log(x); // Muestra 10
console.log(y); // Muestra 20
```

En este ejemplo, x y y son completamente independientes entre s√≠ a pesar de que y fue inicialmente creada como una copia de x.

**Gr√°fico**

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    }
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso person esta apilado en nuestra lista, pero a su vez sus datos se almacenan en otra pila, a la cual acceder√° a esta, por su referencia.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },
    let newName = name;
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName = Jhoswe",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

En este caso ahora tenemos una nueva variable llamada newName el cual tendr√° el valor que la variable name que en este caso es Jhoswe; Ojo que name sigue teniendo el valor de Jhoswe.

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "",
        },
        {
          tipoDeDato: "newName=Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora nosotros cambiamos el valor de newName a Sau, pero el valor de name seguir√° siendo la misma de la original, es decir Jhoswe

<div className="grid grid-cols-2 my-5 gap-5">
  <div>

    ```js copy filename="JavaScript"
    let name = 'Jhoswe';
    let age = 34;
    let person = {
      name:'Genner',
      age:25
    },

    let newName = name;
    newName = 'Saul'

    let newPerson = person
    ```

  </div>
  <table className="table-fixed w-full text-center">
    <thead className="bg-sky-900 text-white text-sm">
      <tr>
        <th>Pila de Memoria</th>
        <th>Pila de Objeto</th>
      </tr>
    </thead>
    <tbody>
      {[
        {
          tipoDeDato: "newPerson",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "newName = Saul",
        },
        {
          tipoDeDato: "person",
          tipoDeDato2: `{
            name: "Genner",
            age:25
          }`,
        },
        {
          tipoDeDato: "age = 34",
        },
        {
          tipoDeDato: "name = Jhoswe",
        },
      ].map((item) => (
        <tr key={item.tipoDeDato}>
          <td>{item.tipoDeDato}</td>
          <td>{item.tipoDeDato2}</td>
        </tr>
      ))}
    </tbody>

  </table>
</div>

Ahora newPerson apunta a la misma referencia de person, por lo que si hay alg√∫n cambio dentro del objeto de person o newPerson, este cambio lo tendr√°n ambos.

2. **Valores Complejos**

Los valores complejos (tambi√©n conocidos como objetos) incluyen object, array, function, entre otros. A diferencia de los valores primitivos, cuando asignas un objeto a una variable, lo que se guarda en la variable es una referencia al objeto, no el objeto en s√≠. Esto significa que si tienes varias variables apuntando al mismo objeto y modificas el objeto a trav√©s de una de ellas, el cambio es visible a trav√©s de todas las variables que referencian ese objeto. Esto se conoce como **asignaci√≥n por referencia**.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let obj1 = { value: 10 };
let obj2 = obj1;

// Modificar 'obj2' afecta 'obj1'
obj2.value = 20;

console.log(obj1.value); // Muestra 20
console.log(obj2.value); // Muestra 20
```

En este ejemplo, tanto obj1 como obj2 apuntan al mismo objeto en memoria. Cambiar una propiedad a trav√©s de obj2 altera el objeto al que tambi√©n apunta obj1.

**Importancia de Comprender Estas Diferencias**

Comprender la diferencia entre c√≥mo se manejan los valores primitivos y los complejos es esencial por varias razones:

- **Mutabilidad:**

En JavaScript, los tipos primitivos como number, string, boolean, null, undefined, symbol, y bigint son inmutables. Esto significa que los valores contenidos en estas variables no pueden ser alterados despu√©s de su creaci√≥n. Si necesitas modificar un valor primitivo, lo que realmente sucede es que se crea un nuevo valor primitivo y se asigna a la variable, mientras que el valor original permanece sin cambios.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let str = "Hello";
str = str + " World"; // Aqu√≠, "Hello World" es un nuevo string, no una modificaci√≥n del original.
```

**Objetos Mutables**

A diferencia de los primitivos, los objetos como Array, Object, y Function son mutables. Esto significa que sus contenidos o propiedades pueden ser cambiados despu√©s de ser creados. Si una variable almacena una referencia a un objeto, las modificaciones al contenido del objeto afectar√°n a todas las referencias a ese objeto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let array = [1, 2, 3];
array.push(4); // Modifica el array original a√±adiendo un elemento al final.
```

- **Gesti√≥n de Memoria:**

Cuando se declara una variable en JavaScript y se le asigna un valor, el lenguaje gestiona autom√°ticamente la memoria necesaria para almacenar ese valor. Para valores primitivos, la cantidad de memoria necesaria es fija y relativamente peque√±a, mientras que para objetos, la memoria requerida puede variar considerablemente.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let num1 = 42; // Almacena 42 directamente en la memoria asignada a num1.
let obj1 = { value: 42 }; // Crea un objeto en la memoria, y obj1 almacena una referencia a √©l.
let obj2 = obj1; // obj2 no almacena otro objeto, sino una referencia al mismo objeto que obj1.
```

- **Rendimiento:**

El manejo de objetos y sus referencias puede tener implicaciones significativas en el rendimiento, especialmente en aplicaciones grandes y complejas.

- Asignaci√≥n y Copia: La asignaci√≥n de objetos y la copia de referencias son operaciones r√°pidas porque no implican duplicar el objeto subyacente. Sin embargo, la creaci√≥n de objetos nuevos puede ser costosa en t√©rminos de tiempo y memoria.
- Modificaci√≥n de Objetos: Modificar objetos es eficiente en cuanto a que no requiere la creaci√≥n de un nuevo objeto, pero si muchas referencias apuntan al mismo objeto, los cambios pueden tener efectos secundarios en partes no previstas del programa, lo que puede llevar a bugs o comportamientos inesperados.
- Garbage Collection: JavaScript utiliza un recolector de basura para liberar memoria que ya no es accesible. La gesti√≥n de muchos objetos y referencias puede complicar el proceso de recolecci√≥n de basura, potencialmente llevando a pausas o retrasos en la ejecuci√≥n del programa.

## Number

En JavaScript, los Number son uno de los tipos de datos b√°sicos (tipos primitivos) que se utilizan para representar valores num√©ricos, tanto enteros como fracciones decimales. Vamos a explorar en detalle c√≥mo funcionan y c√≥mo se manejan en este lenguaje.

**Declaraci√≥n de Variables Num√©ricas**

Crear variables num√©ricas en JavaScript es muy sencillo. Se pueden declarar simplemente escribiendo el n√∫mero literal o utilizando el constructor Number.

```js copy filename="JavaScript"
// Notaci√≥n literal (preferida)
const numero = 4;
const decimal = 15.8;
const numeroLegible = 5_000_000;

// Notaci√≥n con objetos (evitar)
const numeroObjeto = new Number(4);
const decimalObjeto = new Number(15.8);
const letra = new Number("A");
```

En la mayor√≠a de los casos, se prefiere la notaci√≥n literal debido a su simplicidad y eficiencia. La notaci√≥n con objetos es m√°s tediosa y puede llevar a resultados inesperados, como la creaci√≥n de objetos en lugar de valores primitivos.

**Manejo de Decimales y Separadores**

En JavaScript, los n√∫meros con decimales se representan utilizando un punto (.). Adem√°s, se puede usar el gui√≥n bajo (\_) como separador visual para hacer m√°s legibles los n√∫meros grandes.

```js copy filename="JavaScript"
const decimal = 123.45;
const numeroGrande = 1_000_000;

console.log(decimal); // 123.45
console.log(numeroGrande); // 1000000
```

El gui√≥n bajo no afecta el valor num√©rico, simplemente mejora la legibilidad.

**Notaci√≥n Cient√≠fica y Diferentes Bases Num√©ricas**

JavaScript permite representar n√∫meros en diferentes bases num√©ricas y en notaci√≥n cient√≠fica, lo cual es √∫til para trabajar con n√∫meros muy grandes o muy peque√±os.

```js copy filename="JavaScript"
// Notaci√≥n cient√≠fica
const grande = 1.23e5; // 123000
const peque√±o = 1.23e-5; // 0.0000123

// Diferentes bases num√©ricas
const decimal = 255; // Decimal
const hexadecimal = 0xff; // Hexadecimal
const octal = 0o377; // Octal
const binario = 0b11111111; // Binario

console.log(grande); // 123000
console.log(peque√±o); // 0.0000123
console.log(hexadecimal); // 255
console.log(octal); // 255
console.log(binario); // 255
```

### Rango Seguro de Enteros

En JavaScript, el manejo de n√∫meros es cr√≠tico, especialmente cuando se trata de grandes cantidades o c√°lculos precisos. La representaci√≥n est√°ndar de n√∫meros en JavaScript se hace mediante el formato de doble precisi√≥n de 64 bits IEEE 754, tambi√©n conocido como coma flotante de doble precisi√≥n. Este formato permite un amplio rango de valores, pero con limitaciones importantes en t√©rminos de precisi√≥n y rango seguro.

**Comprendiendo la Representaci√≥n en Coma Flotante**

Los n√∫meros en JavaScript, al almacenarse en formato de coma flotante, pueden no ser capaces de representar ciertos valores de manera exacta. Esto se debe a que el formato de coma flotante prioriza un amplio rango sobre la precisi√≥n absoluta en ciertos casos. Aunque puede manejar n√∫meros extremadamente grandes o peque√±os, el rango en el que los n√∫meros se pueden representar de manera segura sin perder precisi√≥n es mucho m√°s limitado.

**Constantes de Rango Seguro**

JavaScript define varias constantes para ayudar a los desarrolladores a entender los l√≠mites de la representaci√≥n num√©rica segura:

- **Number.MAX_SAFE_INTEGER:** El entero positivo m√°s grande que se puede representar de manera segura. Este valor es ${2^{53}-1}$, que es 9,007,199,254,740,991.
- **Number.MIN_SAFE_INTEGER:** El entero negativo m√°s grande (en valor absoluto) que se puede representar de manera segura. Este valor es ‚àí(${2^{53}-1}$).
- **Number.MAX_VALUE:** El valor m√°s grande que se puede representar en JavaScript, aproximadamente 1.79ùëí+308. No es recomendable para c√°lculos precisos ya que valores m√°s all√° del rango seguro pueden conducir a imprecisiones.
- **Number.MIN_VALUE:** El valor m√°s peque√±o que se puede representar en JavaScript, que es aproximadamente 5ùëí‚àí324. Es importante notar que este no es un negativo, sino el positivo m√°s peque√±o.

**Utilizando Number.EPSILON**

Number.EPSILON: Representa la diferencia m√°s peque√±a posible entre un n√∫mero en JavaScript y el siguiente n√∫mero representable m√°s grande, que es ${2^{-52}}$. Es √∫til para c√°lculos que necesitan una precisi√≥n extremadamente alta y para evaluar la igualdad de n√∫meros de punto flotante.

### Valores Infinitos

En JavaScript, existen dos constantes especiales para representar valores infinitos: Infinity y -Infinity. Estas constantes son √∫tiles cuando necesitas trabajar con valores extremadamente grandes o peque√±os, que no pueden ser representados de manera precisa dentro de los l√≠mites normales de los n√∫meros en JavaScript.

**Constantes de Infinito**

Las dos constantes que representan valores infinitos en JavaScript son:

- **Number.POSITIVE_INFINITY** o **simplemente Infinity:** Representa el infinito positivo (+‚àû).
- **Number.NEGATIVE_INFINITY** o **simplemente -Infinity:** Representa el infinito negativo (-‚àû).

```js copy filename="JavaScript"
console.log(Number.POSITIVE_INFINITY); // Output: Infinity
console.log(Number.NEGATIVE_INFINITY); // Output: -Infinity
```

Estas constantes se comportan de la manera esperada en operaciones aritm√©ticas:

- Cualquier n√∫mero positivo multiplicado por Infinity resulta en Infinity.
- Cualquier n√∫mero negativo multiplicado por Infinity resulta en -Infinity.
- Dividir un n√∫mero positivo por Infinity resulta en 0.
- Dividir un n√∫mero negativo por Infinity resulta en -0.

### Comprobaciones Num√©ricas

En JavaScript, es fundamental realizar comprobaciones num√©ricas para asegurarse de que los valores se manejan de manera correcta y segura. Estas comprobaciones permiten verificar la naturaleza de las variables num√©ricas, como si son finitas, enteras o seguras. JavaScript proporciona varios m√©todos est√°ticos del objeto Number para realizar estas verificaciones.

**Verificar si un Valor es Finito**

El m√©todo Number.isFinite(number) se utiliza para comprobar si un valor es un n√∫mero finito. Esta funci√≥n devuelve true si el valor es finito y false si es infinito o no es un n√∫mero.

```js copy filename="JavaScript"
console.log(Number.isFinite(42)); // true
console.log(Number.isFinite(551.3)); // true
console.log(Number.isFinite(Infinity)); // false
console.log(Number.isFinite(-Infinity)); // false
console.log(Number.isFinite(NaN)); // false
console.log(Number.isFinite("42")); // false
```

En este ejemplo, Number.isFinite(42) devuelve true porque 42 es un n√∫mero finito. Sin embargo, Number.isFinite(Infinity) devuelve false porque Infinity no es un n√∫mero finito.

**Verificar si un Valor es Entero**

El m√©todo Number.isInteger(number) verifica si un valor es un n√∫mero entero. Devuelve true si el valor es un entero y false si es un n√∫mero decimal o no es un n√∫mero.

```js copy filename="JavaScript"
console.log(Number.isInteger(5)); // true
console.log(Number.isInteger(4.6)); // false
console.log(Number.isInteger(NaN)); // false
console.log(Number.isInteger(Infinity)); // false
console.log(Number.isInteger("5")); // false
```

En este ejemplo, Number.isInteger(5) devuelve true porque 5 es un n√∫mero entero, mientras que Number.isInteger(4.6) devuelve false porque 4.6 es un n√∫mero decimal.

**Verificar si un Valor es un Entero Seguro**

El m√©todo Number.isSafeInteger(number) verifica si un valor es un entero seguro. Un entero seguro es un n√∫mero que se puede representar con precisi√≥n en JavaScript, sin riesgo de perder precisi√≥n debido al formato de coma flotante de 64 bits. El rango de enteros seguros est√° definido entre Number.MIN_SAFE_INTEGER y Number.MAX_SAFE_INTEGER.

```js copy filename="JavaScript"
console.log(Number.isSafeInteger(9007199254740991)); // true
console.log(Number.isSafeInteger(9007199254740992)); // false
console.log(Number.isSafeInteger(1e15)); // true
console.log(Number.isSafeInteger(1e16)); // false
console.log(Number.isSafeInteger(Infinity)); // false
console.log(Number.isSafeInteger("9007199254740991")); // false
```

En este ejemplo, Number.isSafeInteger(9007199254740991) devuelve true porque el valor est√° dentro del rango seguro, mientras que Number.isSafeInteger(9007199254740992) devuelve false porque excede el rango seguro.

**Comprobaci√≥n en Algoritmos**

En algoritmos que manejan grandes cantidades de datos num√©ricos, es crucial asegurarse de que todos los valores utilizados sean v√°lidos y seguros para evitar errores y resultados imprecisos.

```js copy filename="JavaScript"
function calcularSuma(numeros) {
  let suma = 0;
  for (const numero de numeros) {
    if (!Number.isFinite(numero)) {
      throw new Error("N√∫mero no finito en la lista.");
    }
    suma += numero;
  }
  if (!Number.isSafeInteger(suma)) {
    throw new Error("La suma resultante no es un n√∫mero seguro.");
  }
  return suma;
}

try {
  const numeros = [1000000000000000, 2000000000000000, 3000000000000000];
  const suma = calcularSuma(numeros);
  console.log("La suma es:", suma);
} catch (error) {
  console.error(error.message);
}
```

En este ejemplo, se verifica que todos los n√∫meros en la lista sean finitos antes de sumarlos, y se asegura de que la suma resultante sea un n√∫mero seguro.

**Comparaci√≥n de N√∫meros de Punto Flotante**

Al trabajar con n√∫meros de punto flotante, las comparaciones directas pueden no ser precisas debido a los errores de redondeo. Es mejor usar un margen de error para las comparaciones.

```js copy filename="JavaScript"
function compararFlotantes(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

const num1 = 0.1 + 0.2;
const num2 = 0.3;

if (compararFlotantes(num1, num2)) {
  console.log("Los n√∫meros son iguales.");
} else {
  console.log("Los n√∫meros no son iguales.");
}
```

En este ejemplo, se usa Number.EPSILON para comparar los n√∫meros de punto flotante con un margen de error muy peque√±o, asegurando una comparaci√≥n m√°s precisa.

### Representaci√≥n Num√©rica

En JavaScript, la representaci√≥n num√©rica es fundamental para manejar adecuadamente los diversos formatos en los que se pueden presentar o requerir los n√∫meros en aplicaciones web y de software. JavaScript ofrece varios m√©todos para manipular la presentaci√≥n de n√∫meros, permitiendo cambiar entre notaci√≥n exponencial y notaci√≥n de punto fijo, adem√°s de ajustar la precisi√≥n de los n√∫meros.

**Notaci√≥n Exponencial**

La notaci√≥n exponencial es √∫til para representar n√∫meros extremadamente grandes o peque√±os de manera concisa. En JavaScript, se puede convertir un n√∫mero a notaci√≥n exponencial usando el m√©todo .toExponential(digits), donde digits es el n√∫mero de decimales despu√©s del punto.

```js copy filename="JavaScript"
let numero = 123456;
console.log(numero.toExponential(1)); // "1.2e+5"
console.log(numero.toExponential(3)); // "1.235e+5"
```

Este m√©todo redondea el n√∫mero a la cantidad especificada de d√≠gitos decimales y lo muestra en formato exponencial.

**Notaci√≥n de Punto Fijo**

La notaci√≥n de punto fijo es otra forma de representar n√∫meros, especificando el n√∫mero de d√≠gitos que se deben mostrar despu√©s del punto decimal. Esto se realiza con el m√©todo .toFixed(digits), que tambi√©n redondea el n√∫mero a la cantidad especificada de decimales.

```js copy filename="JavaScript"
let numeroFijo = 1.23456;
console.log(numeroFijo.toFixed(1)); // "1.2"
console.log(numeroFijo.toFixed(3)); // "1.235"
```

**Ajuste de Precisi√≥n**

Para especificar el n√∫mero total de d√≠gitos significativos que debe tener un n√∫mero, se puede utilizar el m√©todo .toPrecision(size). Este m√©todo ajusta la cantidad total de d√≠gitos en un n√∫mero, combinando d√≠gitos enteros y decimales, y decide la mejor forma de mostrar el n√∫mero (punto fijo o exponencial) basado en el tama√±o especificado.

```js copy filename="JavaScript"
let numeroPrecision = 12345.6789;
console.log(numeroPrecision.toPrecision(3)); // "1.23e+4"
console.log(numeroPrecision.toPrecision(5)); // "12346"
console.log(numeroPrecision.toPrecision(7)); // "12345.68"
```

Estos m√©todos proporcionan una flexibilidad considerable en c√≥mo se presentan los n√∫meros, permitiendo ajustes precisos para la visualizaci√≥n y manejo de datos num√©ricos en JavaScript. Si necesitas m√°s recursos o informaci√≥n adicional para enriquecer esta secci√≥n, puedo buscar libros en PDF o textos acad√©micos que sean √∫tiles para expandir y mejorar nuestra explicaci√≥n.

### ¬øQu√© es NaN (Not A Number)?

NaN, acr√≥nimo de "Not A Number" (No es un N√∫mero), es un valor especial dentro del universo de JavaScript utilizado para indicar que un resultado num√©rico esperado no pudo ser obtenido. Aunque el nombre sugiere que no es un n√∫mero, t√©cnicamente, NaN pertenece al tipo de datos num√©rico en JavaScript. Este valor es √∫nico en comparaci√≥n con otros valores num√©ricos, ya que no es igual a ning√∫n otro valor, incluido s√≠ mismo.

**Propiedades de NaN**

- **Tipo de dato num√©rico:** A pesar de su nombre, el tipo de NaN es number. Esto puede resultar confuso, pero es esencial para operaciones que esperan un tipo num√©rico aunque el resultado no sea definido matem√°ticamente.

```js copy filename="JavaScript"
console.log(typeof NaN); // "number"
```

- **Comparaci√≥n √∫nica:** NaN no es comparable de forma directa con ning√∫n otro valor, incluso con otro NaN. Esto significa que NaN === NaN y NaN == NaN resultan en false. La √∫nica forma de verificar de manera fiable si un valor es NaN es mediante Number.isNaN() o la funci√≥n global isNaN().

```js copy filename="JavaScript"
console.log(NaN === NaN); // false
console.log(Number.isNaN(NaN)); // true
```

**Generaci√≥n de NaN**

NaN puede resultar de operaciones que no tienen un resultado num√©rico l√≥gico:

- **Indeterminaciones matem√°ticas:** Como dividir cero entre cero.
- **Operaciones inv√°lidas:** Como sumar una cadena de texto no num√©rica a un n√∫mero.
- **Funciones matem√°ticas fuera de dominio:** Como calcular la ra√≠z cuadrada de un n√∫mero negativo en los reales.

```js copy filename="JavaScript"
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // NaN
console.log("texto" * 2); // NaN
```

**M√©todos Relacionados con NaN**

- **Number.isNaN():** M√©todo est√°tico que proporciona una verificaci√≥n precisa de NaN sin forzar la conversi√≥n de tipo.

```js copy filename="JavaScript"
console.log(Number.isNaN("texto")); // false
console.log(Number.isNaN(NaN)); // true
```

- **isNaN():** Funci√≥n global que intenta convertir el argumento a n√∫mero y verifica si el resultado es NaN. Puede dar resultados inesperados si la conversi√≥n es exitosa pero no deseada.

```js copy filename="JavaScript"
console.log(isNaN("123ABC")); // true, "123ABC" convierte a NaN
```

**Tratamiento de NaN en Operaciones**

Cuando NaN participa en operaciones aritm√©ticas, el resultado tambi√©n ser√° NaN, propagando as√≠ el error a trav√©s de c√°lculos sucesivos si no se maneja adecuadamente.

```js copy filename="JavaScript"
console.log(NaN + 10); // NaN
console.log(NaN * 32); // NaN
```

**Uso Pr√°ctico de NaN**

- **Validaciones:** NaN es √∫til para validar y manejar entradas que se suponen num√©ricas pero que podr√≠an no serlo, especialmente en aplicaciones web donde las entradas del usuario son impredecibles.

```js copy filename="JavaScript"
function procesarEntrada(usuarioInput) {
  const numero = parseFloat(usuarioInput);
  if (Number.isNaN(numero)) {
    return "La entrada debe ser num√©rica.";
  }
  return numero * 10;
}

console.log(procesarEntrada("abc")); // "La entrada debe ser num√©rica."
console.log(procesarEntrada("10")); // 100
```

### Conversiones Num√©ricas en JavaScript

En JavaScript, convertir diferentes tipos de datos a n√∫meros es una operaci√≥n fundamental, especialmente dado que JavaScript es un lenguaje de tipado din√°mico donde las conversiones de tipos pueden no ser tan expl√≠citas. Entender c√≥mo manejar estas conversiones es crucial para realizar operaciones matem√°ticas correctamente y para procesar adecuadamente la entrada de datos.

**M√©todos para Convertir Texto a N√∫meros**

JavaScript ofrece varios m√©todos y funciones para convertir cadenas y otros tipos de datos a n√∫meros. Estos m√©todos incluyen:

1. **Number.parseInt()**

La funci√≥n parseInt() en JavaScript es una herramienta esencial para convertir cadenas de texto en n√∫meros enteros. Su utilidad se extiende especialmente en escenarios donde los datos no vienen tipificados, como es com√∫n en JavaScript, un lenguaje de tipado d√©bil. Esto hace que parseInt() sea indispensable para preparar datos para operaciones matem√°ticas, conversiones de base num√©rica, entre otras necesidades.

**Funcionamiento de parseInt**

parseInt() analiza una cadena y devuelve un entero en la base especificada o en base decimal por defecto. Si el primer car√°cter no puede ser convertido a un n√∫mero, devuelve NaN. Esto lo convierte en una herramienta poderosa y a la vez delicada que requiere atenci√≥n en su uso para evitar resultados inesperados.

**Sintaxis y Uso**

La funci√≥n parseInt() puede ser utilizada de dos maneras principales:

- **parseInt(string):** Convierte string a un entero utilizando la base decimal.
- **parseInt(string, base):** Convierte string a un entero utilizando la base especificada, donde base es el sistema num√©rico (de 2 a 36).

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(parseInt("10")); // 10, interpretado como base 10
console.log(parseInt("10", 10)); // 10, expl√≠citamente en base 10
console.log(parseInt("10", 8)); // 8, interpretado como base 8
console.log(parseInt("10", 16)); // 16, interpretado como base 16
console.log(parseInt("1010", 2)); // 10, interpretado como binario
```

**Detalles de Implementaci√≥n**

- **Ignorar Caracteres No Num√©ricos:** parseInt() comienza a parsear desde el inicio de la cadena y contin√∫a hasta que encuentra un car√°cter que no es v√°lido en el sistema num√©rico especificado, en cuyo punto detiene el parseo y devuelve el n√∫mero parseado hasta ese momento.

```js copy filename="JavaScript"
console.log(parseInt("123abc")); // 123
console.log(parseInt("abc123")); // NaN, porque empieza con no num√©rico
console.log(parseInt("70 kg", 10)); // 70
```

- **Manejo de Decimales:** Si la cadena representa un n√∫mero decimal, parseInt() descartar√° cualquier fracci√≥n y devolver√° solo la parte entera.

```js copy filename="JavaScript"
console.log(parseInt("123.45")); // 123
console.log(parseInt("123.999")); // 123
console.log(parseInt("0.99")); // 0
```

**Aplicaciones Pr√°cticas de ParseInt()**

- **Extracci√≥n de N√∫meros de Cadenas en Formatos de Datos:** A menudo, especialmente en aplicaciones web, los datos num√©ricos vienen incorporados en cadenas con unidades o etiquetas, donde parseInt() puede ser utilizado para extraer el n√∫mero puro.

```js copy filename="JavaScript"
function extraerNumeroDeCadena(cadena) {
  return parseInt(cadena);
}

console.log(extraerNumeroDeCadena("200px")); // 200
console.log(extraerNumeroDeCadena("ID123")); // NaN, comienza con no num√©rico
```

- **Conversi√≥n de Bases Num√©ricas: parseInt()** es √∫til para convertir cadenas en diferentes bases a un n√∫mero decimal, lo que es esencial en computaci√≥n y electr√≥nica.

```js copy filename="JavaScript"
function convertirBase(cadena, base) {
  return parseInt(cadena, base);
}

console.log(convertirBase("ff", 16)); // 255
console.log(convertirBase("110", 2)); // 6
```

<Callout emoji="üëÄ" type="error">
  **OJO:** Estos ejemplos subrayan la flexibilidad y potencia de parseInt() para
  la conversi√≥n de cadenas a n√∫meros enteros en JavaScript. Es una herramienta
  vital para la manipulaci√≥n y preparaci√≥n de datos en un entorno no tipificado,
  permitiendo realizar operaciones num√©ricas y t√©cnicas efectivas con datos
  inicialmente representados como cadenas.
</Callout>

2. **Number.parseFloat()**

parseFloat() es una funci√≥n en JavaScript dise√±ada espec√≠ficamente para la conversi√≥n de cadenas a n√∫meros de punto flotante. A diferencia de parseInt(), que solo devuelve la parte entera de un n√∫mero, parseFloat() es capaz de mantener la precisi√≥n decimal, lo que es crucial para operaciones matem√°ticas que requieren exactitud en los decimales.

**Funcionamiento de parseFloat**

La funci√≥n parseFloat() analiza una cadena desde el principio hasta que encuentra un car√°cter que no se puede interpretar como parte de un n√∫mero. Si el primer car√°cter no puede ser convertido a un n√∫mero, la funci√≥n devuelve NaN.

**Sintaxis y Uso**

```js copy filename="JavaScript"
parseFloat(string);
```

**string:** Cadena de caracteres que se desea convertir a un n√∫mero de punto flotante.

**Caracter√≠sticas Principales de ParseFloat()**

1. **Retenci√≥n de Decimales:** A diferencia de parseInt(), parseFloat() interpreta y retiene cualquier parte decimal del n√∫mero, lo que la hace ideal para datos financieros, cient√≠ficos y cualquier otro uso donde los decimales son necesarios.

2. **Ignora Espacios Iniciales:** Los espacios blancos al inicio de la cadena son ignorados autom√°ticamente por parseFloat().

3. **Terminaci√≥n al Encontrar un Car√°cter no Num√©rico:** Si parseFloat() encuentra un car√°cter que no puede formar parte de un n√∫mero, detiene el an√°lisis y devuelve el n√∫mero formado hasta ese punto. Si no encuentra ning√∫n car√°cter num√©rico al inicio, devuelve NaN.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(parseFloat("10.50")); // 10.5
console.log(parseFloat("3.14159")); // 3.14159
console.log(parseFloat("0.0314E+2")); // 3.14
console.log(parseFloat("314e-2")); // 3.14
console.log(parseFloat("  123.45")); // 123.45
console.log(parseFloat("123.45kg")); // 123.45
console.log(parseFloat("abc123.45")); // NaN, comienza con caracteres no num√©ricos
```

**Conversi√≥n entre Bases Num√©ricas**

Las conversiones entre bases num√©ricas son fundamentales en muchas aplicaciones de programaci√≥n, desde criptograf√≠a hasta manejo de permisos en sistemas operativos. JavaScript facilita estas conversiones a trav√©s de m√©todos incorporados como parseInt() para conversiones a decimal y toString() para convertir desde decimal a otras bases.

1. ¬øQu√© es una Base Num√©rica?

Una base num√©rica es el n√∫mero de d√≠gitos √∫nicos, incluyendo el cero, que un sistema num√©rico utiliza para representar n√∫meros. La m√°s familiar para nosotros es la base decimal (base 10), pero otros sistemas como el binario (base 2), el octal (base 8) y el hexadecimal (base 16) son esenciales en computaci√≥n.

- **Conversi√≥n de Otras Bases a Decimal:** Para convertir un n√∫mero de cualquier base a decimal, se utiliza parseInt(string, base), donde string es la representaci√≥n en cadena del n√∫mero y base es la base del n√∫mero original.

```js copy filename="JavaScript"
// Binario a Decimal
console.log(parseInt("11101", 2)); // 29

// Octal a Decimal
console.log(parseInt("31", 8)); // 25

// Hexadecimal a Decimal
console.log(parseInt("FF", 16)); // 255
```

- **Conversi√≥n desde Decimal a Otra Base:** Para convertir un n√∫mero decimal a otra base, se usa el m√©todo number.toString(base). Este m√©todo devuelve una cadena que representa el n√∫mero original en la base especificada.

```js copy filename="JavaScript"
// Decimal a Binario
console.log((26).toString(2)); // "11010"

// Decimal a Octal
console.log((80).toString(8)); // "120"

// Decimal a Hexadecimal
console.log((245123).toString(16)); // "3bd83"
```

2. **Utilizaci√≥n de Prefijos en Literales Num√©ricos**

JavaScript tambi√©n soporta literales num√©ricos con prefijos que indican la base del n√∫mero, lo cual simplifica la conversi√≥n autom√°tica a decimal durante la ejecuci√≥n del c√≥digo.

```js copy filename="JavaScript"
// Binario con prefijo 0b
console.log(0b11101); // 29

// Octal con prefijo 0o
console.log(0o31); // 25

// Hexadecimal con prefijo 0x
console.log(0xff); // 255
```

**Aplicaciones Pr√°cticas**

1. **Validaci√≥n de Entradas**

Es com√∫n necesitar validar y convertir datos ingresados como cadenas a un formato num√©rico espec√≠fico para c√°lculos o l√≥gica de control.

```js copy filename="JavaScript"
function validarYConvertir(input, base) {
  let numero = parseInt(input, base);
  return isNaN(numero) ? "Entrada inv√°lida" : numero;
}

console.log(validarYConvertir("11101", 2)); // 29
console.log(validarYConvertir("XYZ", 16)); // 'Entrada inv√°lida'
```

2. **Formateo y Presentaci√≥n de Datos**

Convertir n√∫meros a diferentes bases puede ser √∫til para mostrar datos de manera que sean m√°s comprensibles o relevantes para una aplicaci√≥n espec√≠fica, como mostrar permisos de archivos en notaci√≥n octal o direcciones de memoria en hexadecimal.

```js copy filename="JavaScript"
function mostrarComoHexadecimal(numero) {
  return numero.toString(16);
}

console.log(mostrarComoHexadecimal(255)); // "ff"
```

<Callout emoji="üëÄ" type="error">
  **OJO:** Estas t√©cnicas subrayan c√≥mo JavaScript maneja la conversi√≥n de
  n√∫meros entre diversas bases num√©ricas, proporcionando flexibilidad y potencia
  para aplicaciones que necesitan manejar diferentes sistemas num√©ricos
</Callout>

### El objeto Math

El objeto Math de JavaScript proporciona una serie de propiedades y m√©todos que facilitan la realizaci√≥n de tareas matem√°ticas. Este objeto no es un constructor y todos sus m√©todos son est√°ticos, accesibles directamente desde el objeto Math.

**Constantes de Math**

El objeto Math incluye varias constantes matem√°ticas √∫tiles que pueden ser necesarias en diversas aplicaciones matem√°ticas:

- **Math.E:** El n√∫mero de Euler, la base de los logaritmos naturales, aproximadamente 2.718.
- **Math.PI:** El n√∫mero œÄ, aproximadamente 3.14159, √∫til en c√°lculos geom√©tricos y trigonom√©tricos.
- **Math.SQRT2:** La ra√≠z cuadrada de 2, aproximadamente 1.414, √∫til en c√°lculos de geometr√≠a.
- **Math.SQRT1_2:** La ra√≠z cuadrada de 1/2, aproximadamente 0.707, tambi√©n utilizada en c√°lculos geom√©tricos.

Estas constantes son esenciales para garantizar la precisi√≥n y facilitar el acceso a valores que de otro modo requerir√≠an c√°lculos complicados o tablas de b√∫squeda.

**M√©todos Matem√°ticos de Math**

Math proporciona una amplia gama de funciones que son fundamentales en casi todos los campos de la programaci√≥n que requieren matem√°ticas, desde simples c√°lculos hasta operaciones complejas:

1. **M√©todo Math.abs(x)**

El m√©todo Math.abs(x) en JavaScript es utilizado para obtener el valor absoluto de un n√∫mero, x. El valor absoluto de un n√∫mero es su valor sin considerar el signo. Por ejemplo, tanto para -5 como para 5, el valor absoluto es 5.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.abs(-10); // Retorna 10
Math.abs(5); // Retorna 5
```

Este m√©todo es especialmente √∫til en situaciones donde necesitas garantizar que est√°s trabajando con valores no negativos, como en c√°lculos de distancias o en algoritmos que requieren valores absolutos para su l√≥gica.

2. **M√©todo Math.sign(x)**

El m√©todo Math.sign(x) es usado para determinar el signo de un n√∫mero que puede ser positivo, negativo o cero. Este m√©todo retorna 1 para n√∫meros positivos, -1 para n√∫meros negativos, y 0 para el n√∫mero cero.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.sign(-20); // Retorna -1
Math.sign(20); // Retorna 1
Math.sign(0); // Retorna 0
```

Math.sign es √∫til para ajustar la l√≥gica de control en funciones y algoritmos donde el signo del n√∫mero afecta el flujo del proceso o el resultado final, como en m√©todos de ordenamiento o en simulaciones f√≠sicas.

3. **M√©todo Math.exp(x)**

Este m√©todo devuelve e elevado a la potencia de x, donde e es la base de los logaritmos naturales, aproximadamente igual a 2.71828. Este es un exponente constante utilizado en muchos c√°lculos en ciencias e ingenier√≠a. La funci√≥n es especialmente √∫til para c√°lculos en los que se necesita crecimiento exponencial o decaimiento, como modelar poblaciones o inter√©s compuesto.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.exp(1)); // Aproximadamente 2.71828
console.log(Math.exp(0)); // 1
console.log(Math.exp(-1)); // Aproximadamente 0.36788
```

4. **M√©todo Math.expm1(x)**

Math.expm1(x) es una funci√≥n relacionada que calcula e elevado a la potencia de x, menos 1. Es decir, devuelve Math.exp(x) - 1. Esto es √∫til para c√°lculos que requieren alta precisi√≥n en rangos donde x es muy peque√±o. Cuando x es peque√±o, Math.exp(x) se acerca a 1 muy de cerca, y restar 1 de un n√∫mero cercano a 1 puede llevar a una p√©rdida significativa de precisi√≥n. Math.expm1(x) maneja esto de manera m√°s precisa.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.expm1(1)); // Aproximadamente 1.71828
console.log(Math.expm1(0)); // 0
console.log(Math.expm1(-1)); // Aproximadamente -0.63212
```

5. **M√©todo Math.max**

Este m√©todo devuelve el mayor de los argumentos que recibe. Si alguno de los argumentos no es un n√∫mero y no puede ser convertido en uno, devolver√° NaN.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.max(3, 1, 2); // Devuelve 3
Math.max(-10, -20, -30); // Devuelve -10
Math.max(0, 150, 30); // Devuelve 150
Math.max(); // Devuelve -Infinity
```

Este m√©todo es especialmente √∫til cuando necesitas asegurar que un valor no caiga por debajo de un cierto m√≠nimo o no exceda un cierto m√°ximo al comparar din√°micamente m√∫ltiples valores.

6. **M√©todo Math.min**

El m√©todo Math.min funciona de manera similar a Math.max pero devuelve el menor de los argumentos. Si no se proporcionan argumentos, devuelve Infinity, lo cual es √∫til para comparaciones cuando se inicializan variables en ciclos de optimizaci√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
Math.min(3, 1, 2); // Devuelve 1
Math.min(-10, -20, -30); // Devuelve -30
Math.min(0, 150, 30); // Devuelve 0
Math.min(); // Devuelve Infinity
```

Estos m√©todos pueden ser extremadamente √∫tiles en muchos contextos de programaci√≥n, desde la optimizaci√≥n de rendimiento y la validaci√≥n de datos, hasta su uso en algoritmos matem√°ticos y estad√≠sticos.

Por ejemplo, si est√°s desarrollando una funci√≥n para encontrar el rango de valores en un conjunto de datos, puedes usar ambos m√©todos para determinar los l√≠mites superior e inferior del rango.

```js copy filename="JavaScript"
function calcularRango(valores) {
  return Math.max(...valores) - Math.min(...valores);
}

// Uso de la funci√≥n
console.log(calcularRango([3, 7, 9, 1])); // Devuelve 8
```

Este c√≥digo define una funci√≥n calcularRango que calcula la diferencia entre el valor m√°ximo y m√≠nimo de un array de n√∫meros, ilustrando una aplicaci√≥n pr√°ctica de Math.max y Math.min para resolver problemas espec√≠ficos en JavaScript.

7. **M√©todo Math.pow(base, exp)**

El m√©todo Math.pow(base, exp) es una funci√≥n incorporada en JavaScript que se utiliza para calcular una base elevada a la potencia de un exponente. Es fundamental en situaciones donde necesitas realizar c√°lculos de potenciaci√≥n r√°pidos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let resultadoPotencia = Math.pow(5, 3);
console.log(resultadoPotencia); // Imprime 125
```

Este ejemplo muestra c√≥mo elevar 5 a la potencia de 3. Este m√©todo es extremadamente √∫til en c√°lculos matem√°ticos que requieren exponenciaci√≥n, como en c√°lculos financieros, computaciones cient√≠ficas o incluso en algoritmos de gr√°ficos.

8. **M√©todo Math.sqrt(x)**

Por otro lado, Math.sqrt(x) calcula la ra√≠z cuadrada de un n√∫mero. Este m√©todo es esencial para operaciones que necesitan determinar la ra√≠z cuadrada de un n√∫mero, como en c√°lculos estad√≠sticos, resoluci√≥n de ecuaciones en f√≠sica, o en algoritmos de machine learning para calcular distancias euclidianas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let resultadoRaiz = Math.sqrt(144);
console.log(resultadoRaiz); // Imprime 12
```

Este ejemplo demuestra la obtenci√≥n de la ra√≠z cuadrada de 144, resultando en 12. Es una herramienta vital en √°reas donde la normalizaci√≥n o la estandarizaci√≥n de datos es requerida.

9. **M√©todo Math.cbrt(x)**

El m√©todo Math.cbrt(x) calcula la ra√≠z c√∫bica de un n√∫mero x. Este m√©todo es √∫til cuando necesitas determinar el valor de un n√∫mero elevado al cubo. Por ejemplo, si est√°s trabajando con vol√∫menes en un contexto geom√©trico o f√≠sico y conoces el volumen de un cubo, puedes usar Math.cbrt(x) para encontrar la longitud de los lados del cubo.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que est√°s calculando el tama√±o de un contenedor c√∫bico que tiene un volumen de 27 metros c√∫bicos. Podr√≠as usar Math.cbrt(27) para encontrar que cada lado del cubo mide 3 metros.

```js copy filename="JavaScript"
let volumen = 27;
let lado = Math.cbrt(volumen);
console.log(lado); // Output: 3
```

10. **M√©todo Math.imul(a, b)**

El m√©todo Math.imul(a, b) realiza una multiplicaci√≥n de 32 bits de dos argumentos, a y b. Este m√©todo es particularmente √∫til para ciertas operaciones de bajo nivel que requieren precisi√≥n en la manipulaci√≥n de enteros, como en gr√°ficos computacionales o algoritmos que dependen de operaciones aritm√©ticas exactas a nivel de bits.

<h4 className="font-medium mt-5">Ejemplo</h4>

Si est√°s desarrollando un juego y necesitas calcular posiciones de p√≠xeles o manipular datos gr√°ficos en el que cada operaci√≥n cuenta para el rendimiento, Math.imul() puede ser crucial para asegurar que las operaciones sean eficientes y precisas.

```js copy filename="JavaScript"
let factor1 = 65536;
let factor2 = 65536;
let resultado = Math.imul(factor1, factor2);
console.log(resultado); // Output depende de la arquitectura, posiblemente 0 debido a overflow
```

11. **M√©todo Math.clz32(x)**

El m√©todo Math.clz32() devuelve el n√∫mero de ceros a la izquierda en la representaci√≥n binaria de 32 bits de un n√∫mero. clz32 significa "count leading zero bits in 32-bit binary representation." Este m√©todo es √∫til para determinar la cantidad de ceros que preceden a la parte significativa de un n√∫mero. Es especialmente relevante en aplicaciones de bajo nivel que interact√∫an con datos binarios, donde la posici√≥n del primer bit significativo es importante.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(Math.clz32(1)); // 31, porque en binario 1 es 000...0001, con 31 ceros delante
console.log(Math.clz32(1000)); // 22, porque en binario 1000 tiene 22 ceros al inicio
console.log(Math.clz32(0)); // 32, un caso especial, todos son ceros
```

**M√©todo Math.random()**

El m√©todo Math.random() es una herramienta esencial en JavaScript para generar n√∫meros pseudoaleatorios. Aqu√≠, te proporciono una exploraci√≥n detallada de c√≥mo funciona y algunos ejemplos pr√°cticos para utilizarlo eficazmente en diversos escenarios.

- **Caracter√≠sticas del M√©todo Math.random()**

Math.random() genera un n√∫mero flotante aleatorio en el rango de 0 (inclusive) hasta casi 1 (exclusivo), con hasta 16 decimales de precisi√≥n. Este comportamiento lo hace incre√≠blemente √∫til para todo tipo de aplicaciones de programaci√≥n que requieren elementos de aleatoriedad.

- **Generaci√≥n B√°sica de N√∫meros Aleatorios**

La funci√≥n Math.random() por s√≠ sola simplemente devuelve un n√∫mero entre 0 y 1. Esto es √∫til para simular probabilidades o para operaciones que requieren una selecci√≥n aleatoria dentro de un rango muy limitado.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let randomNumber = Math.random();
console.log(randomNumber);
```

- **Uso Avanzado: Generaci√≥n de N√∫meros Enteros Aleatorios**

Para utilizar Math.random() para generar un n√∫mero entero dentro de un rango espec√≠fico, se puede adaptar utilizando multiplicaciones y la funci√≥n Math.floor() para redondear hacia abajo al n√∫mero entero m√°s cercano.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let randomInt = Math.floor(Math.random() * 5);
console.log(randomInt);
```

- **Optimizaci√≥n de la Generaci√≥n de N√∫meros Aleatorios**

Para casos donde se necesita un redondeo m√°s eficiente sin la sobrecarga de Math.floor(), puedes utilizar el operador de doble negaci√≥n bitwise ~~, que es una forma r√°pida de descartar la parte decimal de un n√∫mero:

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let quickRandomInt = ~~(Math.random() * 5);
console.log(quickRandomInt);
```

Esta t√©cnica es especialmente √∫til en entornos de alto rendimiento donde cada milisegundo de ejecuci√≥n cuenta, como en juegos o aplicaciones gr√°ficas intensivas.

**M√©todos de logaritmos**

En JavaScript, el objeto Math proporciona m√©todos para c√°lculos matem√°ticos avanzados que incluyen varias funciones de logaritmos.

1. **Math.log(x)**

x. Este es un c√°lculo fundamental en muchos problemas matem√°ticos, especialmente en aquellos que involucran crecimiento exponencial o descomposici√≥n, como en finanzas para calcular intereses compuestos, en biolog√≠a para modelar crecimiento de poblaciones, o en f√≠sica para decaimiento radioactivo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Logaritmo natural de 10
console.log(Math.log(10)); // Aproximadamente 2.3026
```

2. **Math.log10(x)**

Por otro lado, Math.log10(x) calcula el logaritmo decimal (en base 10) de un n√∫mero ùë•. Este m√©todo es √∫til cuando necesitas determinar cu√°ntas veces tienes que multiplicar 10 para llegar a ùë•. Es com√∫n en ciencias para medir la acidez (pH), en ingenier√≠a para decibelios en medidas de sonido, o en astronom√≠a para escalas de magnitud estelar.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Logaritmo base 10 de 100
console.log(Math.log10(100)); // Exactamente 2
```

3. **Math.log2(x)**

El m√©todo Math.log2(x) calcula el logaritmo base 2 de un n√∫mero ùë•. Este c√°lculo es fundamental en campos como ciencias de la computaci√≥n y tecnolog√≠a de la informaci√≥n, donde los logaritmos base 2 se utilizan para determinar la eficiencia de algoritmos, especialmente aquellos que se dividen a la mitad progresivamente, como los algoritmos de b√∫squeda y ordenamiento.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que necesitas determinar el n√∫mero de niveles en una estructura de datos de √°rbol binario completo. Si tienes ùëõ elementos, el n√∫mero de niveles ùêø necesarios para almacenar estos elementos en un √°rbol binario es aproximadamente Math.log2(n) + 1.

```js copy filename="JavaScript"
function calcularNiveles(n) {
  return Math.ceil(Math.log2(n) + 1);
}
console.log(calcularNiveles(1024)); // Resultado: 11
```

4. **Math.log1p(x)**

Math.log1p(x) es particularmente √∫til para c√°lculos en los que
ùë• es muy peque√±o y los resultados de log(1+ùë•) pueden ser inexactos debido a la precisi√≥n de punto flotante. Este m√©todo es ampliamente utilizado en an√°lisis financiero, estad√≠sticas y ciencias de la salud para modelos que dependen de crecimiento logar√≠tmico o ajustes exponenciales.

<h4 className="font-medium mt-5">Ejemplo</h4>

En estad√≠sticas, Math.log1p(x) es crucial para transformar datos que incluyen valores cercanos a cero, lo cual es com√∫n en medidas de concentraciones qu√≠micas o biol√≥gicas en experimentos cient√≠ficos.

```js copy filename="JavaScript"
function transformarDatos(dato) {
  return Math.log1p(dato);
}
console.log(transformarDatos(0.000001)); // Resultado: un n√∫mero muy peque√±o cercano a 0.000001
```

**M√©todos de redondeo**

Como hemos visto anteriormente, es muy com√∫n necesitar m√©todos para redondear n√∫meros y reducir el n√∫mero de decimales o aproximar a una cifra concreta. Para ello, de forma nativa, Javascript proporciona los siguientes m√©todos de redondeo:

1. **Math.round(x)**

El m√©todo Math.round(x) se utiliza para redondear un n√∫mero al entero m√°s cercano. En el caso de n√∫meros que est√°n exactamente a mitad de camino entre dos enteros, sigue la regla del redondeo sim√©trico alejado de cero en la mayor√≠a de los casos, lo que significa que redondea al entero m√°s cercano con preferencia por un resultado positivo infinito en caso de empate.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que queremos redondear algunos valores para comprender c√≥mo funciona este m√©todo:

```js copy filename="JavaScript"
console.log(Math.round(0.9)); // Resultado: 1
console.log(Math.round(1.2)); // Resultado: 1
console.log(Math.round(1.5)); // Resultado: 2
console.log(Math.round(1.95)); // Resultado: 2
console.log(Math.round(-1.5)); // Resultado: -1
```

2. **Math.ceil(x)**

El m√©todo Math.ceil(x), por otro lado, siempre redondea un n√∫mero hacia arriba al pr√≥ximo entero mayor, independientemente de la fracci√≥n. Esto es especialmente √∫til en situaciones donde necesitamos asegurar que un n√∫mero sea redondeado hacia arriba para evitar subestimaciones en c√°lculos cr√≠ticos, como dimensionamientos y contabilizaciones.

<h4 className="font-medium mt-5">Ejemplo</h4>

Veamos c√≥mo Math.ceil(x) act√∫a sobre varios n√∫meros:

```js copy filename="JavaScript"
console.log(Math.ceil(0.1)); // Resultado: 1
console.log(Math.ceil(1.2)); // Resultado: 2
console.log(Math.ceil(1.5)); // Resultado: 2
console.log(Math.ceil(1.99)); // Resultado: 2
console.log(Math.ceil(-1.5)); // Resultado: -1
```

3. **Math.floor(x)**

El m√©todo Math.floor(x) redondea un n√∫mero x hacia abajo, es decir, al entero m√°s cercano menor que o igual a x. Este m√©todo es muy √∫til cuando necesitas eliminar cualquier fracci√≥n decimal de un n√∫mero, especialmente en c√°lculos que requieren valores enteros como √≠ndices de matriz, iteraciones de bucle, entre otros.

<h4 className="font-medium mt-5">Ejemplo</h4>

Supongamos que est√°s implementando una funci√≥n que distribuye √≠tems en diferentes categor√≠as basadas en rangos de precios que aumentan en incrementos de 50. Usar Math.floor() puede ayudar a asignar un precio a la categor√≠a correcta:

```js copy filename="JavaScript"
function categorizarPrecio(precio) {
  return Math.floor(precio / 50);
}

console.log(categorizarPrecio(137)); // Imprime 2, correspondiente al rango de 100-149
console.log(categorizarPrecio(49)); // Imprime 0, correspondiente al rango 0-49
```

4. **Math.fround(x)**

El m√©todo Math.fround(x) devuelve la representaci√≥n flotante de precisi√≥n simple m√°s cercana de un n√∫mero x. Esto es √∫til en contextos donde la precisi√≥n de doble punto flotante no es necesaria o donde operaciones de precisi√≥n simple pueden ser m√°s r√°pidas dependiendo del hardware y el navegador.

<h4 className="font-medium mt-5">Ejemplo</h4>

En aplicaciones gr√°ficas o de simulaci√≥n, a veces la precisi√≥n de doble punto no es requerida, y el uso de Math.fround() puede optimizar el rendimiento:

```js copy filename="JavaScript"
function calcularDistancia(velocidad, tiempo) {
  return Math.fround(velocidad * tiempo);
}

console.log(calcularDistancia(0.1, 0.2)); // Resultado aproximado con precisi√≥n simple
```

5. **Math.trunc(x)**

Por otro lado, Math.trunc(x) simplemente elimina la parte decimal de un n√∫mero, sin importar si los decimales son mayores o menores que .5. Este m√©todo es esencial cuando simplemente deseas truncar un n√∫mero para obtener su parte entera, sin realizar ning√∫n tipo de redondeo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Truncando el n√∫mero
console.log(Math.trunc(3.95)); // Resultado: 3
console.log(Math.trunc(4.75)); // Resultado: 4
console.log(Math.trunc(-1.5)); // Resultado: -1
```

Aqu√≠, Math.trunc() elimina los decimales de cualquier n√∫mero proporcionado, lo que es especialmente notable en el caso de los n√∫meros negativos, donde simplemente se descarta la parte decimal.

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øQu√© valor tiene Number.MAX_VALUE en JavaScript?
</h4>

<p className="my-2">a) ${2^{1024}}$</p>
<p>b) El valor m√°s grande posible que JavaScript puede representar</p>
<p className="my-2">c) 1.7976931348623157√ó${10^{308}}$</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 1.7976931348623157√ó${10^{308}}$</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">2. ¬øQu√© devuelve parseInt("7*6", 10)?</h4>

<p className="my-2">a) 42</p>
<p>b) 7</p>
<p className="my-2">b) NaN</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 7</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øQu√© m√©todo se utilizar√≠a para convertir 123456789n a un n√∫mero regular,
  asumiendo que est√° dentro del rango seguro?
</h4>

<p className="my-2">a) BigInt.toNumber()</p>
<p>b) Number()</p>
<p className="my-2">c) No es posible convertir BigInt a Number</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Number()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">4. ¬øQu√© resultado produce Math.round(4.7)?</h4>

<p className="my-2">a) 4</p>
<p>b) 5</p>
<p className="my-2">c) 4.5</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 5</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l de las siguientes no es una representaci√≥n v√°lida de un n√∫mero en
  JavaScript?
</h4>

<p className="my-2">a) 0x1A</p>
<p>b) 2e10</p>
<p className="my-2">c) 000123</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 000123</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo generar√≠as un n√∫mero aleatorio entero entre 1 y 10?
</h4>

<p className="my-2">a) Math.floor(Math.random() * 10) + 1</p>
<p>b) Math.ceil(Math.random() * 10)</p>
<p className="my-2">c) Math.round(Math.random() * 10)</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) Math.floor(Math.random() * 10) + 1</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© m√©todo de BigInt se utilizar√≠a para asegurar que un n√∫mero sea tratado
  como entero sin signo de 8 bits?
</h4>

<p className="my-2">a) BigInt.asIntN(8, value)</p>
<p>b) BigInt.asUintN(8, value)</p>
<p className="my-2">c) BigInt.toUint8(value)</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) BigInt.asUintN(8, value)</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">8. ¬øQu√© devuelve Math.log10(100)?</h4>

<p className="my-2">a) 10</p>
<p>b) 2</p>
<p className="my-2">c) 1</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) 2</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øQu√© sucede cuando ejecutas Number.isNaN('NaN')?
</h4>

<p className="my-2">a) True</p>
<p>b) False</p>
<p className="my-2">c) TypeError</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) False</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øCu√°l de las siguientes es correcta para obtener la ra√≠z c√∫bica de 27 en
  JavaScript?
</h4>

<p className="my-2">a) Math.pow(27, 1/3)</p>
<p>b) Math.sqrt(27)</p>
<p className="my-2">c) Math.cbrt(27)</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Math.cbrt(27)</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© es Number.MAX_SAFE_INTEGER en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Es la constante que representa el m√°ximo valor entero seguro que JavaScript puede manejar sin perder precisi√≥n, equivalente a ${2^{53}-1}$

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øCu√°l es la diferencia entre Number y BigInt en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Number maneja valores num√©ricos dentro de un cierto rango y con limitaciones de precisi√≥n, mientras que BigInt permite trabajar con enteros muy grandes m√°s all√° del rango seguro de Number.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øC√≥mo se puede convertir un string a un n√∫mero en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Se puede utilizar parseInt() para obtener una representaci√≥n entera, o parseFloat() para obtener un n√∫mero con decimales.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. Explica el resultado de 0.1 + 0.2 === 0.3 en JavaScript.
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Esta expresi√≥n devuelve false debido a la imprecisi√≥n de la representaci√≥n de n√∫meros flotantes en JavaScript.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øQu√© m√©todo usar√≠as para obtener el valor absoluto de un n√∫mero en
  JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Se usar√≠a el m√©todo Math.abs().

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo generas un n√∫mero aleatorio entre 0 y 50 en JavaScript?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Utilizando Math.random() multiplicado por 50 y luego aplicando Math.floor() al resultado para obtener un entero.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© sucede si intentas sumar un BigInt y un Number directamente?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      JavaScript lanzar√° un TypeError, ya que no permite operaciones directas entre BigInt y Number sin una conversi√≥n expl√≠cita.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øPara qu√© se utiliza el m√©todo Number.isNaN() y c√≥mo se diferencia de isNaN() global?

</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Number.isNaN() es m√°s estricto y solo devuelve true para el valor NaN. El isNaN() global convierte el argumento en un n√∫mero, lo que puede llevar a resultados verdaderos para valores no num√©ricos que se comportan como NaN tras la conversi√≥n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øCu√°l es la utilidad de Math.pow() y c√≥mo se podr√≠a replicar su
  funcionalidad con operadores en ES6 o superior?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Math.pow(a, b) eleva a a la potencia de b. En ES6, se puede replicar con el operador de exponenciaci√≥n **, como en a ** b.


    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. Explica la diferencia entre Math.floor() y Math.ceil().
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Math.floor() redondea hacia abajo, hacia el entero m√°s cercano, mientras que Math.ceil() redondea hacia arriba, hacia el entero m√°s cercano.

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Escribe un programa que calcule y muestre el √°rea de un c√≠rculo con un
  radio de 7 usando Math.PI.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const radio = 7;
        const area = Math.PI * radio ** 2;
        console.log(area);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Genera un n√∫mero aleatorio entre 50 y 100.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const aleatorio = Math.floor(Math.random() * 51) + 50;
        console.log(aleatorio);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  3. Utiliza BigInt para calcular ${2^{128}}$ sin perder precisi√≥n.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const resultado = 2n ** 128n;
        console.log(resultado.toString());
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Redondea 6.25 a la unidad m√°s cercana usando Math.round().
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const redondeado = Math.round(6.25);
        console.log(redondeado);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  5. Convierte "123.456" en un n√∫mero entero.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const numero = parseInt("123.456");
        console.log(numero);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  6. Verifica si 9007199254740991 es un entero seguro en JavaScript.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const esSeguro = Number.isSafeInteger(9007199254740991);
        console.log(esSeguro);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">7. Calcula el logaritmo base 10 de 1000.</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const log10 = Math.log10(1000);
        console.log(log10);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  8. Usa Math.ceil() para redondear 7.004 al entero m√°s alto.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const redondeoAlto = Math.ceil(7.004);
        console.log(redondeoAlto);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  9. Determina el m√°ximo y el m√≠nimo de los n√∫meros 4, 19, 8, 1 y 4 usando
  Math.max() y Math.min().
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const maximo = Math.max(4, 19, 8, 1, 4);
        const minimo = Math.min(4, 19, 8, 1, 4);
        console.log(`M√°ximo: ${maximo}, M√≠nimo: ${minimo}`);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  10. Convierte 123456789123456789n (BigInt) a un tipo Number, si es seguro
  hacerlo.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const bigNumber = 123456789123456789n;
        let convertedNumber;
        if (bigNumber <= Number.MAX_SAFE_INTEGER) {
          convertedNumber = Number(bigNumber);
        } else {
          console.log('Conversi√≥n no segura');
        }
        console.log(convertedNumber);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## BigInt

BigInt es un tipo de dato en JavaScript dise√±ado para manejar n√∫meros enteros extremadamente grandes que sobrepasan los l√≠mites del tipo de dato Number. Con BigInt, puedes realizar operaciones matem√°ticas precisas con grandes enteros sin temor a perder precisi√≥n, lo cual es crucial en √°reas como la criptograf√≠a, la ciencia de datos y cualquier aplicaci√≥n que requiera manejar grandes n√∫meros.

**Caracter√≠sticas de BigInt**

- **Creaci√≥n:** Para crear un BigInt, puedes a√±adir n al final de un n√∫mero entero literal o usar el constructor BigInt() para convertir un Number o string a un BigInt.
- **Precisi√≥n:** BigInt permite representar y operar con n√∫meros enteros m√°s grandes que el l√≠mite de 2^53 - 1, que es el valor m√°ximo seguro que JavaScript puede representar con el tipo Number.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Crear un BigInt utilizando la notaci√≥n literal
let largeNumber = 1234567890123456789012345678901234567890n;

// Crear un BigInt a partir de un string
let fromString = BigInt("1234567890123456789012345678901234567890");

// Operaciones aritm√©ticas con BigInt
console.log(largeNumber + fromString); // Suma de BigInts
```

**Operaciones con BigInt**

Dado que BigInt es un tipo diferente, no puedes mezclar operaciones directamente entre BigInt y Number. Cualquier operaci√≥n matem√°tica debe realizarse entre valores del mismo tipo, es decir, o entre BigInts o entre Numbers.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const firstBigNumber = 9007199254740991n;
const secondBigNumber = 10n;

// Operaci√≥n v√°lida: sumando BigInts
console.log(firstBigNumber + secondBigNumber); // 9007199254741001n

// Operaci√≥n inv√°lida: sumando BigInt y Number
// console.log(firstBigNumber + 10);  // Error
```

### Mezcla de Tipos de Datos

En JavaScript, mezclar diferentes tipos de datos, especialmente BigInt y Number, puede ser complejo y requiere un entendimiento detallado para evitar errores y p√©rdida de precisi√≥n. A continuaci√≥n, se profundiza en c√≥mo manejar estos casos y las precauciones que se deben tomar.

**Conversiones y Operaciones entre BigInt y Number**

- **Operaciones Directas:** JavaScript no permite operaciones directas entre BigInt y Number sin una conversi√≥n expl√≠cita. Intentar realizar una operaci√≥n entre estos dos tipos sin convertir uno de ellos resultar√° en un error.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Intento de suma directa entre BigInt y Number
// const result = 5n + 5;  // Error: Cannot mix BigInt and other types
```

- **Conversiones Apropiadas:** Para realizar operaciones entre BigInt y Number, uno de los tipos debe ser convertido expl√≠citamente al otro. Sin embargo, cada conversi√≥n tiene implicaciones que deben ser consideradas cuidadosamente para evitar p√©rdida de datos o precisi√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Conversi√≥n de Number a BigInt y suma
const numberBigInt = BigInt(5) + 5n; // 10n, conversi√≥n segura si el Number es exacto

// Conversi√≥n de BigInt a Number y suma
const bigIntNumber = 5 + Number(5n); // 10, seguro mientras BigInt est√© dentro del rango seguro de Number
```

**Implicaciones de las Conversiones**

- **P√©rdida de Precisi√≥n:** Convertir BigInt a Number puede llevar a p√©rdida de precisi√≥n si el BigInt es mayor que el valor m√°ximo seguro que Number puede representar (Number.MAX_SAFE_INTEGER).

- **Errores en Tiempo de Ejecuci√≥n:** Convertir Number a BigInt puede ser problem√°tico si el Number ha perdido precisi√≥n debido a su tama√±o o c√°lculos previos.

**Comparaci√≥n de BigInt y Number**

- **Comparaci√≥n Estricta (===):** Devuelve false siempre que se comparen BigInt y Number, incluso si los valores num√©ricos son iguales, debido a la diferencia en tipos de datos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(5n === 5); // false, tipos diferentes
```

- **Comparaci√≥n de Igualdad (==):** Permite una conversi√≥n de tipos impl√≠cita y podr√≠a devolver true si los valores num√©ricos son iguales.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(5n == 5); // true, valor num√©rico igual
```

**Conversiones a String**

- **Conversi√≥n de BigInt a String:** Utilizar String() o .toString() sobre un BigInt elimina la n al final y proporciona una representaci√≥n en forma de cadena del n√∫mero.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
console.log(String(2n ** 53n)); // "9007199254740992"
console.log((2n ** 53n).toString()); // "9007199254740992"
```

### M√©todos de BigInt

BigInt en JavaScript ofrece capacidades √∫nicas para manejar n√∫meros extremadamente grandes, incluso m√°s all√° de los l√≠mites de los n√∫meros enteros normales. Entre sus herramientas, destacan los m√©todos .asIntN() y .asUintN(), que permiten manipular BigInts a nivel de bits con precisi√≥n controlada. Estos m√©todos son fundamentales cuando necesitamos implementar operaciones de bit a bit con un n√∫mero espec√≠fico de bits, asegurando as√≠ que el comportamiento en envolturas o truncamientos sea predecible y correcto.

**M√©todo .asIntN()**

El m√©todo .asIntN(bits, bigNumber) ajusta el n√∫mero bigNumber a una cantidad espec√≠fica de bits, interpretando el resultado como un entero con signo. Este m√©todo es crucial cuando trabajamos con sistemas que requieren una cantidad fija de bits y pueden tener valores negativos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Representaci√≥n de enteros con signo usando 2 bits
console.log(BigInt.asIntN(2, -3n)); // Resultado: representa incorrectamente -3 como 1n debido a la truncaci√≥n
console.log(BigInt.asIntN(2, -2n)); // Resultado: -2n (10 en binario)
console.log(BigInt.asIntN(2, 1n)); // Resultado: 1n (01 en binario)
console.log(BigInt.asIntN(2, 3n)); // Resultado: -1n (representa 3 incorrectamente como -1 debido a la envoltura)
```

**M√©todo .asUintN()**

Por otro lado, .asUintN(bits, bigNumber) tambi√©n ajusta bigNumber a bits especificados, pero lo interpreta como un entero sin signo. Este m√©todo es ideal para casos en los que todos los valores deben ser no negativos y es crucial evitar la interpretaci√≥n de signos.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
// Representaci√≥n de enteros sin signo usando 2 bits
console.log(BigInt.asUintN(2, -1n)); // Resultado: 3n (interpreta -1 como 3, lo cual es incorrecto sin contexto adecuado)
console.log(BigInt.asUintN(2, 2n)); // Resultado: 2n (10 en binario)
console.log(BigInt.asUintN(2, 4n)); // Resultado: 0n (representa 4 como 0 debido a la envoltura)
```

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øQu√© m√©todo usar√≠as para convertir un BigInt a un tipo Number, asumiendo
  que el valor est√° dentro del rango seguro?
</h4>

<p className="my-2">a) A) Number.toBigInt()</p>
<p>b) BigInt.toNumber()</p>
<p className="my-2">c) Number()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Number()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© sucede si intentas sumar 10n y 5 directamente en JavaScript?
</h4>

<p className="my-2">a) Devuelve 15n</p>
<p>b) Lanza un TypeError</p>
<p className="my-2">b) Devuelve 15</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) Lanza un TypeError</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øCu√°l es el resultado de comparar 10n === 10?
</h4>

<p className="my-2">a) true</p>
<p>b) false</p>
<p className="my-2">c) TypeError</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) false</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© representa BigInt en JavaScript y por qu√© es necesario?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      BigInt es un tipo de dato en JavaScript dise√±ado para manejar enteros muy grandes que superan el valor m√°ximo seguro de Number. Es necesario para realizar operaciones precisas con n√∫meros grandes, especialmente en contextos como la criptograf√≠a o el procesamiento de grandes vol√∫menes de datos.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øC√≥mo se crea un BigInt a partir de un n√∫mero literal?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Para crear un BigInt a partir de un n√∫mero literal, se a√±ade n al final del n√∫mero. Por ejemplo, 123n.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øEs posible realizar operaciones mixtas entre BigInt y Number directamente?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      No, JavaScript no permite operaciones directas entre BigInt y Number debido a diferencias en su precisi√≥n y representaci√≥n. Las operaciones deben realizarse convirtiendo expl√≠citamente uno de los tipos al otro.

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Escribe un script que use BigInt para calcular ${2^{100}}$ sin perder precisi√≥n.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const result = 2n ** 100n;
        console.log(result);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Convierte el BigInt 123456789012345678901234567890n a un Number y verifica
  si la conversi√≥n es segura.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const bigIntValue = 123456789012345678901234567890n;
        if (bigIntValue <= BigInt(Number.MAX_SAFE_INTEGER)) {
            const numberValue = Number(bigIntValue);
            console.log(numberValue);
        } else {
            console.log("Conversi√≥n no segura");
        }
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  3. Realiza una operaci√≥n de suma entre dos BigInt y muestra el resultado.
</h4>

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        const bigIntOne = 1000000000000000000000000n;
        const bigIntTwo = 2000000000000000000000000n;
        const sum = bigIntOne + bigIntTwo;
        console.log(sum);
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## String

En programaci√≥n, un string es una secuencia de caracteres utilizada para representar texto. Los strings en JavaScript son un tipo de dato primitivo y se utilizan ampliamente para almacenar y manipular datos textuales. Un string puede contener letras, n√∫meros, s√≠mbolos y espacios, y se define utilizando comillas simples ('), comillas dobles ("), o backticks (`).

```js copy filename="JavaScript"
let stringSimple = "Hola, mundo";
let stringDoble = "Hola, mundo";
let stringBackticks = `Hola, mundo`;
```

**Creaci√≥n y Asignaci√≥n de Strings**

Los strings se pueden asignar a variables de varias maneras, ya sea utilizando la notaci√≥n literal (comillas simples o dobles) o la notaci√≥n mediante el constructor String. Sin embargo, la notaci√≥n literal es la preferida debido a su simplicidad y eficiencia.

```js copy filename="JavaScript"
// Notaci√≥n literal (preferida)
let saludo = "Hola a todos";
let mensaje = "Bienvenido a JavaScript";

// Notaci√≥n mediante el constructor (menos com√∫n)
let saludoConstructor = new String("Hola a todos");
let mensajeConstructor = new String("Bienvenido a JavaScript");
```

**Caracter√≠sticas de los Strings**

- **Inmutabilidad:** Los strings en JavaScript son inmutables, lo que significa que una vez creados, no pueden ser modificados. Cualquier operaci√≥n que parezca modificar un string en realidad crea un nuevo string.

```js copy filename="JavaScript"
let original = "Hola";
let modificado = original + ", mundo";
console.log(original); // 'Hola'
console.log(modificado); // 'Hola, mundo'
```

- **Tipo de dato primitivo:** Los strings son uno de los tipos de datos primitivos en JavaScript, junto con n√∫meros, booleanos, null, undefined, y s√≠mbolos.

- **Uso de Unicode:** JavaScript utiliza Unicode para representar caracteres, lo que permite incluir caracteres de casi todos los idiomas y muchos s√≠mbolos especiales.

**Escapando Caracteres en Strings**

Para incluir caracteres especiales dentro de un string, como comillas, saltos de l√≠nea o tabulaciones, se utilizan secuencias de escape con una barra invertida (\):

```js copy filename="JavaScript"
let comillasSimples = "It's a beautiful day";
let comillasDobles = 'He said, "Hello"';
let saltoLinea = "Primera l√≠nea\nSegunda l√≠nea";
let tabulacion = "Columna1\tColumna2";
console.log(comillasSimples); // "It's a beautiful day"
console.log(comillasDobles); // "He said, "Hello""
console.log(saltoLinea);
// Primera l√≠nea
// Segunda l√≠nea
console.log(tabulacion); // "Columna1  Columna2"
```

**Concatenaci√≥n de Strings**

Puedes unir (concatenar) dos o m√°s strings utilizando el operador + o el operador +=. Esto es √∫til para crear nuevos strings a partir de otros existentes:

```js copy filename="JavaScript"
let parte1 = "Hola";
let parte2 = "mundo";
let completo = parte1 + " " + parte2;
console.log(completo); // "Hola mundo"

parte1 += ", c√≥mo est√°s?";
console.log(parte1); // "Hola, c√≥mo est√°s?"
```

**Uso de Literales de Plantilla**

Las plantillas literales (template literals) son una caracter√≠stica de ES6 que permite crear strings complejos de manera m√°s legible y manejable. Usan backticks (`) en lugar de comillas y permiten la interpolaci√≥n de variables y expresiones mediante la sintaxis ${}:

```js copy filename="JavaScript"
let nombre = "Ana";
let edad = 25;
let presentacion = `Me llamo ${nombre} y tengo ${edad} a√±os.`;
console.log(presentacion); // "Me llamo Ana y tengo 25 a√±os."
```

**Interpolaci√≥n de Variables**

La interpolaci√≥n de variables en JavaScript es una t√©cnica introducida en ECMAScript 6 (ES6) que permite insertar variables y expresiones directamente dentro de un string, haciendo que el c√≥digo sea m√°s legible y f√°cil de escribir. Esta t√©cnica utiliza los template literals, que son delimitados por backticks (`) en lugar de comillas simples (') o dobles (").

1. **Template Literals**

Como vimos anteriormente a los template literals, estos tambi√©n permiten crear strings que incluyen variables y expresiones embebidas utilizando la sintaxis \$\{expresion}. Esta forma de crear strings ofrece varias ventajas:

- **Interpolaci√≥n de variables y expresiones:** Puedes insertar variables y resultados de expresiones directamente en el string.
- **Strings multil√≠nea:** Facilita la creaci√≥n de strings que abarcan m√∫ltiples l√≠neas sin necesidad de caracteres de escape.
- **Inclusi√≥n de comillas:** Permite usar comillas simples y dobles dentro del string sin necesidad de escaparlas.

2. **Interpolaci√≥n B√°sica de Variables**

Para insertar una variable en un template literal, se utiliza la sintaxis \$\{variable} dentro de los backticks. JavaScript evaluar√° la variable y la insertar√° en el string resultante.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let nombre = "Jhoswe";
let saludo = `Hola, ${nombre}!`;
console.log(saludo); // "Hola, Jhoswe!"
```

En este ejemplo, la variable nombre se inserta directamente en el string saludo.

3. **Interpolaci√≥n de Expresiones**

Adem√°s de variables, tambi√©n se pueden insertar expresiones dentro de los template literals. Las expresiones se evaluar√°n y el resultado se incluir√° en el string.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let a = 5;
let b = 10;
let suma = `${a} + ${b} = ${a + b}`;
console.log(suma); // "5 + 10 = 15"
```

En este ejemplo, las expresiones \$\{a}, \$\{b}, y \$\{a + b} se eval√∫an y sus resultados se incluyen en el string suma.

4. **Strings Multil√≠nea**

Los template literals facilitan la creaci√≥n de strings que abarcan m√∫ltiples l√≠neas sin necesidad de caracteres de escape como \n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let mensaje = `Querido Jhoswe,

Espero que est√©s bien. Este es un mensaje
multil√≠nea que se ve muy legible y claro.

Saludos,
Pepue`;
console.log(mensaje);
```

Este string multil√≠nea se define simplemente utilizando backticks y saltos de l√≠nea.

5. **Incluir Comillas dentro de Template Literals**

Los template literals permiten incluir comillas simples y dobles sin necesidad de escaparlas, lo cual facilita la construcci√≥n de strings con diferentes tipos de comillas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let frase = `Ella dijo, "JavaScript es genial" y yo estuve de acuerdo.`;
console.log(frase); // "Ella dijo, "JavaScript es genial" y yo estuve de acuerdo."
```

En este caso, las comillas dobles se incluyen directamente dentro del string delimitado por backticks.

6. **Usos Avanzados de Template Literals**

6.1. **Interpolaci√≥n en HTML:** Los template literals son ideales para crear plantillas de HTML din√°mico. Permiten insertar variables y expresiones directamente en el c√≥digo HTML, lo que facilita la creaci√≥n de contenido din√°mico.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let titulo = "Bienvenido";
let contenido = `<div>
    <h1>${titulo}</h1>
    <p>Este es un ejemplo de interpolaci√≥n de variables en HTML.</p>
</div>`;
document.body.innerHTML = contenido;
```

6.2. **Funciones y Template Literals:** Los template literals pueden ser utilizados dentro de funciones para crear contenido din√°mico basado en los argumentos de la funci√≥n.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
function crearBoton(clase, texto) {
  return `<button class="${clase}">${texto}</button>`;
}

let botonPrimario = crearBoton("btn-primario", "Aceptar");
let botonAdvertencia = crearBoton("btn-advertencia", "Eliminar");
console.log(botonPrimario); // "<button class="btn-primario">Aceptar</button>"
console.log(botonAdvertencia); // "<button class="btn-advertencia">Eliminar</button>"
```

### Propiedades de un String

En JavaScript, los strings tienen varias propiedades importantes que permiten obtener informaci√≥n sobre el string y manipularlo de diversas maneras. A continuaci√≥n, exploramos estas propiedades en detalle.

1. **Propiedad length**

La propiedad length es la m√°s utilizada y la √∫nica propiedad fundamentalmente importante de un string. Devuelve el n√∫mero de caracteres en el string, incluyendo espacios, signos de puntuaci√≥n y caracteres especiales.

**Caracter√≠sticas de la propiedad length**

- Es de solo lectura: no puedes modificar la longitud de un string directamente a trav√©s de esta propiedad.
- Devuelve un valor num√©rico que representa el total de caracteres en el string.
- Se puede acceder a ella directamente desde cualquier string sin necesidad de guardarlo en una variable.

```js copy filename="JavaScript"
let ejemplo = "JavaScript";
console.log(ejemplo.length); // 10
```

2. **Propiedad constructor**

La propiedad constructor devuelve una referencia a la funci√≥n que cre√≥ la instancia del objeto String. En JavaScript, todas las instancias de string son creadas por la funci√≥n String.

**Caracter√≠sticas de la propiedad constructor**

- Es √∫til para verificar el tipo de un objeto.
- Permite crear nuevas instancias de objetos String.
- Se hereda de Object.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo.constructor); // function String() { [native code] }
```

3. **Propiedad prototype**

La propiedad prototype permite agregar nuevas propiedades y m√©todos a todos los objetos String. Esto es √∫til cuando se desea extender la funcionalidad de los strings en todas las instancias.

**Caracter√≠sticas de la propiedad prototype**

- Permite extender la funcionalidad de los strings.
- Los m√©todos y propiedades a√±adidos a String.prototype estar√°n disponibles para todas las instancias de string.
- Es una caracter√≠stica poderosa para personalizar y ampliar las capacidades de los strings.

```js copy filename="JavaScript"
String.prototype.despedir = function () {
  return "Adi√≥s, " + this;
};
```

4. **Propiedad \_\_proto\_\_**

La propiedad **proto** es una referencia al prototipo del objeto, del cual hereda propiedades y m√©todos. Aunque es accesible, no es recomendable modificar **proto** directamente. En su lugar, se deben utilizar m√©todos como Object.getPrototypeOf() y Object.setPrototypeOf().

**Caracter√≠sticas de la propiedad \_\_proto\_\_**

- Permite acceder al prototipo del objeto.
- Se utiliza principalmente para inspecci√≥n y depuraci√≥n.
- Modificar **proto** directamente no es una pr√°ctica recomendada debido a posibles problemas de rendimiento y mantenimiento del c√≥digo.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo.__proto__ === String.prototype); // true
```

**Acceso a un Car√°cter**

En JavaScript, los strings son secuencias de caracteres, y a menudo es necesario acceder a un car√°cter espec√≠fico dentro de un string. Existen varias formas de lograr esto, cada una con sus propias caracter√≠sticas y usos. A continuaci√≥n, se detallan los m√©todos m√°s comunes para acceder a un car√°cter en un string.

**Acceso mediante √çndices**

Los strings en JavaScript se comportan como arrays de caracteres, lo que permite acceder a un car√°cter espec√≠fico utilizando la notaci√≥n de corchetes ([]) con un √≠ndice. Los √≠ndices en JavaScript comienzan en 0, por lo que el primer car√°cter de un string tiene el √≠ndice 0, el segundo el √≠ndice 1, y as√≠ sucesivamente.

**Caracter√≠sticas de este m√©todo**

- **Acceso Directo:** Permite acceder directamente a cualquier car√°cter dentro del string utilizando su posici√≥n.
- **Inmutabilidad:** Aunque puedes acceder a caracteres individuales, no puedes modificar un car√°cter directamente utilizando esta notaci√≥n debido a que los strings en JavaScript son inmutables.
- **√çndice fuera de rango:** Si intentas acceder a un √≠ndice que no existe, no se lanzar√° un error, pero obtendr√°s undefined.

```js copy filename="JavaScript"
let saludo = "Hola, mundo";
console.log(saludo[0]); // "H"
console.log(saludo[7]); // "u"
console.log(saludo[10]); // "o"
console.log(saludo[20]); // undefined
```

### Posiciones y substrings

Antes de profundizar en los m√©todos, es importante entender dos conceptos clave:

1. **Substring:** Un substring es una subcadena de texto, es decir, una secuencia de caracteres que forma parte de un string m√°s grande. Por ejemplo, en el string "Hola amigos", la subcadena "amigos" es un substring.

2. **Posici√≥n o √çndice:** La posici√≥n o √≠ndice es un n√∫mero que representa el lugar donde se encuentra un car√°cter en el string, comenzando desde 0. Por ejemplo, en el string "Hola amigos", el car√°cter 'a' en "amigos" est√° en la posici√≥n 5.

```js copy filename="JavaScript"
"Hola amigos";
0123456789;
```

**Obtener la Posici√≥n o √çndice de un Car√°cter**

Para encontrar la posici√≥n o √≠ndice de un car√°cter dentro de un string, JavaScript ofrece varios m√©todos.

1. **Car√°cter en cierta posici√≥n**

**M√©todo .charAt(pos)**

El m√©todo .charAt(pos) devuelve el car√°cter en la posici√≥n especificada dentro de un string. Es √∫til para acceder a caracteres individuales, especialmente en versiones antiguas de JavaScript donde la notaci√≥n de corchetes ([]) no es compatible.

- **Sintaxis**

```js copy filename="JavaScript"
string.charAt(pos);
```

**pos:** La posici√≥n (√≠ndice) del car√°cter que se desea obtener. El √≠ndice comienza en 0.

- **Caracter√≠sticas del M√©todo .charAt(pos)**

  - **Compatibilidad:** Es compatible con versiones m√°s antiguas de JavaScript.
  - **Valor de retorno:** Devuelve una cadena de longitud 1 (un solo car√°cter) que se encuentra en la posici√≥n especificada.
  - **√çndice fuera de rango:** Si el √≠ndice est√° fuera del rango del string, devuelve una cadena vac√≠a ("").

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript";
console.log(texto.charAt(0)); // "J"
console.log(texto.charAt(4)); // "S"
console.log(texto.charAt(9)); // "t"
console.log(texto.charAt(10)); // ""
```

En este ejemplo, charAt se usa para obtener los caracteres en las posiciones 0, 4 y 9 del string "JavaScript". Tambi√©n muestra c√≥mo se comporta cuando el √≠ndice est√° fuera del rango del string, devolviendo una cadena vac√≠a.

2. **Posici√≥n de cierto car√°cter**

En JavaScript, localizar la posici√≥n de un car√°cter o subcadena espec√≠fica dentro de un string es una tarea com√∫n. Los m√©todos .indexOf(text) y .indexOf(text, from) son herramientas esenciales para realizar estas b√∫squedas. A continuaci√≥n, explicaremos en detalle c√≥mo funcionan estos m√©todos y c√≥mo utilizarlos de manera efectiva.

**M√©todo .indexOf(text)**

El m√©todo .indexOf(text) busca la primera aparici√≥n de una subcadena dentro de un string y devuelve el √≠ndice correspondiente. Si no se encuentra la subcadena, devuelve -1. Este m√©todo es √∫til cuando necesitas saber si una subcadena espec√≠fica est√° presente en un string y, de ser as√≠, en qu√© posici√≥n se encuentra.

- **Sintaxis**

```js copy filename="JavaScript"
string.indexOf(searchValue);
```

**searchValue:** La subcadena que se desea buscar dentro del string.

- **Caracter√≠sticas de .indexOf(text)**

  - **Devuelve el √≠ndice:** El √≠ndice de la primera aparici√≥n del searchValue en el string.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial";
let posicion = texto.indexOf("Script"); // 4
console.log(posicion); // 4

let noEncontrado = texto.indexOf("script"); // -1 (debido a la sensibilidad a may√∫sculas y min√∫sculas)
console.log(noEncontrado); // -1
```

En este ejemplo, indexOf busca la subcadena "Script" dentro del string "JavaScript es genial", devolviendo el √≠ndice 4. Si se busca "script" (en min√∫sculas), se devuelve -1 porque la b√∫squeda es sensible a may√∫sculas y min√∫sculas.

**M√©todo .indexOf(text, from)**

El m√©todo .indexOf(text, from) es una extensi√≥n de .indexOf(text) que permite especificar un √≠ndice desde el cual comenzar la b√∫squeda. Esto es √∫til cuando necesitas buscar la subcadena a partir de una posici√≥n espec√≠fica dentro del string, proporcionando mayor control y flexibilidad.

- **Sintaxis**

```js copy filename="JavaScript"
string.indexOf(searchValue, fromIndex);
```

**searchValue:** La subcadena que se desea buscar dentro del string.
**fromIndex:** La posici√≥n desde la cual se desea comenzar la b√∫squeda. El valor por defecto es 0.

- **Caracter√≠sticas de .indexOf(text, from)**

- **Devuelve el √≠ndice:** El √≠ndice de la primera aparici√≥n del searchValue en el string, comenzando desde fromIndex.
- **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
- **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.
- **Permite especificar el punto de inicio:** La b√∫squeda comienza desde el √≠ndice fromIndex, proporcionando mayor flexibilidad.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let primeraPosicion = texto.indexOf("JavaScript"); // 0
console.log(primeraPosicion); // 0

let segundaPosicion = texto.indexOf("JavaScript", 15); // 22
console.log(segundaPosicion); // 22
```

En este ejemplo, indexOf busca la subcadena "JavaScript" dentro del string "JavaScript es genial. JavaScript es vers√°til.". La primera b√∫squeda comienza desde el inicio del string, devolviendo el √≠ndice 0. La segunda b√∫squeda comienza desde el √≠ndice 15, devolviendo el √≠ndice 23.

3. **Posici√≥n desde el Final**

En JavaScript, los m√©todos .lastIndexOf(text) y .lastIndexOf(text, from) se utilizan para buscar la √∫ltima aparici√≥n de un car√°cter o subcadena dentro de un string, comenzando la b√∫squeda desde el final del string. Estos m√©todos son √∫tiles para encontrar la posici√≥n de la √∫ltima ocurrencia de un car√°cter o subcadena espec√≠fica, lo que puede ser esencial en muchas operaciones de manipulaci√≥n de texto.

**M√©todo .lastIndexOf(text)**

El m√©todo .lastIndexOf(text) busca la √∫ltima aparici√≥n de una subcadena dentro de un string y devuelve el √≠ndice correspondiente. Si no se encuentra la subcadena, devuelve -1. Este m√©todo es particularmente √∫til cuando necesitas encontrar la posici√≥n de la √∫ltima ocurrencia de una subcadena espec√≠fica en un string.

- **Sintaxis**

```js copy filename="JavaScript"
string.lastIndexOf(searchValue);
```

**searchValue:** La subcadena que se desea buscar dentro del string.

- **Caracter√≠sticas de .lastIndexOf(text)**

  - **Devuelve el √≠ndice:** El √≠ndice de la √∫ltima aparici√≥n del searchValue en el string.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let ultimaPosicion = texto.lastIndexOf("JavaScript");
console.log(ultimaPosicion); // 22

let noEncontrado = texto.lastIndexOf("script");
console.log(noEncontrado); // -1
```

En este ejemplo, lastIndexOf busca la subcadena "JavaScript" dentro del string "JavaScript es genial. JavaScript es vers√°til.", devolviendo el √≠ndice 23. Si se busca "script" (en min√∫sculas), se devuelve -1 porque la b√∫squeda es sensible a may√∫sculas y min√∫sculas.

**M√©todo .lastIndexOf(text, from)**

El m√©todo .lastIndexOf(text, from) permite especificar un √≠ndice desde el cual comenzar la b√∫squeda hacia atr√°s. Esto proporciona mayor control y flexibilidad, permitiendo encontrar la √∫ltima aparici√≥n de una subcadena comenzando desde una posici√≥n espec√≠fica dentro del string.

- **Sintaxis**

```js copy filename="JavaScript"
string.lastIndexOf(searchValue, fromIndex);
```

**searchValue:** La subcadena que se desea buscar dentro del string.
**fromIndex:** La posici√≥n desde la cual se desea comenzar la b√∫squeda hacia atr√°s. El valor por defecto es la longitud del string menos uno.

- **Caracter√≠sticas de .lastIndexOf(text, from)**

  - **Devuelve el √≠ndice:** El √≠ndice de la √∫ltima aparici√≥n del searchValue en el string, comenzando desde fromIndex.
  - **Retorno de -1:** Si el searchValue no se encuentra, se devuelve -1.
  - **Sensible a may√∫sculas y min√∫sculas:** La b√∫squeda distingue entre may√∫sculas y min√∫sculas.
  - **Permite especificar el punto de inicio:** La b√∫squeda comienza desde el √≠ndice fromIndex hacia atr√°s, proporcionando mayor flexibilidad.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "JavaScript es genial. JavaScript es vers√°til.";
let ultimaPosicionDesde = texto.lastIndexOf("es", 11);
console.log(ultimaPosicionDesde); // 11

let ultimaPosicionCompleta = texto.lastIndexOf("es", texto.length - 1);
console.log(ultimaPosicionCompleta); // 33
```

An√°lisis del Ejemplo 1:

String: "JavaScript es genial. JavaScript es vers√°til."
Subcadena Buscada (text): "es"
Punto de Inicio (from): 11
En este ejemplo, el m√©todo .lastIndexOf("es", 11) busca la subcadena "es" empezando desde el √≠ndice 11 y movi√©ndose hacia atr√°s (hacia el inicio del string).

La b√∫squeda comienza desde el √≠ndice 11 y encuentra "es" justo en esa posici√≥n, que es parte de la palabra "es" en la frase "JavaScript es genial."
Por lo tanto, el m√©todo devuelve 11, que es el √≠ndice donde comienza la subcadena "es" encontrada al realizar la b√∫squeda hacia atr√°s desde el √≠ndice 11.

An√°lisis del Ejemplo 2:

String: "JavaScript es genial. JavaScript es vers√°til."
Subcadena Buscada (text): "es"
Punto de Inicio (from): texto.length - 1 (que es 43 - 1 = 42)
En este caso, el m√©todo .lastIndexOf("es", 42) inicia la b√∫squeda de la subcadena "es" desde el √≠ndice 42, que es el √∫ltimo √≠ndice del string.

La b√∫squeda se realiza hacia atr√°s desde el final del string.
Encuentra la subcadena "es" en la parte "es" de la palabra "vers√°til" hacia el final del string.
El √≠ndice donde comienza esta subcadena es 33, que es el resultado devuelto por el m√©todo.

**Obtener Fragmentos (Substrings)**

Javascript tambi√©n posee una serie de m√©todos mediante los cuales podemos crear substrings formados por un fragmento del original.

1. **Repetir cadena de texto**

**M√©todo .repeat(num)**

El m√©todo .repeat(num) devuelve un nuevo string que contiene la concatenaci√≥n del string original repetido num veces. Este m√©todo es √∫til para generar patrones repetitivos, crear rellenos o simplemente repetir contenido.

- **Sintaxis**

```js copy filename="JavaScript"
string.repeat(count);
```

**count:** Un n√∫mero entero que indica cu√°ntas veces se repetir√° el string. Debe ser un valor mayor o igual a 0.

- **Caracter√≠sticas de .repeat(num)**

  - **Devuelve un nuevo string:** El string original se repite count veces, y el resultado es un nuevo string.
  - **Par√°metro count:** Debe ser un n√∫mero entero. Si es un n√∫mero decimal, se redondear√° hacia abajo.
  - **Valor count negativo o infinito:** Lanza un RangeError.
  - **Valor count igual a 0:** Devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let saludo = "Hola";
let repetido = saludo.repeat(3);
console.log(repetido); // "HolaHolaHola"

let relleno = "*".repeat(5);
console.log(relleno); // "*****"

let vacio = "JavaScript".repeat(0);
console.log(vacio); // ""
```

En este ejemplo, el m√©todo repeat se utiliza para repetir el string "Hola" tres veces, creando el string "HolaHolaHola". Tambi√©n se usa para generar un relleno de asteriscos y para demostrar que repetir un string 0 veces resulta en una cadena vac√≠a.

2. **Fragmento de texto (substring)**

**M√©todo .substring(start, end)**

El m√©todo .substring(start, end) se utiliza para extraer partes de un string. Devuelve una nueva cadena que contiene los caracteres desde el √≠ndice start hasta, pero sin incluir, el √≠ndice end. Si end se omite, extrae hasta el final del string.

- **Sintaxis**

```js copy filename="JavaScript"
string.substring(start, end);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena.
**end (opcional):** El √≠ndice del primer car√°cter que no se incluir√° en la subcadena. Si se omite, substring extraer√° caracteres desde start hasta el final del string.

- **Caracter√≠sticas**

  - **Indices positivos:** Ambos √≠ndices deben ser n√∫meros no negativos.
  - **Intercambio de √≠ndices:** Si start es mayor que end, los valores se intercambian.
  - **Ajuste de l√≠mites:** Los valores fuera del rango del string se ajustan al inicio o al final del string.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.substring(3); // "marino"
let subcadena2 = texto.substring(3, 5); // "ma"
let subcadena3 = texto.substring(5, 3); // "ma" (intercambio de √≠ndices)
console.log(subcadena1); // "marino"
console.log(subcadena2); // "ma"
console.log(subcadena3); // "ma"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.substring(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer entre dos √≠ndices:** En el ejemplo texto.substring(3, 5), se extraen los caracteres desde el √≠ndice 3 hasta el 5, sin incluir el car√°cter en el √≠ndice 5.

**Intercambio de √≠ndices:** En el ejemplo texto.substring(5, 3), como el primer √≠ndice es mayor que el segundo, el m√©todo intercambia los valores y extrae los caracteres desde el √≠ndice 3 hasta el 5.

**M√©todo .substr(start, size)**

El m√©todo .substr(start, size) devuelve una nueva cadena de texto que contiene los caracteres de la cadena original comenzando desde el √≠ndice start y extendi√©ndose por size caracteres.

- **Sintaxis**

```js copy filename="JavaScript"
string.substr(start, size);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena. Puede ser negativo para contar desde el final del string.
**size (opcional):** El n√∫mero de caracteres que se incluir√°n en la subcadena. Si se omite, substr extraer√° caracteres desde start hasta el final del string.

- **Caracter√≠sticas**

  - **Inicio negativo:** Si start es negativo, la posici√≥n se cuenta desde el final del string.
  - **Longitud positiva:** size debe ser un n√∫mero positivo. Si es 0 o negativo, se devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.substr(3); // "marino"
let subcadena2 = texto.substr(3, 5); // "marin"
let subcadena3 = texto.substr(-3); // "ino"
let subcadena4 = texto.substr(-3, 2); // "in"
console.log(subcadena1); // "marino"
console.log(subcadena2); // "marin"
console.log(subcadena3); // "ino"
console.log(subcadena4); // "in"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.substr(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer una cantidad espec√≠fica de caracteres:** En el ejemplo texto.substr(3, 5), se extraen 5 caracteres comenzando desde el √≠ndice 3.

**Inicio negativo:** En el ejemplo texto.substr(-3), se extraen los caracteres desde el tercer √≠ndice desde el final del string hasta el final.

**Inicio negativo con tama√±o espec√≠fico:** En el ejemplo texto.substr(-3, 2), se extraen 2 caracteres comenzando desde el tercer √≠ndice desde el final del string.

**M√©todo .slice(start, end)**

El m√©todo .slice(start, end) devuelve una nueva cadena de texto que contiene los caracteres de la cadena original desde el √≠ndice start hasta, pero sin incluir, el √≠ndice end. Funciona de manera similar a substring, pero admite √≠ndices negativos.

- **Sintaxis**

```js copy filename="JavaScript"
string.slice(start, end);
```

**start:** El √≠ndice del primer car√°cter que se incluir√° en la subcadena. Puede ser negativo para contar desde el final del string.
**end (opcional):** El √≠ndice del primer car√°cter que no se incluir√° en la subcadena. Si se omite, slice extraer√° caracteres desde start hasta el final del string. Puede ser negativo para contar desde el final del string.

- **Caracter√≠sticas**

  - **Inicio y fin negativos:** Ambos √≠ndices pueden ser negativos, contando desde el final del string.
  - **No intercambia √≠ndices:** Si start es mayor que end, no intercambia los valores, sino que devuelve una cadena vac√≠a.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let texto = "Submarino";
let subcadena1 = texto.slice(3); // "marino"
let subcadena2 = texto.slice(3, 5); // "ma"
let subcadena3 = texto.slice(-3); // "ino"
let subcadena4 = texto.slice(-6, -3); // "Submar"
console.log(subcadena1); // "marino"
console.log(subcadena2); // "ma"
console.log(subcadena3); // "ino"
console.log(subcadena4); // "mar"
```

**Extraer desde un √≠ndice espec√≠fico:** En el ejemplo texto.slice(3), se extraen los caracteres desde el √≠ndice 3 hasta el final del string.

**Extraer entre dos √≠ndices:** En el ejemplo texto.slice(3, 5), se extraen los caracteres desde el √≠ndice 3 hasta el 5, sin incluir el car√°cter en el √≠ndice 5.

**Inicio negativo:** En el ejemplo texto.slice(-3), se extraen los caracteres desde el tercer √≠ndice desde el final del string hasta el final.

**Inicio y fin negativos:** En el ejemplo texto.slice(-6, -3), se extraen los caracteres desde el noveno √≠ndice desde el final del string hasta el tercer √≠ndice desde el final.

**Dividir un texto en partes (array)**

El m√©todo .split() en JavaScript ofrece una flexibilidad considerable para dividir strings en arrays utilizando separadores espec√≠ficos. Este m√©todo se puede aplicar de varias maneras, dependiendo de si el separador es una cadena fija, una expresi√≥n regular, o si se establece un l√≠mite en la cantidad de splits. Profundicemos en los detalles t√©cnicos y las variantes de este m√©todo para entender mejor su aplicaci√≥n y comportamiento en diferentes contextos.

- **Divisi√≥n con Texto Fijo**

Cuando se utiliza una cadena fija como separador, .split() divide el string en cada punto donde encuentra esta cadena.

**M√©todo .split(text)**

Cuando utilizas .split(text) sin un segundo par√°metro, divides el string original en tantos elementos como ocurrencias del separador haya en el string. Este m√©todo es √∫til para descomponer un string en un array basado en un delimitador fijo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const poem = "The quick brown fox jumps over the lazy dog";
const words = poem.split(" ");
console.log(words);
```

const poem = "The quick brown fox jumps over the lazy dog";
const words = poem.split(" ");
console.log(words);

**.split(text, limit)**

El par√°metro limit controla el n√∫mero m√°ximo de elementos que ser√°n incluidos en el array resultante. Si el n√∫mero de divisiones producidas por el separator es mayor que limit, las subdivisiones adicionales son descartadas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const data = "apple,orange,banana,pear,grape";
const limitedItems = data.split(",", 3);
console.log(limitedItems);
```

Aqu√≠, limitedItems ser√° ["apple", "orange", "banana"]. Aunque hay m√°s elementos que podr√≠an ser extra√≠dos, el limit de 3 asegura que solo los tres primeros sean incluidos.

**.split(regexp)**

Utilizar expresiones regulares como el separator permite un control m√°s refinado sobre c√≥mo se divide el string. Puedes especificar un patr√≥n que puede no ser un substring fijo.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const complexData = "word1, word2: word3; word4. word5";
const parts = complexData.split(/[\s,;:.]+/);
console.log(parts);
```

En este caso, parts ser√° ["word1", "word2", "word3", "word4", "word5"]. La expresi√≥n regular /[\s,;:.]+/ indica que el string debe dividirse en cualquier punto donde uno o m√°s espacios, comas, puntos y comas, dos puntos o puntos se encuentren.

**.split(regexp, limit)**

Combinar una expresi√≥n regular con un limit te permite dividir un string seg√∫n un patr√≥n complejo, pero tambi√©n controlar cu√°ntos substrings quieres extraer, lo cual es √∫til para evitar procesamiento innecesario.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const message =
  "This is a sentence. This is another sentence. And yet another one.";
const firstTwoSentences = message.split(/[.!?]\s/, 2);
console.log(firstTwoSentences);
```

Aqu√≠, firstTwoSentences ser√° ["This is a sentence", "This is another sentence"]. La divisi√≥n se realiza en puntos, signos de exclamaci√≥n o interrogaci√≥n seguidos de un espacio, pero se limita a las dos primeras sentencias.

- **Detalles Adicionales sobre .split() y Caracteres Especiales**

Es importante destacar que si el separator es una cadena vac√≠a, el resultado es un array de caracteres individuales del string. Esto es particularmente √∫til para tareas como la inversi√≥n de un string o la realizaci√≥n de operaciones en cada car√°cter.

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const message =
  "This is a sentence. This is another sentence. And yet another one.";
const firstTwoSentences = message.split(/[.!?]\s/, 2);
console.log(firstTwoSentences);
```

Este script divide word en caracteres, los invierte y luego los une de nuevo, resultando en "sdrawkcab".

### Buscar y Reemplazar

En JavaScript, las operaciones de b√∫squeda y reemplazo son fundamentales para manipular cadenas de texto. Estas operaciones permiten identificar subcadenas espec√≠ficas dentro de una cadena mayor y, si es necesario, reemplazarlas con una nueva subcadena. Esto es extremadamente √∫til en muchas aplicaciones web, como la validaci√≥n de formularios, la limpieza de datos de entrada, o simplemente la transformaci√≥n de textos seg√∫n las necesidades del usuario.

üîçVerificar(üîç): Este es el m√°s sencillo de los tres m√©todos. S√≥lo comprueba si existe un fragmento de texto. üïµÔ∏è‚Äç‚ôÄÔ∏è Buscar (üîç üïµÔ∏è‚Äç‚ôÄÔ∏è): busca un fragmento de texto y devuelve informaci√≥n sobre el texto encontrado (ubicaci√≥n, texto...). üîÅ Reemplazar (üîç üïµÔ∏è‚Äç‚ôÄÔ∏è üîÅ): busca y reemplaza texto. En general, es m√°s caro.

**M√©todo .startsWith()**

El m√©todo .startsWith() en JavaScript se utiliza para determinar si una cadena de texto comienza con los caracteres especificados, devolviendo true si es as√≠ y false de lo contrario. Es fundamental en situaciones donde es necesario validar los inicios de las cadenas, como c√≥digos de productos, protocolos en URLs, o simplemente condiciones de formato.

- **Sintaxis**

```js copy filename="JavaScript"
string.startsWith(searchString, position);
```

**searchString:** La subcadena que se busca al comienzo del string principal.
**position (opcional):** La posici√≥n en la cadena desde la cual se debe empezar a buscar. El valor por defecto es 0, lo que implica que la b√∫squeda comienza desde el inicio del string.

<h4 className="font-medium mt-5">Ejemplo</h4>

Consideremos algunos ejemplos que ilustran c√≥mo se utiliza .startsWith() en diferentes contextos:

```js copy filename="JavaScript"
const str1 = "Buenos d√≠as, mundo!";
console.log(str1.startsWith("Buenos")); // true

const str2 = "JavaScript es genial";
console.log(str2.startsWith("Script", 4)); // true

const filename = "reporte_final.doc";
console.log(filename.startsWith("reporte")); // true
```

- En el primer ejemplo, se verifica si el string "Buenos d√≠as, mundo!" comienza con la subcadena "Buenos", lo cual es verdadero.
- En el segundo ejemplo, "JavaScript es genial" se verifica si comienza con "Script" empezando desde el √≠ndice 4, mostrando c√≥mo se puede ajustar el punto de inicio de la b√∫squeda.
- El tercer ejemplo verifica si el nombre de archivo comienza con "reporte", algo com√∫n en la validaci√≥n de formatos de archivo o en sistemas de manejo de documentos.

**M√©todo .endsWith(text, to)**

El m√©todo .endsWith() es utilizado para determinar si una cadena de texto termina con los caracteres de otra cadena especificada, devolviendo true si es as√≠, y false en caso contrario. Este m√©todo es particularmente √∫til cuando necesitas asegurarte de que un string cumple con ciertos criterios al final, como extensiones de archivo o ciertas terminaciones en idiomas program√°ticos o humanos.

- **Sintaxis**

```js copy filename="JavaScript"
string.endsWith(searchString, length);
```

**searchString:** La cadena que se buscar√° al final del string.
**length (opcional):** Si se especifica, se trata el string como si tuviera exactamente este n√∫mero de caracteres (esencialmente, ajusta el string a este tama√±o antes de realizar la b√∫squeda).

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const file = "example.txt";
console.log(file.endsWith(".txt")); // true

const greeting = "Hello world!";
console.log(greeting.endsWith("world", 11)); // true
```

En el primer ejemplo, se verifica si el nombre del archivo termina en .txt, √∫til para manipulaci√≥n de archivos. En el segundo ejemplo, se verifica si la cadena "Hello world!" termina con "world" cuando se consideran los primeros 11 caracteres, demostrando c√≥mo el par√°metro de longitud puede alterar el resultado.

**M√©todo .includes(text, from)**

El m√©todo .includes() permite verificar si una cadena contiene otra subcadena dentro de ella, devolviendo true si la encuentra, y false si no. Este m√©todo es insustituible en la b√∫squeda de contenido dentro de un string, y su capacidad para iniciar la b√∫squeda desde un √≠ndice espec√≠fico lo hace muy vers√°til.

- **Sintaxis**

```js copy filename="JavaScript"
string.includes(searchString, position);
```

**searchString:** La subcadena que se buscar√° dentro del string.
**position (opcional):** El √≠ndice desde donde comenzar la b√∫squeda dentro del string. Por defecto es 0.

<h4 className="font-medium mt-5">Ejemplo Avanzado</h4>

```js copy filename="JavaScript"
const phrase = "Finding substrings in strings";
console.log(phrase.includes("sub")); // true

const message = "Case sensitive search";
console.log(message.includes("case")); // false
console.log(message.includes("case", 5)); // true
```

En estos ejemplos, el m√©todo .includes() demuestra su utilidad para encontrar subcadenas. El segundo ejemplo tambi√©n resalta la sensibilidad a may√∫sculas y min√∫sculas del m√©todo, y c√≥mo el inicio de la b√∫squeda puede afectar el resultado.

### B√∫squeda de Cadenas

La b√∫squeda de cadenas de texto es una operaci√≥n fundamental en la programaci√≥n. Permite localizar posiciones espec√≠ficas, verificar la existencia de patrones y mucho m√°s. En JavaScript, uno de los m√©todos m√°s poderosos para realizar estas b√∫squedas es .search(), que utiliza expresiones regulares (regex).

**M√©todo .search(regexp)**

El m√©todo .search() busca una coincidencia entre una expresi√≥n regular y el string sobre el que se aplica. Devuelve el √≠ndice de la primera coincidencia o -1 si no se encuentra ninguna coincidencia. Es una herramienta esencial cuando se necesita comprobar la presencia de patrones complejos dentro de un string.

- **Sintaxis**

```js copy filename="JavaScript"
string.search(regexp);
```

**regexp:** Una expresi√≥n regular que describe el patr√≥n a buscar.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const text = "JavaScript es un lenguaje de programaci√≥n vers√°til.";
const position = text.search(/lenguaje/);
console.log(position); // 17
```

En este ejemplo, la palabra "lenguaje" se encuentra en la posici√≥n 14 del string.

**M√©todo .match(regexp)**

El m√©todo .match() se utiliza para obtener todas las coincidencias de una expresi√≥n regular en una cadena. Devuelve un array que contiene las coincidencias encontradas o null si no se encuentra ninguna coincidencia.

- **Sintaxis**

```js copy filename="JavaScript"
string.match(regexp);
```

**regexp:** Una expresi√≥n regular que describe el patr√≥n a buscar.

- **Caracter√≠sticas**

  - Si la expresi√≥n regular no tiene el flag global (g), .match() devolver√° solo la primera coincidencia y algunos detalles adicionales.
  - Si la expresi√≥n regular tiene el flag global (g), .match() devolver√° todas las coincidencias encontradas.

<h4 className="font-medium mt-5">Ejemplo sin el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const result = text.match(/JavaScript/);
console.log(result); // ["JavaScript", index: 0, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
```

En este caso, .match() devuelve la primera coincidencia junto con su posici√≥n en el string y otros detalles.

<h4 className="font-medium mt-5">Ejemplo con el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const result = text.match(/JavaScript/g);
console.log(result); // ["JavaScript", "JavaScript"]
```

Aqu√≠, al usar el flag global (g), .match() devuelve todas las ocurrencias de "JavaScript" en un array.

**M√©todo .matchAll(regexp)**

El m√©todo .matchAll() es una versi√≥n m√°s reciente y avanzada de .match(). Devuelve un iterador que produce todas las coincidencias completas, incluidas las subcadenas capturadas. Requiere el flag global (g) en la expresi√≥n regular.

- **Sintaxis**

```js copy filename="JavaScript"
string.matchAll(regexp);
```

- **Caracter√≠sticas**

Devuelve un iterador de todas las coincidencias encontradas, lo que es √∫til para manejar grandes conjuntos de datos de manera eficiente.
Incluye detalles completos de cada coincidencia, incluidos los grupos de captura.

<h4 className="font-medium mt-5">Ejemplo con el flag global</h4>

```js copy filename="JavaScript"
const text = "JavaScript es maravilloso. JavaScript es potente.";
const matches = text.matchAll(/JavaScript/g);

for (const match of matches) {
  console.log(match); // ["JavaScript", index: 0, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
  // ["JavaScript", index: 27, input: "JavaScript es maravilloso. JavaScript es potente.", groups: undefined]
}
```

En este ejemplo, el iterador produce todas las coincidencias una por una.

### Reemplazar cadenas de texto

Reemplazar cadenas de texto es una tarea fundamental en la manipulaci√≥n de strings en JavaScript. Los m√©todos .replace() y .replaceAll() son esenciales para estas operaciones, permitiendo tanto reemplazos simples como complejos con expresiones regulares.

**M√©todo .replace(text, newText)**

El m√©todo .replace() se utiliza para reemplazar la primera coincidencia de una subcadena o una expresi√≥n regular dentro de un string. Su uso es bastante vers√°til, permitiendo realizar reemplazos b√°sicos y tambi√©n m√°s avanzados mediante el uso de expresiones regulares.

- **Sintaxis**

```js copy filename="JavaScript"
string.replace(searchValue, newValue);
```

**searchValue:** La subcadena o expresi√≥n regular que se va a buscar en el string.
**newValue:** La subcadena que reemplazar√° la primera coincidencia de searchValue.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludo = "Hola mundo";
const nuevoSaludo = saludo.replace("mundo", "amigo");
console.log(nuevoSaludo); // "Hola amigo"
```

En este ejemplo, la primera aparici√≥n de "mundo" se reemplaza por "amigo". Esto es √∫til para situaciones donde solo necesitas cambiar la primera instancia de una palabra o frase.

<h4 className="font-medium mt-5">Ejemplo usando expresiones regulares</h4>

```js copy filename="JavaScript"
const frase = "El color es rojo. El color es verde.";
const nuevaFrase = frase.replace(/color/, "tono");
console.log(nuevaFrase); // "El tono es rojo. El color es verde."
```

Aqu√≠, se utiliza una expresi√≥n regular para buscar la primera aparici√≥n de "color" y reemplazarla por "tono". Las expresiones regulares ofrecen una manera poderosa de buscar patrones dentro de un string.

<h4 className="font-medium mt-5">Ejemplo de reemplazo con funci√≥n</h4>

```js copy filename="JavaScript"
const texto = "Hola mundo";
const nuevoTexto = texto.replace("mundo", (match) => `amigo (${match})`);
console.log(nuevoTexto); // "Hola amigo (mundo)"
```

En este caso, en lugar de simplemente proporcionar un string para reemplazar, se usa una funci√≥n. La funci√≥n recibe como argumento la coincidencia encontrada y devuelve el nuevo valor. Esto permite generar reemplazos din√°micos basados en el contenido original.

**M√©todo .replaceAll(text, newText)**

El m√©todo .replaceAll() se utiliza para reemplazar todas las coincidencias de una subcadena espec√≠fica o una expresi√≥n regular dentro de un string. Es especialmente √∫til cuando necesitas modificar m√∫ltiples apariciones de un texto en una sola operaci√≥n.

- **Sintaxis**

```js copy filename="JavaScript"
string.replaceAll(searchValue, newValue);
```

**searchValue:** La subcadena o expresi√≥n regular que se va a buscar en el string.
**newValue:** La subcadena que reemplazar√° todas las coincidencias de searchValue.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
const saludo = "Hola mundo mundo";
const nuevoSaludo = saludo.replaceAll("mundo", "amigo");
console.log(nuevoSaludo); // "Hola amigo amigo"
```

En este caso, todas las apariciones de "mundo" se reemplazan por "amigo". Esto es muy √∫til cuando necesitas asegurarte de que todas las instancias de un texto espec√≠fico se cambien.

<h4 className="font-medium mt-5">Ejemplo usando expresiones regulares</h4>

```js copy filename="JavaScript"
const frase = "El color es rojo. El color es verde.";
const nuevaFrase = frase.replaceAll(/color/g, "tono");
console.log(nuevaFrase); // "El tono es rojo. El tono es verde."
```

Aqu√≠, se usa una expresi√≥n regular global (/color/g) para encontrar todas las apariciones de "color" y reemplazarlas por "tono". Las expresiones regulares globales son potentes para realizar reemplazos en todo el string.

<h4 className="font-medium mt-5">Ejemplo de reemplazo con funci√≥n</h4>

```js copy filename="JavaScript"
const frase = "Contar: 1, 2, 3, 4";
const nuevaFrase = frase.replaceAll(/\d/g, (match) => `(${match})`);
console.log(nuevaFrase); // "Contar: (1), (2), (3), (4)"
```

Aqu√≠, se utiliza una funci√≥n para envolver cada d√≠gito encontrado en par√©ntesis. La funci√≥n de reemplazo recibe el valor encontrado y devuelve el nuevo valor, permitiendo una transformaci√≥n compleja y din√°mica del string original.

### Modificar Cadenas de Texto

Modificar cadenas de texto es una operaci√≥n esencial en cualquier lenguaje de programaci√≥n. JavaScript proporciona varios m√©todos para transformar cadenas de texto. Vamos a detallar cada uno de estos m√©todos con ejemplos pr√°cticos para que puedas entender c√≥mo y cu√°ndo utilizarlos.

**M√©todo .toLowerCase()**

El m√©todo .toLowerCase() se utiliza para convertir todos los caracteres de una cadena a min√∫sculas. Esto puede ser particularmente √∫til cuando necesitamos normalizar el texto para comparaciones o b√∫squedas insensibles a may√∫sculas y min√∫sculas.

- **Funcionamiento**

.toLowerCase() recorre cada car√°cter de la cadena original y, si encuentra una letra may√∫scula, la convierte en min√∫scula. La cadena original no se modifica; en su lugar, se devuelve una nueva cadena con todos los caracteres en min√∫sculas.

- **Sintaxis**

```js copy filename="JavaScript"
string.toLowerCase();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Imagina que tienes un formulario donde el usuario puede ingresar su direcci√≥n de correo electr√≥nico, y quieres asegurarte de que la comparaci√≥n sea insensible a may√∫sculas y min√∫sculas.

```js copy filename="JavaScript"
const emailInput = "Usuario@Dominio.Com";
const normalizedEmail = emailInput.toLowerCase();
console.log(normalizedEmail); // "usuario@dominio.com"
```

**M√©todo `.toUpperCase()**

El m√©todo .toUpperCase() se utiliza para convertir todos los caracteres de una cadena a may√∫sculas. Este m√©todo es √∫til para enfatizar texto o para asegurar consistencia en la presentaci√≥n de datos.

- **Funcionamiento**

.toUpperCase() recorre cada car√°cter de la cadena original y, si encuentra una letra min√∫scula, la convierte en may√∫scula. La cadena original no se modifica; en su lugar, se devuelve una nueva cadena con todos los caracteres en may√∫sculas.

- **Sintaxis**

```js copy filename="JavaScript"
string.toUpperCase();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Imagina que tienes una cadena que quieres usar como t√≠tulo en una p√°gina web y quieres asegurarte de que se muestre en may√∫sculas.

```js copy filename="JavaScript"
const title = "bienvenidos a mi sitio web";
const upperTitle = title.toUpperCase();
console.log(upperTitle); // "BIENVENIDOS A MI SITIO WEB"
```

**M√©todo .padStart(size, text)**

El m√©todo .padStart() rellena la cadena actual con otra cadena hasta que la longitud resultante alcanza la longitud dada. Este m√©todo es √∫til para formatear datos, como n√∫meros o fechas, de manera uniforme.

-**Funcionamiento**

.padStart() a√±ade caracteres al inicio de la cadena original hasta que se alcanza la longitud especificada. Si la longitud especificada es menor o igual a la longitud de la cadena original, la cadena se devuelve sin cambios.

- **Sintaxis**

```js copy filename="JavaScript"
string.padStart(targetLength [, padString])
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Para mostrar n√∫meros siempre con al menos dos d√≠gitos, se puede utilizar .padStart().

```js copy filename="JavaScript"
const num = "5";
const paddedNum = num.padStart(2, "0");
console.log(paddedNum); // "05"
```

Si tienes identificadores que deben tener un formato fijo de longitud, .padStart() puede ser muy √∫til.

```js copy filename="JavaScript"
const id = "123";
const formattedId = id.padStart(6, "0");
console.log(formattedId); // "000123"
```

**M√©todo .padEnd(size, text)**

El m√©todo .padEnd() funciona de manera similar a .padStart(), pero a√±ade caracteres al final de la cadena. Este m√©todo es √∫til para alinear texto en una presentaci√≥n tabular o para crear strings con un formato espec√≠fico.

- **Funcionamiento**

.padEnd() a√±ade caracteres al final de la cadena original hasta que se alcanza la longitud especificada. Si la longitud especificada es menor o igual a la longitud de la cadena original, la cadena se devuelve sin cambios.

- **Sintaxis**

```js copy filename="JavaScript"
string.padEnd(targetLength [, padString])
```

<h4 className="font-medium mt-5">Ejemplo</h4>

Para alinear nombres en una presentaci√≥n tabular, puedes utilizar .padEnd().

```js copy filename="JavaScript"
const name = "Ana";
const paddedName = name.padEnd(10, " ");
console.log(paddedName); // "Ana       "
```

Si necesitas que las descripciones de productos tengan una longitud fija para alineaci√≥n, .padEnd() es √∫til.

```js copy filename="JavaScript"
const description = "Laptop";
const paddedDescription = description.padEnd(15, ".");
console.log(paddedDescription); // "Laptop........"
```

**M√©todo .trimStart()**

El m√©todo .trimStart() elimina los espacios en blanco al inicio de un string. Este m√©todo no modifica el string original, sino que devuelve una nueva cadena sin los espacios iniciales.

- **Funcionamiento**

El m√©todo .trimStart() opera sobre una instancia de cadena y elimina cualquier espacio en blanco (incluidos espacios, tabs, etc.) desde el comienzo de la cadena hasta que encuentra el primer car√°cter no blanco. Este m√©todo es particularmente √∫til cuando se trata de entradas de usuario, donde los espacios en blanco adicionales pueden introducir errores o inconsistencias.

- **Sintaxis**

```js copy filename="JavaScript"
string.trimStart();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo";
let trimmedText = text.trimStart();
console.log(trimmedText); // "Hola Mundo"
```

En este ejemplo, trimmedText contiene "Hola Mundo" sin los espacios iniciales.

```js copy filename="JavaScript"
let text = "\t\tJavaScript";
let trimmedText = text.trimStart();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, los caracteres de tabulaci√≥n (\t) al inicio de la cadena text se eliminan.

**M√©todo .trimEnd()**

El m√©todo .trimEnd() elimina los espacios en blanco al final de un string. Similar a .trimStart(), este m√©todo devuelve una nueva cadena sin los espacios finales.

- **Funcionamiento**

El m√©todo .trimEnd() se encarga de eliminar los espacios en blanco desde el final de la cadena hasta encontrar el primer car√°cter no blanco. Esto es √∫til para limpiar datos que pueden tener espacios adicionales al final, asegurando que las comparaciones y manipulaciones de cadenas sean precisas.

- **Sintaxis**

```js copy filename="JavaScript"
string.trimEnd();
```

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "Hola Mundo   ";
let trimmedText = text.trimEnd();
console.log(trimmedText); // "Hola Mundo"
```

En este caso, trimmedText resulta en "Hola Mundo" sin los espacios finales.

```js copy filename="JavaScript"
let text = "JavaScript\t\t";
let trimmedText = text.trimEnd();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, los caracteres de tabulaci√≥n (\t) al final de la cadena text se eliminan.

**M√©todo .trim()**

El m√©todo .trim() elimina los espacios en blanco tanto al inicio como al final de un string. Este m√©todo es una combinaci√≥n de .trimStart() y .trimEnd(), proporcionando una soluci√≥n completa para limpiar los espacios en blanco de los extremos de una cadena.

- **Sintaxis**

```js copy filename="JavaScript"
string.trim();
```

- **Funcionamiento**

El m√©todo .trim() es el m√°s completo de los tres, ya que se ocupa de eliminar todos los espacios en blanco tanto al principio como al final de una cadena. Esto es extremadamente √∫til en una variedad de situaciones, desde la limpieza de datos de entrada hasta la normalizaci√≥n de cadenas para comparaciones y almacenamiento.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo   ";
let trimmedText = text.trim();
console.log(trimmedText); // "Hola Mundo"
```

En este ejemplo, trimmedText contiene "Hola Mundo" sin los espacios en blanco al inicio y al final.

```js copy filename="JavaScript"
let text = "\t\tJavaScript\t\t";
let trimmedText = text.trim();
console.log(trimmedText); // "JavaScript"
```

Aqu√≠, tanto los caracteres de tabulaci√≥n (\t) al inicio como al final de la cadena text se eliminan.

### Ejercicios

A continuaci√≥n, presento una serie de quizes, preguntas y ejercicios dise√±ados para ayudarte a consolidar tu comprensi√≥n sobre los tipos de datos en JavaScript que hemos discutido. Cada ejercicio incluye una soluci√≥n para que puedas verificar tu trabajo.

**Quizes**

<h4 className="font-medium mt-5">
  1. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: " Hello World
  ".trimStart();
</h4>

<p className="my-2">a) "Hello World "</p>
<p>b) " Hello World"</p>
<p className="my-2">c) "Hello World"</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) "Hello World "</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øQu√© m√©todo utilizar√≠as para verificar si una cadena contiene la palabra
  "JavaScript"?
</h4>

<p className="my-2">a) .indexOf()</p>
<p>b) .includes()</p>
<p className="my-2">c) .search()</p>
<p className="mb-2">d) Todas las anteriores</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>d) Todas las anteriores</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "12345".slice(1, 3);
</h4>

<p className="my-2">a) 12</p>
<p>b) 234</p>
<p className="my-2">c) 23</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) 23</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øQu√© m√©todo se utiliza para convertir una cadena a min√∫sculas?
</h4>

<p className="my-2">a) .toLowerCase()</p>
<p>b) .toUpperCase()</p>
<p className="my-2">c) .toLocaleLowerCase()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) .toLowerCase()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: " JavaScript
  ".trimEnd();
</h4>

<p className="my-2">a) " JavaScript"</p>
<p>b) "JavaScript "</p>
<p className="my-2">c) "JavaScript"</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) " JavaScript"</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øQu√© m√©todo devuelve el √≠ndice de la primera ocurrencia de una subcadena?
</h4>

<p className="my-2">a) .search()</p>
<p>b) .indexOf()</p>
<p className="my-2">c) .find()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) .indexOf()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "Learning JavaScript".includes("Java");

</h4>

<p className="my-2">a) true</p>
<p>b) false</p>
<p className="my-2">c) undefined</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) true</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "Hello".charAt(0);
</h4>

<p className="my-2">a) H</p>
<p>b) e</p>
<p className="my-2">c) o</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>a) H</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øQu√© m√©todo se utiliza para dividir una cadena en un array de subcadenas
  basadas en un separador?
</h4>

<p className="my-2">a) .join()</p>
<p>b) .split()</p>
<p className="my-2">c) .slice()</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>b) .split()</AccordionContent>
  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øCu√°l ser√° el resultado de la siguiente expresi√≥n?: "JavaScript".substring(4, 10);

</h4>

<p className="my-2">a) Java</p>
<p>b) Script</p>
<p className="my-2">c) Scrip</p>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>c) Scrip</AccordionContent>
  </AccordionItem>
</Accordion>

**Preguntas**

<h4 className="font-medium mt-5">
  1. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco al inicio de una
  cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trimStart()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  2. ¬øCu√°l es la diferencia entre .includes() y .indexOf()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .includes() devuelve true o false si una cadena contiene una subcadena espec√≠fica, mientras que .indexOf() devuelve el √≠ndice de la primera ocurrencia de la subcadena o -1 si no se encuentra.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  3. ¬øC√≥mo se puede convertir una cadena a may√∫sculas?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .toUpperCase()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  4. ¬øQu√© m√©todo se utiliza para verificar si una cadena comienza con una
  subcadena espec√≠fica?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .startsWith()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  5. ¬øCu√°l es el prop√≥sito del m√©todo .slice() en cadenas de texto?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Extraer una secci√≥n de una cadena y devolverla como una nueva cadena, sin modificar la original.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  6. ¬øC√≥mo puedes dividir una cadena en un array de subcadenas?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .split()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  7. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco tanto al inicio
  como al final de una cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trim()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  8. ¬øCu√°l es la diferencia entre .substring() y .substr()?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .substring(start, end) devuelve una parte de la cadena entre start y end, mientras que .substr(start, length) devuelve una parte de la cadena desde start y con una longitud espec√≠fica length.

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  9. ¬øC√≥mo se puede reemplazar una subcadena en una cadena por otra subcadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      Usando el m√©todo .replace()

    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium mt-5">
  10. ¬øQu√© m√©todo se utiliza para eliminar espacios en blanco al final de una
  cadena?
</h4>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>

      .trimEnd()

    </AccordionContent>

  </AccordionItem>
</Accordion>

**Desaf√≠os**

<h4 className="font-medium my-5">
  1. Eliminar espacios en blanco al inicio y al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo   ";
        let trimmedText = text.trim();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  2. Verificar si una cadena contiene una subcadena espec√≠fica.
</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript es divertido";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript es divertido";
        let contains = text.includes("JavaScript");
        console.log(contains); // true
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">3. Convertir una cadena a may√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "hola mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "hola mundo";
        let upperText = text.toUpperCase();
        console.log(upperText); // "HOLA MUNDO"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  4. Reemplazar una subcadena en una cadena por otra subcadena.
</h4>

```js copy filename="JavaScript"
let text = "Me gusta programar en Java";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Me gusta programar en Java";
        let newText = text.replace("Java", "JavaScript");
        console.log(newText); // "Me gusta programar en JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">5. Extraer una parte de una cadena.</h4>

```js copy filename="JavaScript"
let text = "Aprendiendo JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Aprendiendo JavaScript";
        let part = text.slice(12, 22);
        console.log(part); // "JavaScript"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  6. Eliminar espacios en blanco al inicio de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "   Hola Mundo";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "   Hola Mundo";
        let trimmedText = text.trimStart();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  7. Eliminar espacios en blanco al final de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "Hola Mundo   ";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "Hola Mundo   ";
        let trimmedText = text.trimEnd();
        console.log(trimmedText); // "Hola Mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  8. Dividir una cadena en un array de subcadenas.
</h4>

```js copy filename="JavaScript"
let text = "rojo,azul,verde";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "rojo,azul,verde";
        let colors = text.split(",");
        console.log(colors); // ["rojo", "azul", "verde"]
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">
  9. Obtener el car√°cter en una posici√≥n espec√≠fica de una cadena.
</h4>

```js copy filename="JavaScript"
let text = "JavaScript";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "JavaScript";
        let char = text.charAt(4);
        console.log(char); // "S"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

<h4 className="font-medium my-5">10. Convertir una cadena a min√∫sculas.</h4>

```js copy filename="JavaScript"
let text = "HOLA MUNDO";
```

<div className="my-5">
  <Editor
    height="10vh"
    theme="vs-dark"
    defaultLanguage="javascript"
    defaultValue="// Escribe aqu√≠ tu c√≥digo JavaScript"
  />
</div>

<Accordion type="single" collapsible>
  <AccordionItem value="item-1">
    <AccordionTrigger>Respuesta</AccordionTrigger>
    <AccordionContent>
      <div>

        ```js copy filename="JavaScript"
        let text = "HOLA MUNDO";
        let lowerText = text.toLowerCase();
        console.log(lowerText); // "hola mundo"
        ```

      </div>
    </AccordionContent>

  </AccordionItem>
</Accordion>

## Boolean

En JavaScript, un Boolean es un tipo de dato primitivo que puede tener uno de dos valores posibles: true o false. Estos valores se utilizan principalmente para tomar decisiones en el flujo del programa, como en declaraciones condicionales y bucles. Veamos m√°s detalladamente c√≥mo funcionan y c√≥mo se utilizan los Booleanos en JavaScript.

### Creaci√≥n de Booleanos

Puedes crear valores Booleanos directamente utilizando las palabras clave true y false:

```js copy filename="JavaScript"
let isDataValid = true;
let isStringTooLong = false;
```

Tambi√©n puedes obtener valores Booleanos como resultado de evaluaciones l√≥gicas o comparaciones:

```js copy filename="JavaScript"
let isGreater = 10 > 5; // true
let isEqual = 10 === 10; // true
let isLesser = 5 < 3; // false
```

**Uso de Booleanos en Condicionales**

Los valores Booleanos son fundamentales en las estructuras de control, como las declaraciones if, que permiten ejecutar bloques de c√≥digo bas√°ndose en condiciones:

```js copy filename="JavaScript"
let isLoggedIn = true;

if (isLoggedIn) {
  console.log("User is logged in.");
} else {
  console.log("User is not logged in.");
}
```

En este ejemplo, si isLoggedIn es true, se ejecutar√° el primer bloque de c√≥digo. Si es false, se ejecutar√° el bloque en el else.

**Operadores L√≥gicos**

JavaScript proporciona varios operadores l√≥gicos que se pueden usar para manipular valores Booleanos:

- **NOT (!):** Invierte el valor de un Booleano.
- **AND (&&):** Devuelve true si ambos operandos son true.
- **OR (||):** Devuelve true si al menos uno de los operandos es true.

```js copy filename="JavaScript"
let isAdmin = false;
let isMember = true;

console.log(!isAdmin); // true
console.log(isAdmin && isMember); // false
console.log(isAdmin || isMember); // true
```

### Booleanos y Conversi√≥n Impl√≠cita

JavaScript convierte impl√≠citamente otros tipos de datos a Booleanos en contextos l√≥gicos. Los siguientes valores se consideran falsy (se convierten a false):

- false
- 0
- "" (cadena vac√≠a)
- null
- undefined
- NaN (Not-a-Number)

Cualquier otro valor se considera truthy (se convierte a true)

<h4 className="font-medium mt-5">Ejemplo de Conversi√≥n Impl√≠cita</h4>

```js copy filename="JavaScript"
if (0) {
  console.log("This won't be logged.");
}

if ("hello") {
  console.log("This will be logged.");
}
```

## Undefined

En JavaScript, undefined es un tipo de dato primitivo que indica que una variable no ha sido asignada a un valor. Es uno de los valores m√°s comunes que encontrar√°s y es fundamental comprender c√≥mo y cu√°ndo aparece para manejar correctamente los datos y evitar errores en el c√≥digo.

El tipo undefined tiene un √∫nico valor: undefined. Este es el valor por defecto que se asigna a una variable declarada pero no inicializada.

```js copy filename="JavaScript"
let miVariable;
console.log(typeof miVariable); // "undefined"
```

En este caso, miVariable es declarada pero no se le asigna ning√∫n valor, por lo que su tipo y su valor son undefined.

### Asignaci√≥n de undefined

Aunque es posible asignar expl√≠citamente undefined a una variable, generalmente se recomienda usar null para denotar la ausencia intencional de un valor. Usar undefined expl√≠citamente puede llevar a confusiones, ya que tambi√©n es el valor por defecto de variables no inicializadas.

```js copy filename="JavaScript"
console.log(typeof variableNoDeclarada); // "undefined"
console.log(variableNoDeclarada); // Uncaught ReferenceError: variableNoDeclarada is not defined
```

Este comportamiento puede ser √∫til para verificar la existencia de variables en el entorno global sin causar errores.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let miVariable = 10;
miVariable = undefined;
console.log(typeof miVariable); // "undefined"
```

## Null

En JavaScript, null es un tipo de dato primitivo que representa la ausencia intencional de cualquier valor de objeto. Este valor es utilizado para indicar que una variable que normalmente contendr√≠a un objeto est√° actualmente vac√≠a.

El valor null se asigna intencionalmente a una variable para denotar que no tiene valor. Es una forma expl√≠cita de decir que la variable est√° vac√≠a. A diferencia de undefined, que es el valor por defecto para las variables que han sido declaradas pero no inicializadas, null se utiliza para indicar deliberadamente la falta de un valor.

```js copy filename="JavaScript"
let emptyValue = null;
console.log(emptyValue); // null
```

En este ejemplo, emptyValue se inicializa expl√≠citamente con null para indicar que est√° vac√≠a.

**Diferencia entre null y undefined**

Aunque null y undefined pueden parecer similares, tienen significados distintos:

- **null:** Asignado intencionalmente para indicar ausencia de valor.
- **undefined:** Valor predeterminado para variables declaradas pero no inicializadas.

<h4 className="font-medium mt-5">Ejemplo</h4>

```js copy filename="JavaScript"
let variableA = null;
let variableB;

console.log(variableA); // null
console.log(variableB); // undefined
```

En este caso, variableA ha sido asignada expl√≠citamente con null, mientras que variableB no ha sido inicializada, resultando en undefined.

### Propiedades y Comportamiento de null

- **Tipo de Dato:** Aunque null es un valor primitivo, el operador typeof devuelve "object" cuando se aplica a null, lo cual es un error hist√≥rico en JavaScript.

```js copy filename="JavaScript"
let variable = null;
console.log(typeof variable); // "object"
```

- **Comparaciones:** null es igual a s√≠ mismo y a undefined (con el operador ==), pero no es estrictamente igual a undefined (con el operador ===).

```js copy filename="JavaScript"
console.log(null == undefined); // true
console.log(null === undefined); // false
```
